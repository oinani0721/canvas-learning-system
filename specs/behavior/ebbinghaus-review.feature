# specs/behavior/ebbinghaus-review.feature
# Generated by: PM Agent *create-behavior-spec
# Date: 2025-11-25
# Related: Epic 14, FR3, FR3.1-FR3.7, Story 14.1-14.15

@epic-14 @priority-critical @ebbinghaus
Feature: Ebbinghaus Review System - Spaced Repetition Learning
  As a learner
  I want an intelligent spaced repetition review system based on Ebbinghaus forgetting curve
  So that I can efficiently retain knowledge long-term and identify weak concepts

  # Common setup for all scenarios
  Background:
    Given the Canvas Learning System is initialized
    And the Ebbinghaus Review System is enabled
    And Py-FSRS algorithm is configured with default parameters
    And the user has an Obsidian vault with Canvas files

  # ═══════════════════════════════════════════════════════════
  # TRIGGER POINT 1: SCORING-BASED TRIGGERS
  # ═══════════════════════════════════════════════════════════

  @story-14.1 @smoke @trigger-point-1
  Scenario: Automatically add concept to review queue after scoring >= 60
    Given a Canvas "离散数学.canvas" with yellow node "yellow-001"
    And the node contains user understanding for concept "逆否命题"
    When the scoring-agent evaluates "yellow-001" with total score 72
    Then the concept "逆否命题" is added to the review system
    And a new FSRS Card is created with:
      | field           | value       |
      | concept         | 逆否命题    |
      | canvas_file     | 离散数学.canvas |
      | initial_mastery | 0.72        |
      | state           | New         |
    And the system logs "Added concept to review: 逆否命题 (score: 72)"

  @story-14.1 @trigger-point-1
  Scenario: Do not add concept to review queue when score < 60
    Given a Canvas "离散数学.canvas" with yellow node "yellow-002"
    And the node contains user understanding for concept "德摩根律"
    When the scoring-agent evaluates "yellow-002" with total score 45
    Then the concept "德摩根律" is NOT added to the review system
    And the node color remains red (needs more learning)
    And the system logs "Score below threshold, not adding to review: 德摩根律 (score: 45)"

  # ═══════════════════════════════════════════════════════════
  # TRIGGER POINT 4: BEHAVIOR MONITORING (v1.1.6)
  # ═══════════════════════════════════════════════════════════

  @story-14.10 @trigger-point-4 @three-layer-memory
  Scenario: Behavior monitoring detects inactive mastered concepts
    Given Temporal Memory contains learning records:
      | concept      | last_access | mastery | days_inactive |
      | 逆否命题     | 10 days ago | 0.75    | 10            |
      | 充分必要条件 | 3 days ago  | 0.82    | 3             |
      | 集合论       | 15 days ago | 0.68    | 15            |
    And the behavior monitoring runs at 2:00 AM daily
    When the monitor checks for inactive mastered concepts (threshold: 7 days, mastery >= 0.6)
    Then concepts ["逆否命题", "集合论"] are flagged for review
    And concept "充分必要条件" is not flagged (active within 7 days)
    And the flagged concepts are added to review queue with trigger_source "behavior_monitoring"

  @story-14.10 @trigger-point-4 @graphiti
  Scenario: Behavior monitoring detects knowledge gaps via Graphiti
    Given Graphiti knowledge graph contains:
      | concept        | prerequisite_mastery | dependent_concept | dependent_mastery |
      | 集合运算       | 0.85                 | 幂集              | null              |
      | 命题逻辑       | 0.90                 | 谓词逻辑          | null              |
    And "幂集" and "谓词逻辑" have never been studied (knowledge gap)
    When the monitor checks for knowledge gaps (gap_days_threshold: 14)
    Then concepts ["幂集", "谓词逻辑"] are identified as knowledge gaps
    And they are added to review queue with detection_reason "prerequisite_gap"

  @story-14.10 @trigger-point-4 @semantic-memory
  Scenario: Behavior monitoring detects implicit review needs from document access
    Given Semantic Memory records document interactions:
      | concept      | related_doc_access_count | concept_last_review |
      | 逆否命题     | 8                        | 12 days ago         |
      | 德摩根律     | 2                        | 5 days ago          |
    And the threshold is: related_access >= 5, concept_inactive >= 7 days
    When the monitor checks for implicit review needs
    Then concept "逆否命题" is flagged (8 accesses, 12 days inactive)
    And concept "德摩根律" is not flagged (only 2 accesses)

  # ═══════════════════════════════════════════════════════════
  # DAILY REVIEW PANEL
  # ═══════════════════════════════════════════════════════════

  @story-14.3 @smoke @ui
  Scenario: Display today's review panel on Obsidian startup
    Given today is 2025-01-20
    And the review system has due concepts:
      | canvas_file     | concept      | due_date   | urgency |
      | 离散数学.canvas | 逆否命题     | 2025-01-20 | high    |
      | 离散数学.canvas | 充分必要条件 | 2025-01-19 | urgent  |
      | 线性代数.canvas | 向量空间     | 2025-01-20 | medium  |
    When the user opens Obsidian
    Then the review panel sidebar displays:
      | canvas_name | due_concepts_count | urgency_level |
      | 离散数学    | 2                  | urgent        |
      | 线性代数    | 1                  | medium        |
    And the panel shows "今日复习: 3个概念待复习"
    And concepts are sorted by urgency (urgent > high > medium > low)

  @story-14.4 @ui
  Scenario: Click "Start Review" generates verification canvas
    Given the review panel shows "离散数学.canvas" with 2 due concepts
    When the user clicks "开始复习" button
    Then the system calls generate_review_canvas_file()
    And a new verification canvas "离散数学-检验白板-20250120.canvas" is created
    And the verification canvas opens in Obsidian
    And the verification canvas contains questions for due concepts

  @story-14.4 @ui
  Scenario: Postpone review by 1 day
    Given a due concept "逆否命题" with due_date 2025-01-20
    When the user clicks "推迟1天" for "逆否命题"
    Then the FSRS Card due_date is updated to 2025-01-21
    And the concept is removed from today's review panel
    And the system logs "Postponed review: 逆否命题 to 2025-01-21"

  # ═══════════════════════════════════════════════════════════
  # PY-FSRS ALGORITHM
  # ═══════════════════════════════════════════════════════════

  @story-14.1 @fsrs @algorithm
  Scenario: Py-FSRS calculates next review date after successful review
    Given an FSRS Card for "逆否命题" with:
      | field      | value |
      | state      | Review |
      | difficulty | 0.5   |
      | stability  | 10.0  |
    When the user completes review with rating "Good" (3)
    Then the FSRS algorithm updates the card:
      | field          | expected_change          |
      | stability      | increases (e.g., 15.2)   |
      | difficulty     | slightly decreases       |
      | due            | ~15 days from now        |
      | last_review    | today                    |
    And the next_review date is calculated based on forgetting curve

  @story-14.1 @fsrs
  Scenario Outline: FSRS rating determines next review interval
    Given an FSRS Card with stability 10.0
    When the user rates the review as "<rating>"
    Then the next review interval is approximately "<interval>"
    And the card state transitions to "<new_state>"

    Examples:
      | rating  | interval   | new_state |
      | Again   | 1 day      | Relearning |
      | Hard    | 5-7 days   | Review    |
      | Good    | 12-18 days | Review    |
      | Easy    | 25-35 days | Review    |

  # ═══════════════════════════════════════════════════════════
  # MULTI-DIMENSIONAL PRIORITY (v1.1.6)
  # ═══════════════════════════════════════════════════════════

  @story-14.11 @priority-calculation @three-layer-memory
  Scenario: Calculate multi-dimensional priority score
    Given a concept "逆否命题" with the following data:
      | dimension              | source          | value |
      | FSRS urgency           | Py-FSRS         | 8.5   |
      | behavior_weight        | Temporal Memory | 6.0   |
      | network_centrality     | Graphiti        | 7.2   |
      | interaction_weight     | Semantic Memory | 4.0   |
    And the weight configuration is:
      | dimension          | weight |
      | FSRS               | 40%    |
      | Behavior           | 30%    |
      | Network centrality | 20%    |
      | Interaction        | 10%    |
    When the system calculates multi-dimensional priority
    Then the priority score is:
      | calculation                                      | result |
      | 8.5*0.4 + 6.0*0.3 + 7.2*0.2 + 4.0*0.1          | 7.04   |
    And the concept priority_score is 7.04

  @story-14.11 @priority-calculation
  Scenario: Review list sorted by multi-dimensional priority
    Given due concepts with calculated priorities:
      | concept      | priority_score | urgency_level |
      | 逆否命题     | 8.5            | urgent        |
      | 德摩根律     | 6.2            | high          |
      | 集合论       | 4.8            | medium        |
    When the review panel displays the list
    Then concepts are ordered by priority_score descending
    And "逆否命题" appears first (highest priority)

  # ═══════════════════════════════════════════════════════════
  # TARGETED REVIEW MODE (v1.1.8)
  # ═══════════════════════════════════════════════════════════

  @story-14.5 @story-14.14 @targeted-review @v1.1.8
  Scenario: Generate verification canvas with targeted review mode
    Given "离散数学.canvas" has historical review records in Graphiti:
      | review_date | weak_concepts                | mastered_concepts           |
      | 2025-01-10  | ["逆否命题", "德摩根律"]     | ["充分条件", "必要条件"]    |
      | 2025-01-17  | ["逆否命题"]                 | ["德摩根律", "充分条件"]    |
    And the user selects "针对性复习" (targeted review) mode
    When the user clicks "开始复习"
    Then the system calls query_review_history_from_graphiti()
    And calculates targeted review weights:
      | concept_type | weight | count |
      | weak         | 70%    | 14    |
      | mastered     | 30%    | 6     |
    And the verification canvas prioritizes "逆否命题" (most recent weak)
    And includes some mastered concepts to prevent forgetting

  @story-14.5 @fresh-review @v1.1.8
  Scenario: Generate verification canvas with fresh review mode
    Given "离散数学.canvas" has historical review records
    And the user selects "全新检验" (fresh review) mode
    When the user clicks "开始复习"
    Then the system does NOT query review history
    And generates questions evenly distributed across all concepts
    And the verification canvas tests all concepts without bias

  @story-14.15 @ui @v1.1.8
  Scenario: Review mode selection modal dialog
    Given the user clicks "开始复习" button
    When the review mode modal appears
    Then it displays two options:
      | option         | description                                     |
      | 全新检验       | 不参考历史数据，盲测式检验                       |
      | 针对性复习     | 基于历史薄弱概念生成问题（70%薄弱+30%已掌握）   |
    And the default option matches user settings
    When the user selects "针对性复习"
    Then the verification canvas is generated with targeted mode

  @story-14.13 @graphiti @v1.1.8
  Scenario: Store review canvas relationship in Graphiti
    Given a verification canvas "离散数学-检验白板-20250120.canvas" is generated
    And the original canvas is "离散数学.canvas"
    And the review mode is "targeted"
    And the results are: passed 12/15 nodes
    When the system stores the relationship
    Then Graphiti creates a relationship:
      | from_node                           | relationship   | to_node           |
      | 离散数学-检验白板-20250120.canvas   | GENERATED_FROM | 离散数学.canvas   |
    And the relationship metadata includes:
      | field           | value                              |
      | mode            | targeted                           |
      | timestamp       | 2025-01-20T10:00:00Z               |
      | total_nodes     | 15                                 |
      | passed_nodes    | 12                                 |
      | weak_concepts   | ["逆否命题", "集合论", "幂集"]     |
      | mastered_concepts | ["充分条件", ...]                |

  # ═══════════════════════════════════════════════════════════
  # FSRS PARAMETER OPTIMIZATION (v1.1.6)
  # ═══════════════════════════════════════════════════════════

  @story-14.12 @fsrs-optimization @v1.1.6
  Scenario: Optimize FSRS parameters from real learning behavior
    Given Temporal Memory contains 150+ review records for the user
    And the current FSRS parameters are default (17 params)
    When the monthly optimization task runs (1st day of month, 3:00 AM)
    Then the system extracts review history from Temporal Memory
    And runs gradient descent optimization on 17 parameters
    And the optimized parameters achieve lower RMSE than default
    And the new parameters are persisted to the database
    And the user's FSRS algorithm uses optimized parameters

  @story-14.12 @fsrs-optimization @edge-case
  Scenario: Skip FSRS optimization when insufficient data
    Given Temporal Memory contains only 50 review records
    And the minimum threshold is 100 records
    When the monthly optimization task runs
    Then the system logs "Insufficient data for FSRS optimization (50 < 100)"
    And the optimization is skipped
    And default FSRS parameters continue to be used

  # ═══════════════════════════════════════════════════════════
  # REVIEW HISTORY
  # ═══════════════════════════════════════════════════════════

  @story-14.6 @history
  Scenario: View review history for past 7 days
    Given the user has completed reviews:
      | date       | concepts_reviewed | avg_score |
      | 2025-01-19 | 5                 | 78        |
      | 2025-01-18 | 3                 | 82        |
      | 2025-01-17 | 7                 | 71        |
    When the user opens review history (7-day view)
    Then the panel displays:
      | metric              | value |
      | total_concepts      | 15    |
      | average_score       | 77    |
      | review_streak_days  | 3     |
    And a daily trend chart is rendered

  @story-14.6 @history @v1.1.8
  Scenario: View multi-review progress trends
    Given "离散数学.canvas" has 3 historical verification reviews:
      | review_date | progress_rate | mode     |
      | 2025-01-10  | 60%           | fresh    |
      | 2025-01-17  | 75%           | targeted |
      | 2025-01-24  | 88%           | targeted |
    When the user views "历史对比" tab
    Then the panel displays:
      | metric           | value              |
      | overall_trend    | improving          |
      | improvement_rate | 28% (60% -> 88%)   |
      | review_count     | 3                  |
    And a progress curve chart shows the trend
    And concept-level trends show:
      | concept  | history        | first_pass_review |
      | 逆否命题 | [fail, fail, pass] | 3              |
      | 德摩根律 | [fail, pass, pass] | 2              |

  # ═══════════════════════════════════════════════════════════
  # EDGE CASES AND ERROR HANDLING
  # ═══════════════════════════════════════════════════════════

  @story-14.3 @edge-case
  Scenario: Display empty state when no concepts due for review
    Given no concepts are due for review today
    When the user opens Obsidian
    Then the review panel displays:
      | message | "今日无复习任务，继续保持！" |
      | icon    | celebration emoji           |
    And a "查看学习统计" button is shown

  @story-14.7 @notification
  Scenario: Review reminder notification on Obsidian startup
    Given review notifications are enabled in settings
    And 3 concepts are due for review today
    When the user opens Obsidian
    Then an Obsidian Notice displays:
      | title   | "Canvas学习提醒"              |
      | message | "今日有3个概念需要复习"       |
      | action  | "开始复习" button             |
    And clicking the button opens the review panel

  @story-14.7 @notification @edge-case
  Scenario: No notification when notifications disabled
    Given review notifications are disabled in settings
    And 5 concepts are due for review today
    When the user opens Obsidian
    Then no notification is displayed
    But the review panel sidebar still shows due concepts

  @error @edge-case
  Scenario: Handle FSRS database connection failure
    Given the SQLite database is temporarily unavailable
    When a scoring event triggers add_concept_for_review()
    Then the system logs the error
    And records the failed concept to "review_system_errors.json"
    And the main scoring flow continues (non-blocking)
    And a background retry is scheduled

  @error @edge-case
  Scenario: Handle Graphiti connection failure during targeted review
    Given the user selects "针对性复习" mode
    And Graphiti (Neo4j) is temporarily unavailable
    When the system attempts to query review history
    Then the query fails with timeout
    And the system falls back to "全新检验" mode
    And logs warning: "Graphiti unavailable, falling back to fresh review mode"
    And the user is notified of the fallback

  # ═══════════════════════════════════════════════════════════
  # PERFORMANCE REQUIREMENTS
  # ═══════════════════════════════════════════════════════════

  @performance
  Scenario: Review panel loads within acceptable time
    Given the review system has 100+ concepts in the database
    When the user opens Obsidian
    Then the review panel loads within 500ms
    And due concepts are displayed within 1 second
    And the UI remains responsive during loading

  @performance @trigger-point-4
  Scenario: Behavior monitoring completes within time limit
    Given the three-layer memory system contains:
      | layer    | records |
      | Temporal | 5000    |
      | Graphiti | 3000    |
      | Semantic | 2000    |
    When the daily behavior monitoring runs at 2:00 AM
    Then all three queries complete within 30 seconds
    And detected concepts are batch-added to review queue
    And the monitoring report is generated
