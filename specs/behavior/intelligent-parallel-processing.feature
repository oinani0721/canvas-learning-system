# specs/behavior/intelligent-parallel-processing.feature
# Generated by: PM Agent *create-behavior-spec (Incremental Mode)
# Date: 2025-11-25
# Related: Epic 10, FR2.1, Story 10.15, Story 13.8

@epic-10 @fr2.1 @priority-high
Feature: Intelligent Parallel Processing UI
  As a learner
  I want to batch process multiple yellow nodes with intelligent grouping
  So that I can efficiently generate learning materials with minimal manual intervention

  # ══════════════════════════════════════════════════════════════════
  # BACKGROUND
  # ══════════════════════════════════════════════════════════════════

  Background:
    Given the Canvas Learning System Obsidian plugin is loaded
    And the user has an active Canvas file open
    And the AsyncExecutionEngine is initialized

  # ══════════════════════════════════════════════════════════════════
  # SECTION 1: UI ENTRY SCENARIOS
  # ══════════════════════════════════════════════════════════════════

  @story-13.8 @smoke @ui
  Scenario: Click smart batch processing button triggers grouping analysis
    Given Canvas "离散数学.canvas" contains 12 yellow nodes
    And yellow node content covers "对比类", "澄清类", "记忆类" concepts
    When user clicks the ribbon icon "Smart Batch Processing"
    Then system executes TF-IDF vectorization and K-Means clustering
    And analysis completes within 3 seconds
    And a Modal dialog "智能并行处理 - 分组预览" is displayed
    # UI Implementation: this.addRibbonIcon('zap', 'Smart Batch Processing', callback)
    # Modal Implementation: class SmartParallelModal extends Modal

  @story-13.8 @ui @error-handling
  Scenario: No yellow nodes shows notification
    Given Canvas "已完成.canvas" contains only red and green nodes
    And there are no yellow nodes
    When user clicks the ribbon icon "Smart Batch Processing"
    Then a Notice "当前Canvas无黄色节点可处理" is displayed
    And no Modal dialog is opened
    # UI Implementation: new Notice('当前Canvas无黄色节点可处理')

  # ══════════════════════════════════════════════════════════════════
  # SECTION 2: INTELLIGENT CLUSTERING SCENARIOS
  # ══════════════════════════════════════════════════════════════════

  @story-13.8 @clustering
  Scenario: TF-IDF vectorization and K-Means clustering groups correctly
    Given 12 yellow nodes with content:
      | node_id    | content                    | expected_group |
      | yellow-001 | 逆否命题 vs 否命题         | 对比类         |
      | yellow-002 | 充分条件 vs 必要条件       | 对比类         |
      | yellow-003 | 集合论基础概念澄清         | 澄清类         |
      | yellow-004 | 命题逻辑详细解释           | 澄清类         |
    When system executes TF-IDF vectorization
    And K-Means clustering with k=auto and max_k=5
    Then semantically similar nodes are grouped together
    And "逆否命题vs否命题" and "充分条件vs必要条件" are in the same group
    And total group count is between 2 and 5

  @story-13.8 @clustering
  Scenario: Agent auto-recommendation based on group keywords
    Given a group contains comparison concepts "逆否命题vs否命题"
    When system analyzes group content keywords
    Then recommended Agent is "comparison-table"
    And confidence score is displayed

  @story-13.8 @ui
  Scenario: Group preview Modal displays details
    Given clustering is complete with 4 groups
    When Modal renders group information
    Then each group displays:
      | field          | example                   |
      | group_name     | "对比类概念"              |
      | node_count     | 3                         |
      | recommended_agent | comparison-table       |
      | priority       | High                      |
    And user can modify grouping via Setting dropdowns
    # UI Implementation: new Setting(contentEl).addDropdown(...)

  # ══════════════════════════════════════════════════════════════════
  # SECTION 3: EXECUTION AND PROGRESS SCENARIOS
  # ══════════════════════════════════════════════════════════════════

  @story-13.8 @smoke
  Scenario: Start parallel execution
    Given user has confirmed group preview in Modal
    When user clicks "开始处理" button
    Then AsyncExecutionEngine starts processing
    And Modal transitions to progress view
    And real-time progress is displayed
    # UI Implementation: .addButton(btn => btn.setButtonText('开始处理').setCta().onClick(...))

  @story-13.8 @websocket @realtime
  Scenario: WebSocket real-time progress push
    Given smart parallel processing is started with 4 groups
    And WebSocket connection is established
    When Group 1 (comparison-table) completes execution
    Then WebSocket pushes progress update message:
      | field           | value                    |
      | type            | progress_update          |
      | completed_groups| 1                        |
      | total_groups    | 4                        |
      | percentage      | 25%                      |
      | current_group   | Group 2                  |
    And frontend progress bar updates within 500ms
    And status displays "Group 1 completed"

  @story-13.8 @ui
  Scenario: Completion result display
    Given all groups have finished execution
    When results are summarized
    Then Modal displays completion summary:
      | metric          | value                    |
      | total_groups    | 4                        |
      | completed       | 4                        |
      | total_time      | 45s                      |
      | generated_files | 12                       |
    And list of generated .md files is shown
    And user can click to open any generated file

  # ══════════════════════════════════════════════════════════════════
  # SECTION 4: RESOURCE SCHEDULING AND ERROR HANDLING
  # ══════════════════════════════════════════════════════════════════

  @story-10.15 @resource-aware @performance
  Scenario: ResourceAwareScheduler dynamically adjusts concurrency
    Given system initial concurrency is 50
    And current system resource status:
      | metric       | value |
      | cpu_usage    | 85%   |
      | memory_usage | 70%   |
    When ResourceAwareScheduler executes resource check
    Then detects CPU overload (>80% threshold)
    And automatically reduces concurrency to 20
    And logs "Resource protection: reducing concurrency 50 -> 20"
    And existing tasks continue execution with new concurrency for new tasks

  @story-13.8 @error-handling
  Scenario: Partial Agent failure does not interrupt overall execution
    Given 4 groups are executing in parallel
    And Group 2's clarification-path Agent encounters API timeout
    When system handles Agent execution error
    Then Group 2 is marked as "failed"
    And Groups 1, 3, 4 continue normal execution
    And final status is "partial_failure"
    And completion result displays:
      | metric          | value |
      | completed_count | 3     |
      | failed_count    | 1     |
      | success_rate    | 75%   |
    And failed group shows retry button

  @story-13.8 @ui
  Scenario: User cancels execution
    Given execution progress is at 50%
    When user clicks "取消" button in Modal
    Then currently executing tasks complete normally
    And no new tasks are started
    And already completed results are preserved
    And status displays "已取消 - 部分完成"

  # ══════════════════════════════════════════════════════════════════
  # SECTION 5: CANVAS OUTPUT AND PERFORMANCE
  # ══════════════════════════════════════════════════════════════════

  @story-13.8 @canvas-structure
  Scenario: 3-layer Canvas structure generated correctly
    Given yellow node "yellow-001" concept is "逆否命题"
    And oral-explanation Agent generated 1200-word explanation
    When system writes to Canvas
    Then Canvas adds 3-layer structure:
      | layer | type       | content                           |
      | 1     | yellow node| yellow-001 (original)             |
      | 2     | blue TEXT  | "口语化解释 - 逆否命题"           |
      | 3     | file node  | 逆否命题-oral-explanation.md      |
    And edges connect: yellow-001 -> blue TEXT -> file node
    And .md file is saved to Canvas same directory
    # Canvas API: canvasData.nodes.push(newNode); canvasData.edges.push(newEdge);
    # File save: await this.app.vault.modify(file, JSON.stringify(canvasData, null, 2));

  @story-10.15 @performance @benchmark
  Scenario Outline: Parallel processing performance improvement verification
    Given <node_count> yellow nodes need processing
    And each node average Agent execution time is <avg_time> seconds
    When using smart parallel processing with concurrency <concurrency>
    Then total execution time < <max_total_time> seconds
    And parallel efficiency (speedup) >= <speedup>x

    Examples:
      | node_count | avg_time | concurrency | max_total_time | speedup |
      | 10         | 10       | 10          | 15             | 6       |
      | 50         | 8        | 50          | 20             | 20      |
      | 100        | 10       | 50          | 30             | 30      |

  @story-10.15 @performance
  Scenario: Concurrency limit matrix verification
    Given system resources are sufficient
    When executing large batch tasks
    Then Agent-level concurrency <= 100
    And Node-level concurrency <= 50
    And System maximum concurrency <= 500
    And limits are enforced by AsyncExecutionEngine

  # ══════════════════════════════════════════════════════════════════
  # SECTION 6: EDGE CASES
  # ══════════════════════════════════════════════════════════════════

  @story-13.8 @error-handling
  Scenario: Single node in group uses default Agent
    Given clustering results in a group with only 1 node
    And the node content is "量子力学薛定谔方程"
    When system cannot determine Agent from keywords
    Then default Agent "oral-explanation" is assigned
    And user can override via dropdown in preview Modal

  @story-13.8 @error-handling
  Scenario: Canvas file locked by another process
    Given Canvas file is being edited in another Obsidian window
    When system attempts to write 3-layer structure
    Then system retries 3 times with 500ms intervals
    And if all retries fail, shows Notice "Canvas文件被锁定，请关闭其他编辑窗口"
    And generated content is cached for manual retry

  @story-10.15 @resource-aware
  Scenario: Memory pressure triggers garbage collection
    Given memory usage exceeds 90%
    When ResourceAwareScheduler detects memory pressure
    Then forces garbage collection
    And pauses new task scheduling for 5 seconds
    And logs "Memory pressure detected, GC triggered"
    And resumes when memory drops below 80%

  # ══════════════════════════════════════════════════════════════════
  # SECTION 7: INTEGRATION WITH OTHER FEATURES
  # ══════════════════════════════════════════════════════════════════

  @story-13.8 @integration
  Scenario: Results integrate with Ebbinghaus review system
    Given smart parallel processing completed for 12 nodes
    And 12 explanation documents were generated
    When processing completes
    Then each generated document is registered with FSRS
    And initial review interval is set to 1 day
    And documents appear in daily review panel

  @story-13.8 @integration
  Scenario: Generated nodes maintain source reference
    Given yellow node "yellow-001" was processed
    And generated blue TEXT node "text-001"
    When examining the generated node
    Then node contains sourceNodeId: "yellow-001"
    And clicking "查看原节点" navigates to yellow-001
