# specs/behavior/langgraph-supervisor.feature
# Generated by: PM Agent *create-behavior-spec
# Date: 2025-11-25
# Related: Epic 12, Story 12.1-12.16

@epic-12 @priority-p0
Feature: LangGraph Supervisor Multi-Agent Orchestration
  As a system architect
  I want a LangGraph Supervisor to orchestrate 12 learning agents
  So that agents can execute concurrently with proper state management

  # ══════════════════════════════════════════════════════════════════
  # BACKGROUND
  # ══════════════════════════════════════════════════════════════════

  Background:
    Given the LangGraph StateGraph is compiled
    And all 12 learning agents are registered as nodes
    And PostgresSaver checkpointer is configured

  # ══════════════════════════════════════════════════════════════════
  # SECTION 1: SUPERVISOR ROUTING
  # ══════════════════════════════════════════════════════════════════

  @story-12.5 @smoke
  Scenario: Supervisor routes to correct agent based on operation
    Given CanvasLearningState contains:
      | field     | value              |
      | operation | basic_decompose    |
      | node_id   | node-001           |
      | content   | 逆否命题           |
    When StateGraph executes supervisor_router
    Then routing decision is "basic_decomposition" agent
    And state is passed to basic_decomposition node

  @story-12.5
  Scenario Outline: Supervisor routing map validation
    Given operation type is "<operation>"
    When supervisor_router evaluates routing
    Then next node should be "<agent_node>"

    Examples:
      | operation       | agent_node          |
      | basic_decompose | basic_decomposition |
      | deep_decompose  | deep_decomposition  |
      | score           | scoring_agent       |
      | oral_explain    | oral_explanation    |
      | four_level      | four_level_explain  |
      | compare         | comparison_table    |
      | memory_anchor   | memory_anchor       |
      | example_teach   | example_teaching    |
      | clarify         | clarification_path  |
      | verify_question | verification_qa     |

  @story-12.5
  Scenario: Supervisor handles parallel operations
    Given CanvasLearningState contains:
      | field               | value                              |
      | parallel_mode       | true                               |
      | parallel_operations | ["basic_decompose", "oral_explain"]|
    When supervisor_router evaluates routing
    Then routing returns Command with goto list
    And both "basic_decomposition" and "oral_explanation" are scheduled
    And agents execute concurrently

  # ══════════════════════════════════════════════════════════════════
  # SECTION 2: TOOL-EQUIPPED AGENTS
  # ══════════════════════════════════════════════════════════════════

  @story-12.6 @smoke
  Scenario: Agent writes to Canvas using equipped tool
    Given basic_decomposition agent is executing
    And agent generated question "什么是逆否命题的定义？"
    When agent calls write_to_canvas tool
    Then tool acquires FileLock on Canvas file
    And new node is added to Canvas JSON
    And FileLock is released
    And agent returns "已添加节点 q-001"

  @story-12.6
  Scenario: Multiple agents write concurrently with FileLock
    Given 3 agents are executing in parallel:
      | agent               | action        |
      | basic_decomposition | add_node      |
      | scoring_agent       | update_color  |
      | oral_explanation    | add_file_node |
    When all agents call write_to_canvas simultaneously
    Then FileLock ensures sequential writes
    And no data corruption occurs
    And all 3 operations complete successfully
    And average lock wait time < 100ms

  @story-12.6
  Scenario: Agent creates markdown file and links to Canvas
    Given oral_explanation agent generated 1200-word explanation
    When agent executes tool sequence:
      | step | tool             | parameters                    |
      | 1    | create_md_file   | content, filename             |
      | 2    | write_to_canvas  | file_node with path           |
      | 3    | add_edge_to_canvas| source_node, file_node       |
    Then "逆否命题-oral-explanation.md" is created
    And blue FILE node appears on Canvas
    And edge connects original node to FILE node

  # ══════════════════════════════════════════════════════════════════
  # SECTION 3: STATE MANAGEMENT (CHECKPOINTER)
  # ══════════════════════════════════════════════════════════════════

  @story-12.7 @smoke
  Scenario: Checkpointer persists state after each step
    Given thread_id is "canvas_离散数学_abc123"
    And agent completes an operation
    When state is returned from agent node
    Then PostgresSaver persists state snapshot
    And checkpoint includes:
      | field          | persisted |
      | node_results   | yes       |
      | write_history  | yes       |
      | messages       | yes       |
      | current_step   | yes       |

  @story-12.7
  Scenario: Resume from checkpoint after interruption
    Given previous session with thread_id "canvas_离散数学_abc123"
    And session was interrupted at step 3
    When new session invokes graph with same thread_id
    Then state is restored from PostgresSaver
    And execution resumes from step 3
    And previously completed operations are not repeated

  @story-12.7
  Scenario: Multi-turn conversation context maintained
    Given user had previous conversation about "逆否命题"
    And conversation is stored in checkpointer
    When user asks follow-up question "请继续解释"
    Then agent has access to previous context
    And response is contextually relevant
    And no repetition of previous explanations

  # ══════════════════════════════════════════════════════════════════
  # SECTION 4: WRITE HISTORY AND ROLLBACK
  # ══════════════════════════════════════════════════════════════════

  @story-12.8 @smoke
  Scenario: Record write operations in history
    Given agent writes 3 nodes to Canvas
    When each write_to_canvas is called
    Then WriteHistory records:
      | timestamp           | operation | node_id |
      | 2025-11-25T10:30:01 | add_node  | q-001   |
      | 2025-11-25T10:30:02 | add_node  | q-002   |
      | 2025-11-25T10:30:03 | add_node  | q-003   |
    And Canvas snapshot is created before each operation

  @story-12.8
  Scenario: Rollback N steps
    Given WriteHistory contains 5 operations
    And Canvas has 5 added nodes
    When user requests rollback 3 steps via API
    Then Canvas is restored to state before step 3
    And nodes q-003, q-004, q-005 are removed
    And rollback result shows "已回滚3步"

  @story-12.8
  Scenario: Rollback to specific timestamp
    Given WriteHistory contains operations spanning 10 minutes
    When user requests rollback to timestamp "2025-11-25T10:35:00"
    Then Canvas is restored to snapshot at that timestamp
    And all operations after timestamp are undone
    And API returns restored snapshot details

  @story-12.8 @ui
  Scenario: User triggers rollback from error dialog
    Given agent operation failed with error
    And error modal shows "scoring-agent评分失败"
    When user clicks "回滚到错误前" button
    Then POST /api/canvas/rollback is called
    And Canvas is restored to pre-error state
    And success Notice "已恢复到操作前状态" is displayed

  # ══════════════════════════════════════════════════════════════════
  # SECTION 5: FILELOCK CONCURRENCY
  # ══════════════════════════════════════════════════════════════════

  @story-12.9
  Scenario: FileLock timeout handling
    Given Agent A holds FileLock for >10 seconds (stuck)
    When Agent B attempts to acquire lock
    Then Agent B waits up to timeout (10 seconds)
    And after timeout, TimeoutError is raised
    And error logged "无法获取文件锁: 离散数学.canvas.lock"
    And Agent B retries or notifies user

  @story-12.9
  Scenario: FileLock cross-platform compatibility
    Given system is running on "<platform>"
    When FileLock is acquired and released
    Then platform-specific locking mechanism is used
    And lock file is created and cleaned up properly

    Examples:
      | platform |
      | Windows  |
      | macOS    |
      | Linux    |

  @story-12.9
  Scenario: Lock file cleanup on process crash
    Given previous process crashed while holding FileLock
    And stale lock file exists
    When new process starts and detects stale lock
    Then stale lock is cleaned up after 60 seconds idle
    And new process can acquire lock normally

  # ══════════════════════════════════════════════════════════════════
  # SECTION 6: CANVAS ORCHESTRATOR INTEGRATION
  # ══════════════════════════════════════════════════════════════════

  @story-12.10
  Scenario: Canvas orchestrator generates execution plan
    Given user input "拆解并评分'逆否命题'这个节点"
    When canvas_orchestrator parses intent
    Then plan contains multiple operations:
      | step | operation       | target  |
      | 1    | basic_decompose | node-001|
      | 2    | score           | generated_nodes |
    And plan is passed to LangGraph Supervisor

  @story-12.10
  Scenario: Orchestrator handles ambiguous intent
    Given user input "处理这个节点"
    When canvas_orchestrator parses intent
    Then orchestrator asks for clarification
    And returns available operations:
      | option | operation    |
      | 1      | 基础拆解     |
      | 2      | 深度拆解     |
      | 3      | 评分         |
      | 4      | 口语化解释   |

  # ══════════════════════════════════════════════════════════════════
  # SECTION 7: PERFORMANCE REQUIREMENTS
  # ══════════════════════════════════════════════════════════════════

  @story-12.11 @performance
  Scenario: First node appears within 1 second
    Given user requests basic_decompose operation
    When agent starts processing
    Then first question node appears on Canvas within 1 second
    And subsequent nodes appear every 0.5 seconds
    And user sees real-time feedback

  @story-12.11 @performance
  Scenario: Parallel execution maintains Epic 10.2 performance
    Given 50 nodes need processing
    And parallel concurrency is 50
    When AsyncExecutionEngine processes all nodes
    Then performance improvement is >= 3x vs sequential
    And total time < (sequential_time / 3)

  @story-12.11 @performance
  Scenario: Checkpointer does not block agent execution
    Given checkpointer is persisting state
    When agent continues execution
    Then checkpoint persistence is async
    And agent execution is not blocked
    And write latency < 50ms

  # ══════════════════════════════════════════════════════════════════
  # SECTION 8: ERROR HANDLING
  # ══════════════════════════════════════════════════════════════════

  @story-12.12 @error-handling
  Scenario: Agent execution error does not crash graph
    Given scoring_agent encounters API timeout
    When error occurs during agent execution
    Then error is caught and logged
    And state is updated with error information
    And graph can continue or gracefully terminate
    And user is notified of partial failure

  @story-12.12 @error-handling
  Scenario: Database connection loss recovery
    Given PostgresSaver loses connection to database
    When agent completes and attempts checkpoint
    Then checkpointer retries 3 times with exponential backoff
    And if recovery fails, in-memory fallback is used
    And warning is logged and user notified

  @story-12.12 @error-handling
  Scenario: Canvas file not found during write
    Given agent attempts to write to "不存在.canvas"
    When write_to_canvas is called
    Then tool returns error "Canvas文件不存在"
    And state records failed operation
    And user can create file or choose different Canvas

  # ══════════════════════════════════════════════════════════════════
  # SECTION 9: THREAD ID MANAGEMENT
  # ══════════════════════════════════════════════════════════════════

  @story-12.13
  Scenario: Thread ID format follows convention
    Given Canvas file "笔记库/离散数学/离散数学.canvas"
    And session UUID is "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
    When config is created for graph invocation
    Then thread_id is "canvas_离散数学_a1b2c3d4-e5f6-7890-abcd-ef1234567890"
    And thread_id is unique per session

  @story-12.13
  Scenario: Session timeout and thread cleanup
    Given session has been inactive for 30 days
    When cleanup job runs
    Then thread checkpoints are archived
    And in-memory session data is cleared
    And user must start new session for this Canvas

  # ══════════════════════════════════════════════════════════════════
  # SECTION 10: CONFIG PARAMETER STRUCTURE
  # ══════════════════════════════════════════════════════════════════

  @story-12.14
  Scenario: Config contains all required parameters
    Given Canvas operation is initiated
    When create_langgraph_config is called
    Then config contains:
      | field                         | value                      |
      | configurable.thread_id        | canvas_{name}_{session_id} |
      | configurable.canvas_path      | absolute path              |
      | configurable.user_id          | user identifier            |
      | configurable.session_id       | UUID v4                    |
      | configurable.checkpoint_ns    | canvas_learning            |

  @story-12.14
  Scenario: Config enables checkpoint recovery
    Given config with checkpoint_id specified
    When graph is invoked with config
    Then graph resumes from specified checkpoint
    And not from latest checkpoint
