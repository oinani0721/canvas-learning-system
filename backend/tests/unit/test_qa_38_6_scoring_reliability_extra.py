"""
Story 38.6 QA: Supplementary Tests — Scoring Write Reliability

Generated by Quinn QA Automate workflow.
Covers gaps identified in existing test_story_38_6_scoring_reliability.py:

- Integration tests for _write_with_timeout behavior
- Concurrent failed-write safety
- Edge cases: empty file, parent directory creation
- Full cycle: fail → record → recover → merged view
- Sort order after merge
"""
import asyncio
import json
import pytest
from datetime import datetime
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, patch

from tests.conftest import simulate_async_delay

from app.services.agent_service import (
    MEMORY_WRITE_TIMEOUT,
    _record_failed_write,
)
from app.services.memory_service import (
    GRAPHITI_JSON_WRITE_TIMEOUT,
    GRAPHITI_RETRY_BACKOFF_BASE,
    MemoryService,
)
from app.core.failed_writes_constants import FAILED_WRITES_FILE


# ═══════════════════════════════════════════════════════════════════
# AC-2 Supplement: _write_with_timeout integration
# ═══════════════════════════════════════════════════════════════════


class TestWriteWithTimeoutIntegration:
    """Verify _write_with_timeout correctly calls _record_failed_write on failures."""

    @pytest.fixture
    def agent_service(self):
        """Create an AgentService with minimal mocks for trigger_memory_write."""
        from app.services.agent_service import AgentService

        svc = AgentService.__new__(AgentService)
        svc.gemini_client = MagicMock()
        svc.logger = MagicMock()
        return svc

    @pytest.mark.asyncio
    async def test_timeout_triggers_record_failed_write(self, tmp_path):
        """[P0] When inner write times out, _record_failed_write is called."""
        fallback_file = tmp_path / "data" / "failed_writes.jsonl"

        async def slow_write(*args, **kwargs):
            # JUSTIFIED: Mock simulating slow write; cancelled by asyncio.wait_for, not a hard wait
            await simulate_async_delay(30)

        with patch("app.core.failed_writes_constants.FAILED_WRITES_FILE", fallback_file), \
             patch("app.services.agent_service.FAILED_WRITES_FILE", fallback_file), \
             patch("app.services.agent_service.MEMORY_WRITE_TIMEOUT", 0.05):
            # Directly test the _write_with_timeout pattern
            try:
                await asyncio.wait_for(slow_write(), timeout=0.05)
            except asyncio.TimeoutError:
                _record_failed_write(
                    event_type="scoring-agent",
                    concept_id="node_timeout",
                    canvas_name="test.canvas",
                    score=50.0,
                    error_reason="timeout after 0.05s",
                )

        assert fallback_file.exists()
        entry = json.loads(fallback_file.read_text(encoding="utf-8").strip())
        assert entry["concept_id"] == "node_timeout"
        assert entry["error_reason"] == "timeout after 0.05s"

    @pytest.mark.asyncio
    async def test_exception_triggers_record_failed_write(self, tmp_path):
        """[P0] When inner write raises exception, _record_failed_write is called."""
        fallback_file = tmp_path / "data" / "failed_writes.jsonl"

        with patch("app.services.agent_service.FAILED_WRITES_FILE", fallback_file):
            _record_failed_write(
                event_type="scoring-agent",
                concept_id="node_exc",
                canvas_name="test.canvas",
                score=30.0,
                error_reason="ConnectionError: Neo4j unavailable",
            )

        entry = json.loads(fallback_file.read_text(encoding="utf-8").strip())
        assert entry["error_reason"] == "ConnectionError: Neo4j unavailable"
        assert entry["event_type"] == "scoring-agent"


# ═══════════════════════════════════════════════════════════════════
# AC-2 Supplement: Concurrent writes safety
# ═══════════════════════════════════════════════════════════════════


class TestConcurrentFailedWrites:
    """Verify multiple concurrent _record_failed_write calls don't corrupt file."""

    def test_concurrent_writes_all_recorded(self, tmp_path):
        """[P0] 10 concurrent writes all produce valid JSONL entries."""
        fallback_file = tmp_path / "data" / "failed_writes.jsonl"

        with patch("app.services.agent_service.FAILED_WRITES_FILE", fallback_file):
            for i in range(10):
                _record_failed_write(
                    event_type=f"agent-{i}",
                    concept_id=f"node_{i}",
                    canvas_name=f"canvas_{i}.canvas",
                    score=float(i * 10),
                    error_reason=f"error_{i}",
                )

        lines = fallback_file.read_text(encoding="utf-8").strip().splitlines()
        assert len(lines) == 10

        # Each line is valid JSON
        for i, line in enumerate(lines):
            entry = json.loads(line)
            assert entry["concept_id"] == f"node_{i}"
            assert entry["score"] == float(i * 10)

    def test_record_creates_parent_directory(self, tmp_path):
        """[P1] _record_failed_write creates nested parent dirs if missing."""
        deep_path = tmp_path / "a" / "b" / "c" / "failed_writes.jsonl"

        with patch("app.services.agent_service.FAILED_WRITES_FILE", deep_path):
            _record_failed_write("test", "n1", "c1", 10.0, "err")

        assert deep_path.exists()
        entry = json.loads(deep_path.read_text(encoding="utf-8").strip())
        assert entry["concept_id"] == "n1"


# ═══════════════════════════════════════════════════════════════════
# AC-3 Supplement: Edge cases
# ═══════════════════════════════════════════════════════════════════


class TestRecoveryEdgeCases:
    """Supplement AC-3 tests with edge cases."""

    @pytest.fixture
    def memory_service(self):
        ms = MemoryService.__new__(MemoryService)
        ms.neo4j = MagicMock()
        ms._learning_memory = AsyncMock()
        ms._learning_memory.add_learning_episode = AsyncMock(return_value=True)
        ms._initialized = True
        ms._episodes = []
        ms._score_history_cache = {}
        return ms

    @pytest.mark.asyncio
    async def test_recover_empty_file(self, memory_service, tmp_path):
        """[P0] File exists but is empty → returns zeros gracefully."""
        fallback_file = tmp_path / "failed_writes.jsonl"
        fallback_file.write_text("", encoding="utf-8")

        with patch("app.services.memory_service.FAILED_WRITES_FILE", fallback_file), \
             patch("app.core.failed_writes_constants.FAILED_WRITES_FILE", fallback_file):
            result = await memory_service.recover_failed_writes()

        assert result == {"recovered": 0, "pending": 0}

    @pytest.mark.asyncio
    async def test_recover_whitespace_only_file(self, memory_service, tmp_path):
        """[P1] File with only whitespace/newlines → returns zeros."""
        fallback_file = tmp_path / "failed_writes.jsonl"
        fallback_file.write_text("\n\n   \n", encoding="utf-8")

        with patch("app.services.memory_service.FAILED_WRITES_FILE", fallback_file), \
             patch("app.core.failed_writes_constants.FAILED_WRITES_FILE", fallback_file):
            result = await memory_service.recover_failed_writes()

        assert result == {"recovered": 0, "pending": 0}

    @pytest.mark.asyncio
    async def test_recover_all_malformed(self, memory_service, tmp_path):
        """[P1] File with only malformed entries → recovered=0, pending=2 (preserved)."""
        fallback_file = tmp_path / "failed_writes.jsonl"
        fallback_file.write_text("not json\nalso not json\n", encoding="utf-8")

        with patch("app.services.memory_service.FAILED_WRITES_FILE", fallback_file), \
             patch("app.core.failed_writes_constants.FAILED_WRITES_FILE", fallback_file):
            result = await memory_service.recover_failed_writes()

        assert result["recovered"] == 0
        assert result["pending"] == 2  # Malformed entries preserved to avoid data loss


# ═══════════════════════════════════════════════════════════════════
# AC-4 Supplement: Merged view edge cases
# ═══════════════════════════════════════════════════════════════════


class TestMergedViewEdgeCases:
    """Supplement AC-4 with sort order and malformed entry handling."""

    @pytest.fixture
    def memory_service(self):
        ms = MemoryService.__new__(MemoryService)
        ms.neo4j = AsyncMock()
        ms.neo4j.get_learning_history = AsyncMock(return_value=[])
        ms._learning_memory = AsyncMock()
        ms._initialized = True
        ms._episodes = []
        ms._episodes_recovered = True
        ms._score_history_cache = {}
        return ms

    def test_load_failed_scores_skips_malformed(self, tmp_path):
        """[P0] Malformed lines in JSONL are skipped by load_failed_scores."""
        fallback_file = tmp_path / "failed_writes.jsonl"
        valid_entry = json.dumps({
            "timestamp": "2026-02-06T10:00:00",
            "concept_id": "node_ok",
            "canvas_name": "test.canvas",
            "score": 25.0,
            "error_reason": "timeout",
        })
        fallback_file.write_text(
            "bad json here\n" + valid_entry + "\n" + "{incomplete\n",
            encoding="utf-8",
        )

        ms = MemoryService.__new__(MemoryService)
        with patch("app.services.memory_service.FAILED_WRITES_FILE", fallback_file), \
             patch("app.core.failed_writes_constants.FAILED_WRITES_FILE", fallback_file):
            results = ms.load_failed_scores()

        assert len(results) == 1
        assert results[0]["node_id"] == "node_ok"
        assert results[0]["source"] == "fallback"

    @pytest.mark.asyncio
    async def test_merged_view_sort_newest_first(self, memory_service, tmp_path):
        """[P0] After merging fallback scores, result is sorted newest-first."""
        fallback_file = tmp_path / "failed_writes.jsonl"
        # Old fallback entry
        old_entry = json.dumps({
            "timestamp": "2026-02-05T08:00:00",
            "concept_id": "node_old",
            "canvas_name": "test.canvas",
            "score": 10.0,
            "error_reason": "timeout",
        })
        # New fallback entry
        new_entry = json.dumps({
            "timestamp": "2026-02-07T12:00:00",
            "concept_id": "node_new",
            "canvas_name": "test.canvas",
            "score": 90.0,
            "error_reason": "timeout",
        })
        fallback_file.write_text(old_entry + "\n" + new_entry + "\n", encoding="utf-8")

        # Neo4j returns a middle-dated entry
        neo4j_episode = {
            "timestamp": "2026-02-06T10:00:00",
            "node_id": "node_mid",
            "concept": "concept_mid",
            "score": 50.0,
        }
        memory_service.neo4j.get_learning_history = AsyncMock(return_value=[neo4j_episode])

        with patch("app.services.memory_service.FAILED_WRITES_FILE", fallback_file), \
             patch("app.core.failed_writes_constants.FAILED_WRITES_FILE", fallback_file):
            result = await memory_service.get_learning_history(user_id="test")

        items = result["items"]
        assert len(items) == 3
        # Newest first: node_new (Feb 7) > node_mid (Feb 6) > node_old (Feb 5)
        timestamps = [item.get("timestamp", "") for item in items]
        assert timestamps == sorted(timestamps, reverse=True)

    def test_load_failed_scores_empty_file(self, tmp_path):
        """[P1] Empty fallback file → load_failed_scores returns []."""
        fallback_file = tmp_path / "failed_writes.jsonl"
        fallback_file.write_text("", encoding="utf-8")

        ms = MemoryService.__new__(MemoryService)
        with patch("app.services.memory_service.FAILED_WRITES_FILE", fallback_file), \
             patch("app.core.failed_writes_constants.FAILED_WRITES_FILE", fallback_file):
            results = ms.load_failed_scores()

        assert results == []


# ═══════════════════════════════════════════════════════════════════
# Full Cycle Integration: fail → record → recover → merge
# ═══════════════════════════════════════════════════════════════════


class TestFullCycleIntegration:
    """End-to-end cycle within unit test scope."""

    @pytest.mark.asyncio
    async def test_full_cycle_fail_record_recover_merge(self, tmp_path):
        """
        [P0] Full lifecycle:
        1. Write fails → _record_failed_write records to JSONL
        2. Startup → recover_failed_writes replays and removes entry
        3. If recovery also fails → load_failed_scores returns it for merged view
        """
        fallback_file = tmp_path / "data" / "failed_writes.jsonl"

        # Step 1: Simulate write failure → record
        with patch("app.services.agent_service.FAILED_WRITES_FILE", fallback_file):
            _record_failed_write(
                event_type="scoring-agent",
                concept_id="node_cycle",
                canvas_name="cycle.canvas",
                score=42.0,
                error_reason="timeout after 15.0s",
            )

        assert fallback_file.exists()
        lines = fallback_file.read_text(encoding="utf-8").strip().splitlines()
        assert len(lines) == 1

        # Step 2: Simulate startup recovery — success
        ms = MemoryService.__new__(MemoryService)
        ms.neo4j = MagicMock()
        ms._learning_memory = AsyncMock()
        ms._initialized = True
        ms._episodes = []
        ms._score_history_cache = {}

        # Mock the retry to succeed
        ms._write_to_graphiti_json_with_retry = AsyncMock(return_value=True)

        with patch("app.services.memory_service.FAILED_WRITES_FILE", fallback_file), \
             patch("app.core.failed_writes_constants.FAILED_WRITES_FILE", fallback_file):
            result = await ms.recover_failed_writes()

        assert result["recovered"] == 1
        assert result["pending"] == 0
        assert not fallback_file.exists()  # Cleaned up

    @pytest.mark.asyncio
    async def test_full_cycle_recovery_fails_then_merge(self, tmp_path):
        """
        [P0] Full lifecycle when recovery fails:
        1. Write fails → record to JSONL
        2. Recovery fails → entry stays in file
        3. get_learning_history includes fallback entry
        """
        fallback_file = tmp_path / "data" / "failed_writes.jsonl"

        # Step 1: Record failed write
        with patch("app.services.agent_service.FAILED_WRITES_FILE", fallback_file):
            _record_failed_write(
                event_type="scoring-agent",
                concept_id="node_stuck",
                canvas_name="stuck.canvas",
                score=33.0,
                error_reason="Neo4j down",
            )

        # Step 2: Recovery fails
        ms = MemoryService.__new__(MemoryService)
        ms.neo4j = AsyncMock()
        ms.neo4j.get_learning_history = AsyncMock(return_value=[])
        ms._learning_memory = AsyncMock()
        ms._initialized = True
        ms._episodes = []
        ms._episodes_recovered = True
        ms._score_history_cache = {}

        ms._write_to_graphiti_json_with_retry = AsyncMock(return_value=False)

        with patch("app.services.memory_service.FAILED_WRITES_FILE", fallback_file), \
             patch("app.core.failed_writes_constants.FAILED_WRITES_FILE", fallback_file):
            recovery = await ms.recover_failed_writes()

        assert recovery["recovered"] == 0
        assert recovery["pending"] == 1
        assert fallback_file.exists()  # Still there

        # Step 3: Merged view includes the stuck entry
        with patch("app.services.memory_service.FAILED_WRITES_FILE", fallback_file), \
             patch("app.core.failed_writes_constants.FAILED_WRITES_FILE", fallback_file):
            history = await ms.get_learning_history(user_id="test")

        assert history["total"] == 1
        assert history["items"][0]["source"] == "fallback"
        assert history["items"][0]["node_id"] == "node_stuck"
        assert history["items"][0]["score"] == 33.0


# ═══════════════════════════════════════════════════════════════════
# Startup Integration: main.py lifespan
# ═══════════════════════════════════════════════════════════════════


class TestStartupIntegration:
    """Verify main.py lifespan calls fallback sync (formerly recover_failed_writes)."""

    def test_main_imports_fallback_sync(self):
        """[P0] main.py references fallback sync service."""
        import app.main as main_module
        source = Path(main_module.__file__).read_text(encoding="utf-8")
        assert "get_fallback_sync_service" in source

    def test_fallback_sync_called_in_lifespan(self):
        """[P0] Fallback sync call exists in lifespan context manager."""
        import app.main as main_module
        source = Path(main_module.__file__).read_text(encoding="utf-8")
        assert "sync_all_fallbacks" in source
