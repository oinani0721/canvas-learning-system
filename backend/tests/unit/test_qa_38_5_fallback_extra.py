# Canvas Learning System - QA Automation Tests for Story 38.5
# Generated by Quinn QA Workflow (补充覆盖)
"""
QA supplemental tests for Story 38.5: Canvas CRUD Graceful Degradation.

Covers edge cases NOT in ATDD tests:
- Multiple events append correctly to fallback file
- Corrupted fallback file recovery
- _fallback_count accuracy
- is_fallback_active lifecycle (False → True)
- _try_fallback_write respects dual-write flag
- Fallback event contains required fields (timestamp, session_id)
"""

import json
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest


class TestQAFallbackFileAppend:
    """QA: Multiple events append correctly to the same fallback file."""

    @pytest.mark.asyncio
    async def test_multiple_events_append_to_fallback(self, tmp_path):
        """Three consecutive events should all appear in the fallback file."""
        from app.models.canvas_events import CanvasEventType
        from app.services.canvas_service import CanvasService

        fallback_file = tmp_path / "canvas_events_fallback.json"
        service = CanvasService(canvas_base_path=str(tmp_path), memory_client=None)
        service._fallback_file_path = fallback_file

        with patch("app.services.canvas_service.settings") as mock_settings:
            mock_settings.ENABLE_GRAPHITI_JSON_DUAL_WRITE = True

            for i in range(3):
                await service._trigger_memory_event(
                    event_type=CanvasEventType.NODE_CREATED,
                    canvas_name="test_canvas",
                    node_id=f"node-{i}"
                )

        events = json.loads(fallback_file.read_text(encoding="utf-8"))
        assert len(events) == 3, f"Expected 3 events, got {len(events)}"
        assert [e["node_id"] for e in events] == ["node-0", "node-1", "node-2"]


class TestQACorruptedFallbackRecovery:
    """QA: Corrupted fallback file doesn't crash the writer."""

    @pytest.mark.asyncio
    async def test_corrupted_json_file_is_overwritten(self, tmp_path):
        """If fallback file contains invalid JSON, writer starts fresh."""
        from app.models.canvas_events import CanvasEventType
        from app.services.canvas_service import CanvasService

        fallback_file = tmp_path / "canvas_events_fallback.json"
        fallback_file.write_text("{{invalid json", encoding="utf-8")

        service = CanvasService(canvas_base_path=str(tmp_path), memory_client=None)
        service._fallback_file_path = fallback_file

        with patch("app.services.canvas_service.settings") as mock_settings:
            mock_settings.ENABLE_GRAPHITI_JSON_DUAL_WRITE = True

            await service._trigger_memory_event(
                event_type=CanvasEventType.NODE_CREATED,
                canvas_name="test_canvas",
                node_id="node-recovery"
            )

        events = json.loads(fallback_file.read_text(encoding="utf-8"))
        assert len(events) == 1
        assert events[0]["node_id"] == "node-recovery"


class TestQAFallbackCountAccuracy:
    """QA: _fallback_count increments correctly."""

    @pytest.mark.asyncio
    async def test_fallback_count_matches_event_count(self, tmp_path):
        """_fallback_count should equal the number of fallback writes."""
        from app.models.canvas_events import CanvasEventType
        from app.services.canvas_service import CanvasService

        fallback_file = tmp_path / "canvas_events_fallback.json"
        service = CanvasService(canvas_base_path=str(tmp_path), memory_client=None)
        service._fallback_file_path = fallback_file

        assert service._fallback_count == 0, "Initial count should be 0"

        with patch("app.services.canvas_service.settings") as mock_settings:
            mock_settings.ENABLE_GRAPHITI_JSON_DUAL_WRITE = True

            for _ in range(5):
                await service._trigger_memory_event(
                    event_type=CanvasEventType.NODE_CREATED,
                    canvas_name="test",
                    node_id="n1"
                )

        assert service._fallback_count == 5, f"Expected 5, got {service._fallback_count}"


class TestQAIsFallbackActiveLifecycle:
    """QA: is_fallback_active transitions from False to True."""

    @pytest.mark.asyncio
    async def test_is_fallback_active_false_then_true(self, tmp_path):
        """is_fallback_active starts False, becomes True after first fallback."""
        from app.models.canvas_events import CanvasEventType
        from app.services.canvas_service import CanvasService

        fallback_file = tmp_path / "canvas_events_fallback.json"
        service = CanvasService(canvas_base_path=str(tmp_path), memory_client=None)
        service._fallback_file_path = fallback_file

        assert service.is_fallback_active is False, "Should start as False"

        with patch("app.services.canvas_service.settings") as mock_settings:
            mock_settings.ENABLE_GRAPHITI_JSON_DUAL_WRITE = True

            await service._trigger_memory_event(
                event_type=CanvasEventType.NODE_CREATED,
                canvas_name="test",
                node_id="n1"
            )

        assert service.is_fallback_active is True, "Should be True after fallback"


class TestQATryFallbackRespectsFlag:
    """QA: _try_fallback_write does nothing when dual-write is disabled."""

    def test_try_fallback_write_noop_when_disabled(self, tmp_path):
        """_try_fallback_write should not create file when dual-write=False."""
        from app.models.canvas_events import CanvasEventContext, CanvasEventType
        from app.services.canvas_service import CanvasService

        fallback_file = tmp_path / "canvas_events_fallback.json"
        service = CanvasService(canvas_base_path=str(tmp_path), memory_client=None)
        service._fallback_file_path = fallback_file

        context = CanvasEventContext(
            canvas_name="test", node_id="n1"
        )

        with patch("app.services.canvas_service.settings") as mock_settings:
            mock_settings.ENABLE_GRAPHITI_JSON_DUAL_WRITE = False

            service._try_fallback_write(CanvasEventType.NODE_CREATED, context)

        assert not fallback_file.exists(), "No file when dual-write disabled"
        assert service._fallback_count == 0


class TestQAFallbackEventFields:
    """QA: Fallback events contain all required metadata fields."""

    @pytest.mark.asyncio
    async def test_event_contains_timestamp_and_session_id(self, tmp_path):
        """Each fallback event must include timestamp and session_id."""
        from app.models.canvas_events import CanvasEventType
        from app.services.canvas_service import CanvasService

        fallback_file = tmp_path / "canvas_events_fallback.json"
        service = CanvasService(canvas_base_path=str(tmp_path), memory_client=None)
        service._fallback_file_path = fallback_file

        with patch("app.services.canvas_service.settings") as mock_settings:
            mock_settings.ENABLE_GRAPHITI_JSON_DUAL_WRITE = True

            await service._trigger_memory_event(
                event_type=CanvasEventType.NODE_UPDATED,
                canvas_name="math53",
                node_id="node-42"
            )

        events = json.loads(fallback_file.read_text(encoding="utf-8"))
        event = events[0]

        assert "timestamp" in event, "Event must have timestamp"
        assert "session_id" in event, "Event must have session_id"
        assert "event_type" in event
        assert "canvas_name" in event
        assert event["event_type"] == "node_updated"
        assert event["canvas_name"] == "math53"
        assert event["node_id"] == "node-42"

    @pytest.mark.asyncio
    async def test_edge_sync_fallback_includes_from_to_node_ids(self, tmp_path):
        """Edge sync fallback should preserve from_node_id and to_node_id."""
        from app.services.canvas_service import CanvasService

        fallback_file = tmp_path / "canvas_events_fallback.json"
        mock_memory = MagicMock()
        mock_memory.neo4j = None

        service = CanvasService(
            canvas_base_path=str(tmp_path),
            memory_client=mock_memory
        )
        service._fallback_file_path = fallback_file

        with patch("app.services.canvas_service.settings") as mock_settings:
            mock_settings.ENABLE_GRAPHITI_JSON_DUAL_WRITE = True

            await service._sync_edge_to_neo4j(
                canvas_path="math53.canvas",
                edge_id="edge-99",
                from_node_id="src-node",
                to_node_id="dst-node"
            )

        events = json.loads(fallback_file.read_text(encoding="utf-8"))
        event = events[0]

        assert event["event_type"] == "edge_sync"
        assert event["edge_id"] == "edge-99"
        assert event["from_node_id"] == "src-node"
        assert event["to_node_id"] == "dst-node"
