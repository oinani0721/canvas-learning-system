# Canvas Learning System - Tests for Story 38.5
# Story 38.5: Canvas CRUD Graceful Degradation with JSON Fallback
# Generated by TEA ATDD Workflow (Red Phase)
"""
Tests for Story 38.5: Canvas CRUD Graceful Degradation with JSON Fallback.

Verifies 4 Acceptance Criteria:
- AC-1: Memory client None → JSON fallback write + CRUD succeeds + WARNING log
- AC-2: Neo4j down → JSON fallback write + WARNING log
- AC-3: Health visibility — CanvasService tracks degraded state
- AC-4: Log level upgraded from DEBUG to WARNING for skip events

Story Context: docs/stories/EPIC-38-infrastructure-reliability-fixes.md#Story-38.5
[Source: docs/stories/EPIC-38-infrastructure-reliability-fixes.md#Story-38.5]
"""

import asyncio
import json
import logging
from pathlib import Path

from tests.conftest import wait_for_condition
from unittest.mock import AsyncMock, MagicMock, patch

import pytest


# ═══════════════════════════════════════════════════════════════════════════════
# AC-1: Memory Client None → JSON Fallback (D5: Degradation)
# ═══════════════════════════════════════════════════════════════════════════════


class TestAC1MemoryClientNoneFallback:
    """AC-1: When memory_client is None and dual-write enabled, write to JSON fallback."""

    @pytest.mark.asyncio
    async def test_trigger_event_writes_json_when_memory_client_none(self, tmp_path):
        """
        [P0] Canvas event written to JSON fallback when memory_client is None.

        Verifies: canvas_service.py _trigger_memory_event → JSON fallback path
        """
        from app.models.canvas_events import CanvasEventType
        from app.services.canvas_service import CanvasService

        fallback_file = tmp_path / "canvas_events_fallback.json"
        service = CanvasService(canvas_base_path=str(tmp_path), memory_client=None)
        service._fallback_file_path = fallback_file

        with patch("app.services.canvas_service.settings") as mock_settings:
            mock_settings.ENABLE_GRAPHITI_JSON_DUAL_WRITE = True

            await service._trigger_memory_event(
                event_type=CanvasEventType.NODE_CREATED,
                canvas_name="test_canvas",
                node_id="node-1",
                node_data={"id": "node-1", "type": "text", "text": "Hello"}
            )

        assert fallback_file.exists(), (
            "JSON fallback file should be created when memory_client is None. "
            "Story 38.5 AC-1: Write event to JSON fallback"
        )
        content = json.loads(fallback_file.read_text(encoding="utf-8"))
        events = content if isinstance(content, list) else content.get("events", [])
        assert len(events) >= 1, "At least one event should be written"
        assert events[-1]["event_type"] == "node_created"
        assert events[-1]["node_id"] == "node-1"

    @pytest.mark.asyncio
    async def test_no_fallback_file_when_dual_write_disabled(self, tmp_path):
        """
        [P1] No JSON fallback when dual-write is disabled (negative case).

        Verifies: Dual-write flag check prevents unnecessary writes.
        This test passes because no fallback mechanism exists (correct behavior for disabled).
        """
        from app.models.canvas_events import CanvasEventType
        from app.services.canvas_service import CanvasService

        fallback_file = tmp_path / "canvas_events_fallback.json"
        service = CanvasService(canvas_base_path=str(tmp_path), memory_client=None)

        await service._trigger_memory_event(
            event_type=CanvasEventType.NODE_CREATED,
            canvas_name="test_canvas",
            node_id="node-1",
            node_data={"id": "node-1"}
        )

        assert not fallback_file.exists(), "No fallback file should exist when dual-write disabled"

    @pytest.mark.asyncio
    async def test_crud_add_node_succeeds_when_memory_client_none(self, tmp_path):
        """
        [P0] CRUD (add_node) completes successfully when memory_client is None.

        Verifies: _trigger_memory_event does NOT block CRUD operation.
        This test passes because current code silently returns on None memory_client.
        """
        from app.services.canvas_service import CanvasService

        # Create a minimal canvas file for read_canvas to find
        canvas_file = tmp_path / "test.canvas"
        canvas_file.write_text(
            json.dumps({"nodes": [], "edges": []}),
            encoding="utf-8"
        )

        service = CanvasService(canvas_base_path=str(tmp_path), memory_client=None)
        result = await service.add_node("test", {"type": "text", "text": "Hello"})

        assert result is not None, "add_node should return the new node"
        assert result.get("type") == "text"
        assert "id" in result


# ═══════════════════════════════════════════════════════════════════════════════
# AC-2: Neo4j Down → JSON Fallback (D5: Degradation)
# ═══════════════════════════════════════════════════════════════════════════════


class TestAC2Neo4jDownFallback:
    """AC-2: When Neo4j is unreachable, events written to JSON fallback."""

    @pytest.mark.asyncio
    async def test_edge_sync_writes_json_when_neo4j_none(self, tmp_path):
        """
        [P0] Edge sync writes to JSON fallback when neo4j client is None.

        Verifies: canvas_service.py _sync_edge_to_neo4j → JSON fallback
        """
        from app.services.canvas_service import CanvasService

        fallback_file = tmp_path / "canvas_events_fallback.json"
        mock_memory = MagicMock()
        mock_memory.neo4j = None  # Neo4j not available

        service = CanvasService(
            canvas_base_path=str(tmp_path),
            memory_client=mock_memory
        )
        service._fallback_file_path = fallback_file

        with patch("app.services.canvas_service.settings") as mock_settings:
            mock_settings.ENABLE_GRAPHITI_JSON_DUAL_WRITE = True

            await service._sync_edge_to_neo4j(
                canvas_path="test.canvas",
                edge_id="edge-1",
                from_node_id="n1",
                to_node_id="n2"
            )

        assert fallback_file.exists(), (
            "JSON fallback should be created when Neo4j unavailable. "
            "Story 38.5 AC-2: Write edge event to JSON fallback"
        )

    @pytest.mark.asyncio
    async def test_trigger_event_fallback_when_record_temporal_raises(self, tmp_path):
        """
        [P0] _trigger_memory_event falls back to JSON when record_temporal_event raises.

        Verifies: _write_memory_event error handling → JSON fallback write
        """
        from app.models.canvas_events import CanvasEventType
        from app.services.canvas_service import CanvasService

        fallback_file = tmp_path / "canvas_events_fallback.json"
        mock_memory = AsyncMock()
        mock_memory.record_temporal_event = AsyncMock(
            side_effect=ConnectionError("Neo4j unreachable")
        )

        service = CanvasService(
            canvas_base_path=str(tmp_path),
            memory_client=mock_memory
        )
        service._fallback_file_path = fallback_file

        with patch("app.services.canvas_service.settings") as mock_settings:
            mock_settings.ENABLE_GRAPHITI_JSON_DUAL_WRITE = True

            await service._trigger_memory_event(
                event_type=CanvasEventType.NODE_UPDATED,
                canvas_name="test_canvas",
                node_id="node-1"
            )

            # Allow fire-and-forget task to complete within patch context
            await wait_for_condition(
                lambda: fallback_file.exists(),
                description="fallback file created",
                timeout=3.0,
            )

        assert fallback_file.exists(), (
            "JSON fallback should be created when Neo4j connection fails. "
            "Story 38.5 AC-2: Fallback on Neo4j error"
        )


# ═══════════════════════════════════════════════════════════════════════════════
# AC-3: Health Visibility (D5: Degradation)
# ═══════════════════════════════════════════════════════════════════════════════


class TestAC3HealthVisibility:
    """AC-3: CanvasService tracks degraded mode for health reporting."""

    def test_canvas_service_tracks_fallback_active_state(self):
        """
        [P1] CanvasService has a property to report degraded (fallback) state.

        Verifies: CanvasService tracks when operating in JSON fallback mode.
        Expected: property 'is_fallback_active' or similar exists and is True when
        memory_client is None.
        """
        from app.services.canvas_service import CanvasService

        service = CanvasService(memory_client=None)

        # CanvasService should expose degraded state for health endpoint
        assert hasattr(service, "is_fallback_active") or hasattr(service, "_fallback_count"), (
            "CanvasService should track degraded/fallback state. "
            "Story 38.5 AC-3: Health visibility requires state tracking. "
            "Expected: 'is_fallback_active' property or '_fallback_count' counter"
        )


# ═══════════════════════════════════════════════════════════════════════════════
# AC-4: Log Level Upgrade (D2: Resilience)
# ═══════════════════════════════════════════════════════════════════════════════


class TestAC4LogLevelUpgrade:
    """AC-4: Skip events use WARNING log level (not DEBUG)."""

    @pytest.mark.asyncio
    async def test_memory_client_none_emits_warning(self, caplog):
        """
        [P0] WARNING log when memory_client is None (not DEBUG).

        Verifies: canvas_service.py L173-174 logger.debug → logger.warning
        Current: logger.debug("Memory client not configured, skipping event trigger")
        Expected: logger.warning("Memory client unavailable, writing to JSON fallback")
        """
        from app.models.canvas_events import CanvasEventType
        from app.services.canvas_service import CanvasService

        service = CanvasService(memory_client=None)

        with caplog.at_level(logging.WARNING, logger="app.services.canvas_service"):
            await service._trigger_memory_event(
                event_type=CanvasEventType.NODE_CREATED,
                canvas_name="test_canvas",
                node_id="node-1"
            )

        warning_msgs = [r.message for r in caplog.records if r.levelno >= logging.WARNING]
        assert any(
            "memory" in msg.lower() or "unavailable" in msg.lower() or "fallback" in msg.lower()
            for msg in warning_msgs
        ), (
            f"Expected WARNING about memory client unavailable or fallback. "
            f"Got warnings: {warning_msgs}. "
            f"Story 38.5 AC-4: Upgrade logger.debug → logger.warning"
        )

    @pytest.mark.asyncio
    async def test_neo4j_none_emits_warning_in_edge_sync(self, caplog):
        """
        [P0] WARNING log when Neo4j is None in edge sync (not DEBUG).

        Verifies: canvas_service.py L278-286 logger.debug → logger.warning
        Current: logger.debug("Neo4j client not available in memory_client")
        Expected: logger.warning("Neo4j unreachable, event written to JSON fallback")
        """
        from app.services.canvas_service import CanvasService

        mock_memory = MagicMock()
        mock_memory.neo4j = None

        service = CanvasService(memory_client=mock_memory)

        with caplog.at_level(logging.WARNING, logger="app.services.canvas_service"):
            await service._sync_edge_to_neo4j(
                canvas_path="test.canvas",
                edge_id="edge-1",
                from_node_id="n1",
                to_node_id="n2"
            )

        warning_msgs = [r.message for r in caplog.records if r.levelno >= logging.WARNING]
        assert any(
            "neo4j" in msg.lower() or "unavailable" in msg.lower() or "fallback" in msg.lower()
            for msg in warning_msgs
        ), (
            f"Expected WARNING about Neo4j unavailable or fallback. "
            f"Got warnings: {warning_msgs}. "
            f"Story 38.5 AC-4: Upgrade logger.debug → logger.warning"
        )
