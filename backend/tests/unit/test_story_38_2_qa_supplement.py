# Story 38.2 QA Supplement: Additional tests for episode recovery
# Generated by Quinn QA Automate workflow
"""
Supplemental test coverage for Story 38.2 (Learning History Persistence & Restart Recovery).

Tests NOT covered by the original test_story_38_2_episode_recovery.py:
- Cypher mode (non-JSON-fallback) path for Neo4jClient
- Episode field completeness after recovery
- None/missing field handling in recovery
- Initialize idempotency (no double recovery)
- JSON fallback edge cases (None timestamp, limit=1)
"""

import logging
import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from app.clients.neo4j_client import Neo4jClient
from app.services.memory_service import MemoryService


# ---- Fixtures ----

@pytest.fixture
def mock_neo4j_client():
    """Create a mock Neo4jClient."""
    client = MagicMock(spec=Neo4jClient)
    client.initialize = AsyncMock(return_value=True)
    client.stats = {"initialized": True, "mode": "NEO4J", "health_status": True}
    client.get_all_recent_episodes = AsyncMock(return_value=[])
    client.get_learning_history = AsyncMock(return_value=[])
    client.cleanup = AsyncMock()
    return client


@pytest.fixture
def mock_learning_memory_client():
    """Create a mock LearningMemoryClient."""
    client = MagicMock()
    client.add_learning_episode = AsyncMock(return_value=None)
    return client


@pytest.fixture
def memory_service(mock_neo4j_client, mock_learning_memory_client):
    """Create MemoryService with mocked dependencies."""
    return MemoryService(
        neo4j_client=mock_neo4j_client,
        learning_memory_client=mock_learning_memory_client,
    )


# ---- Cypher mode tests (non-JSON-fallback) ----

class TestGetAllRecentEpisodesCypher:
    """Verify Cypher path of get_all_recent_episodes (not JSON fallback)."""

    @pytest.mark.asyncio
    async def test_cypher_mode_calls_run_query(self):
        """When _use_json_fallback=False, run_query is called with correct Cypher."""
        client = Neo4jClient.__new__(Neo4jClient)
        client._use_json_fallback = False
        client._initialized = True
        client.run_query = AsyncMock(return_value=[
            {"user_id": "u1", "concept": "algebra", "concept_id": "c1",
             "score": 90, "timestamp": "2026-02-06T10:00:00",
             "group_id": "math", "review_count": 2}
        ])

        results = await client.get_all_recent_episodes(limit=500)

        client.run_query.assert_called_once()
        call_args = client.run_query.call_args
        query = call_args[0][0]  # first positional arg
        assert "MATCH (u:User)-[r:LEARNED]->(c:Concept)" in query
        assert "LIMIT $limit" in query
        assert call_args[1]["limit"] == 500
        assert len(results) == 1
        assert results[0]["concept"] == "algebra"

    @pytest.mark.asyncio
    async def test_cypher_mode_default_limit(self):
        """Default limit is 1000."""
        client = Neo4jClient.__new__(Neo4jClient)
        client._use_json_fallback = False
        client._initialized = True
        client.run_query = AsyncMock(return_value=[])

        await client.get_all_recent_episodes()

        call_args = client.run_query.call_args
        assert call_args[1]["limit"] == 1000


# ---- Episode field completeness ----

class TestEpisodeRecoveryDataIntegrity:
    """Verify recovered episodes have correct structure and handle edge cases."""

    @pytest.mark.asyncio
    async def test_recovered_episode_has_all_required_fields(
        self, memory_service, mock_neo4j_client
    ):
        """Every recovered episode must have all required fields."""
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(return_value=[
            {
                "user_id": "u1",
                "concept": "calculus",
                "concept_id": "cid-calc",
                "score": 85,
                "timestamp": "2026-02-06T10:00:00",
                "group_id": "math",
                "review_count": 3,
            }
        ])

        await memory_service.initialize()

        ep = memory_service._episodes[0]
        required_fields = [
            "episode_id", "user_id", "concept", "concept_id",
            "score", "timestamp", "group_id", "review_count", "episode_type"
        ]
        for field in required_fields:
            assert field in ep, f"Missing field: {field}"

        # H1 fix: episode_id now includes index + user_id + concept_id
        assert ep["episode_id"] == "recovered-0-u1-cid-calc"
        assert ep["episode_type"] == "recovered"
        assert ep["user_id"] == "u1"
        assert ep["score"] == 85
        assert ep["review_count"] == 3

    @pytest.mark.asyncio
    async def test_recovered_episode_handles_none_score(
        self, memory_service, mock_neo4j_client
    ):
        """score=None should not crash recovery."""
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(return_value=[
            {
                "user_id": "u1",
                "concept": "algebra",
                "concept_id": "cid-alg",
                "score": None,
                "timestamp": "2026-02-06T10:00:00",
                "group_id": "math",
                "review_count": None,
            }
        ])

        await memory_service.initialize()

        assert len(memory_service._episodes) == 1
        ep = memory_service._episodes[0]
        assert ep["score"] is None
        # H2 fix: `record.get("review_count") or 0` now correctly returns 0 for None
        assert ep["review_count"] == 0

    @pytest.mark.asyncio
    async def test_recovered_episode_handles_none_concept_id(
        self, memory_service, mock_neo4j_client
    ):
        """concept_id=None: `or 'unknown'` fallback produces correct episode_id."""
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(return_value=[
            {
                "user_id": "u1",
                "concept": "topology",
                "concept_id": None,
                "score": 70,
                "timestamp": "2026-02-06T10:00:00",
                "group_id": "math",
            }
        ])

        await memory_service.initialize()

        ep = memory_service._episodes[0]
        # H1/H2 fix: now uses `or 'unknown'` so None concept_id → 'unknown'
        assert ep["episode_id"] == "recovered-0-u1-unknown"

    @pytest.mark.asyncio
    async def test_recovered_episode_none_timestamp_becomes_empty(
        self, memory_service, mock_neo4j_client
    ):
        """timestamp=None: `or ""` produces empty string (not 'None')."""
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(return_value=[
            {
                "user_id": "u1",
                "concept": "sets",
                "concept_id": "cid-sets",
                "score": 60,
                "timestamp": None,
                "group_id": "math",
            }
        ])

        await memory_service.initialize()

        ep = memory_service._episodes[0]
        # H2 fix: `str(record.get("timestamp") or "")` → str("") → "" (not "None")
        assert ep["timestamp"] == ""


# ---- Initialize idempotency ----

class TestInitializeIdempotency:
    """Verify initialize() is idempotent — no double recovery."""

    @pytest.mark.asyncio
    async def test_initialize_called_twice_no_double_recovery(
        self, memory_service, mock_neo4j_client
    ):
        """Calling initialize() twice should not duplicate episodes."""
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(return_value=[
            {
                "user_id": "u1",
                "concept": "algebra",
                "concept_id": "cid-1",
                "score": 90,
                "timestamp": "2026-02-06T10:00:00",
                "group_id": "math",
                "review_count": 1,
            }
        ])

        await memory_service.initialize()
        assert len(memory_service._episodes) == 1

        # Second call should short-circuit (self._initialized == True)
        await memory_service.initialize()
        assert len(memory_service._episodes) == 1
        # get_all_recent_episodes called only once
        assert mock_neo4j_client.get_all_recent_episodes.call_count == 1


# ---- JSON fallback edge cases ----

class TestJsonFallbackEdgeCases:
    """Edge cases for _get_all_recent_episodes_json."""

    @pytest.mark.asyncio
    async def test_json_fallback_none_timestamp_sorting(self):
        """None timestamps should sort to the end, not crash."""
        client = Neo4jClient(use_json_fallback=True)
        client._data = {
            "users": [],
            "concepts": [],
            "relationships": [
                {
                    "user_id": "u1",
                    "concept_name": "algebra",
                    "timestamp": None,  # None timestamp
                },
                {
                    "user_id": "u2",
                    "concept_name": "calculus",
                    "timestamp": "2026-02-06T12:00:00",
                },
            ],
        }
        client._initialized = True

        results = await client.get_all_recent_episodes(limit=10)

        assert len(results) == 2
        # calculus (with timestamp) should come first
        assert results[0]["concept"] == "calculus"
        assert results[1]["concept"] == "algebra"

    @pytest.mark.asyncio
    async def test_json_fallback_limit_one(self):
        """limit=1 should return exactly one result."""
        client = Neo4jClient(use_json_fallback=True)
        client._data = {
            "users": [],
            "concepts": [],
            "relationships": [
                {"user_id": f"u{i}", "concept_name": f"c{i}", "timestamp": f"2026-01-{10+i:02d}T00:00:00"}
                for i in range(5)
            ],
        }
        client._initialized = True

        results = await client.get_all_recent_episodes(limit=1)
        assert len(results) == 1

    @pytest.mark.asyncio
    async def test_json_fallback_missing_relationships_key(self):
        """Missing 'relationships' key should return empty list."""
        client = Neo4jClient(use_json_fallback=True)
        client._data = {"users": [], "concepts": []}  # no "relationships"
        client._initialized = True

        results = await client.get_all_recent_episodes()
        assert results == []

    @pytest.mark.asyncio
    async def test_json_fallback_missing_fields_in_relationship(self):
        """Relationships with missing fields should not crash."""
        client = Neo4jClient(use_json_fallback=True)
        client._data = {
            "users": [],
            "concepts": [],
            "relationships": [
                {"user_id": "u1"},  # minimal — only user_id
            ],
        }
        client._initialized = True

        results = await client.get_all_recent_episodes()
        assert len(results) == 1
        assert results[0]["user_id"] == "u1"
        assert results[0]["concept"] is None
        assert results[0]["score"] is None
        assert results[0]["review_count"] == 0  # default


# ---- Code review fixes: dedup, limit, cap ----

class TestCodeReviewFixes:
    """Tests added during code review to verify H1/H2/M1/M2 fixes."""

    @pytest.mark.asyncio
    async def test_recovery_limit_1000_passed_to_neo4j(
        self, memory_service, mock_neo4j_client
    ):
        """L2 fix: AC-2 requires limit=1000 — verify it's passed correctly."""
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(return_value=[])

        await memory_service.initialize()

        mock_neo4j_client.get_all_recent_episodes.assert_called_once_with(limit=1000)

    @pytest.mark.asyncio
    async def test_episode_id_uniqueness_across_users(
        self, memory_service, mock_neo4j_client
    ):
        """H1 fix: Different users learning same concept get unique episode_ids."""
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(return_value=[
            {"user_id": "user-A", "concept": "algebra", "concept_id": "cid-1",
             "score": 90, "timestamp": "2026-02-06T10:00:00"},
            {"user_id": "user-B", "concept": "algebra", "concept_id": "cid-1",
             "score": 80, "timestamp": "2026-02-06T11:00:00"},
        ])

        await memory_service.initialize()

        ids = [e["episode_id"] for e in memory_service._episodes]
        assert len(set(ids)) == 2, f"episode_ids not unique: {ids}"

    @pytest.mark.asyncio
    async def test_lazy_recovery_skips_exact_duplicates(
        self, memory_service, mock_neo4j_client
    ):
        """Lazy recovery deduplicates on (user_id, concept, timestamp) — exact matches only."""
        # Startup fails
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(
            side_effect=Exception("Connection refused")
        )
        await memory_service.initialize()

        # Manually add an episode with known timestamp (simulating degraded-mode)
        memory_service._episodes.append({
            "user_id": "u1", "concept": "algebra", "timestamp": "2026-02-06T10:00:00",
            "episode_type": "learning",
        })
        assert len(memory_service._episodes) == 1

        # Neo4j returns same (user_id, concept, timestamp) + a new one
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(return_value=[
            {"user_id": "u1", "concept": "algebra", "concept_id": "cid-1",
             "score": None, "timestamp": "2026-02-06T10:00:00"},  # exact match → skip
            {"user_id": "u2", "concept": "calculus", "concept_id": "cid-2",
             "score": 85, "timestamp": "2026-02-06T11:00:00"},  # new → add
        ])
        mock_neo4j_client.get_learning_history = AsyncMock(return_value=[])

        await memory_service.get_learning_history(user_id="u1")

        # Should have 2: original algebra + new calculus (exact dup skipped)
        concepts = [e.get("concept") for e in memory_service._episodes]
        assert concepts.count("algebra") == 1, f"Duplicate algebra! episodes: {concepts}"
        assert "calculus" in concepts

    @pytest.mark.asyncio
    async def test_lazy_recovery_keeps_different_timestamps(
        self, memory_service, mock_neo4j_client
    ):
        """Same user+concept but different timestamps are kept (not deduped)."""
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(
            side_effect=Exception("Connection refused")
        )
        await memory_service.initialize()

        # Episode with one timestamp
        memory_service._episodes.append({
            "user_id": "u1", "concept": "algebra", "timestamp": "2026-02-05T09:00:00",
            "episode_type": "learning",
        })

        # Neo4j returns same concept but different timestamp
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(return_value=[
            {"user_id": "u1", "concept": "algebra", "concept_id": "cid-1",
             "score": 90, "timestamp": "2026-02-06T10:00:00"},  # different timestamp → keep
        ])
        mock_neo4j_client.get_learning_history = AsyncMock(return_value=[])

        await memory_service.get_learning_history(user_id="u1")

        # Both entries should be kept (different timestamps)
        algebra_entries = [e for e in memory_service._episodes if e.get("concept") == "algebra"]
        assert len(algebra_entries) == 2, f"Expected 2 algebra entries, got {len(algebra_entries)}"

    @pytest.mark.asyncio
    async def test_episode_cache_capped_at_2000(
        self, memory_service, mock_neo4j_client
    ):
        """M2 fix: self._episodes never exceeds 2000 entries."""
        # Pre-fill with 1500 episodes
        for i in range(1500):
            memory_service._episodes.append({
                "user_id": f"u-{i}", "concept": f"existing-{i}",
                "episode_type": "recorded",
            })

        # Recovery brings 800 more (all unique concepts)
        records = [
            {"user_id": f"r-{i}", "concept": f"recovered-{i}", "concept_id": f"rc-{i}",
             "score": 80, "timestamp": f"2026-02-0{min(i%9+1,9)}T10:00:00"}
            for i in range(800)
        ]
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(return_value=records)

        await memory_service.initialize()

        assert len(memory_service._episodes) <= 2000


class TestConcurrentRecoveryProtection:
    """H2 fix: Verify asyncio.Lock prevents concurrent recovery."""

    @pytest.mark.asyncio
    async def test_concurrent_lazy_recovery_runs_once(
        self, mock_neo4j_client, mock_learning_memory_client
    ):
        """Two concurrent get_learning_history() calls should only trigger one recovery."""
        import asyncio

        svc = MemoryService(
            neo4j_client=mock_neo4j_client,
            learning_memory_client=mock_learning_memory_client,
        )
        # Startup: Neo4j down
        mock_neo4j_client.get_all_recent_episodes = AsyncMock(
            side_effect=Exception("Connection refused")
        )
        await svc.initialize()
        assert svc._episodes_recovered is False

        # Now Neo4j comes back — add a small delay to simulate real query
        call_count = 0

        async def slow_get_episodes(limit=1000):
            nonlocal call_count
            call_count += 1
            await asyncio.sleep(0.05)  # Small delay to allow concurrent entry
            return [{"user_id": "u1", "concept": f"concept-{call_count}",
                     "concept_id": "c1", "score": 80,
                     "timestamp": "2026-02-06T10:00:00"}]

        mock_neo4j_client.get_all_recent_episodes = slow_get_episodes
        mock_neo4j_client.get_learning_history = AsyncMock(return_value=[])

        # Fire two concurrent queries
        await asyncio.gather(
            svc.get_learning_history(user_id="u1"),
            svc.get_learning_history(user_id="u2"),
        )

        # Recovery should have run exactly once (lock prevents double entry)
        assert call_count == 1, f"Expected 1 recovery call, got {call_count}"
        assert svc._episodes_recovered is True
