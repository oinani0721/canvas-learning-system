/**
 * BehaviorMonitorService - Canvas Learning System
 *
 * Implements Story 14.10: 行为监控触发机制（触发点4）
 *
 * Trigger Point 4 Implementation:
 * - Scheduled monitoring task (configurable interval, default 6 hours)
 * - Weakness cluster detection (≥3 red nodes in same community)
 * - Consecutive days without review detection
 * - Review recommendation generation
 * - Non-blocking (failures don't affect main flow)
 *
 * @module BehaviorMonitorService
 * @version 1.0.0
 */

import { App, requestUrl } from 'obsidian';

// ============================================================================
// Types and Interfaces
// ============================================================================

/**
 * Monitoring settings
 */
export interface BehaviorMonitorSettings {
    /** Enable behavior monitoring */
    enabled: boolean;
    /** Monitoring interval in hours */
    intervalHours: number;
    /** API base URL for backend services */
    apiBaseUrl: string;
    /** Request timeout in milliseconds */
    timeout: number;
    /** Minimum red nodes to form a weakness cluster */
    weaknessClusterThreshold: number;
    /** Days without review to trigger alert */
    daysWithoutReviewThreshold: number;
    /** Enable console logging for debugging */
    enableLogging: boolean;
}

/**
 * Default monitoring settings
 * Source: PRD 触发点4 - 每6小时运行
 */
export const DEFAULT_BEHAVIOR_MONITOR_SETTINGS: BehaviorMonitorSettings = {
    enabled: true,
    intervalHours: 6,
    apiBaseUrl: 'http://localhost:8000/api/v1',
    timeout: 30000, // 30 seconds for potentially long-running analysis
    weaknessClusterThreshold: 3,
    daysWithoutReviewThreshold: 3,
    enableLogging: false,
};

/**
 * Weakness cluster detected by monitoring
 */
export interface WeaknessCluster {
    /** Cluster/community ID */
    clusterId: string;
    /** Community name or topic */
    communityName: string;
    /** Canvas file containing the cluster */
    canvasName: string;
    /** Red nodes in this cluster */
    redNodes: WeakNode[];
    /** Total nodes in cluster */
    totalNodes: number;
    /** Weakness ratio (red/total) */
    weaknessRatio: number;
    /** Recommended action */
    recommendation: string;
}

/**
 * A weak node (red status) in the system
 */
export interface WeakNode {
    /** Node ID */
    nodeId: string;
    /** Concept name */
    conceptName: string;
    /** Days since last review */
    daysSinceReview: number;
    /** Current memory strength (0-1) */
    memoryStrength: number;
    /** Related concepts that might need review */
    relatedConcepts: string[];
}

/**
 * Concept that hasn't been reviewed for extended period
 */
export interface StaleReviewConcept {
    /** Concept name */
    conceptName: string;
    /** Node ID in canvas */
    nodeId: string;
    /** Canvas file name */
    canvasName: string;
    /** Days since last review */
    daysSinceReview: number;
    /** Last review date */
    lastReviewDate: Date | null;
    /** Estimated memory decay (0-1, 0 = forgotten) */
    estimatedRetention: number;
    /** Priority score for review */
    reviewPriority: number;
}

/**
 * Monitoring check result
 */
export interface MonitoringResult {
    /** Check timestamp */
    timestamp: Date;
    /** Whether check completed successfully */
    success: boolean;
    /** Error message if failed */
    error?: string;
    /** Duration of check in milliseconds */
    durationMs: number;
    /** Weakness clusters found */
    weaknessClusters: WeaknessCluster[];
    /** Concepts needing review */
    staleReviewConcepts: StaleReviewConcept[];
    /** Total recommendations generated */
    totalRecommendations: number;
}

/**
 * Scheduled task status
 */
export interface SchedulerStatus {
    /** Whether monitoring is active */
    isRunning: boolean;
    /** Last check timestamp */
    lastCheck: Date | null;
    /** Next scheduled check */
    nextCheck: Date | null;
    /** Total checks performed */
    totalChecks: number;
    /** Successful checks count */
    successfulChecks: number;
    /** Failed checks count */
    failedChecks: number;
    /** Current interval in hours */
    intervalHours: number;
}

/**
 * Review recommendation generated by monitoring
 */
export interface ReviewRecommendation {
    /** Recommendation ID */
    id: string;
    /** Type of recommendation */
    type: 'weakness_cluster' | 'stale_review' | 'prerequisite_gap';
    /** Priority level (1-10, 10 being highest) */
    priority: number;
    /** Human-readable title */
    title: string;
    /** Detailed description */
    description: string;
    /** Affected concepts */
    concepts: string[];
    /** Canvas file */
    canvasName: string;
    /** Suggested action */
    suggestedAction: string;
    /** Created at */
    createdAt: Date;
}

// ============================================================================
// BehaviorMonitorService Class
// ============================================================================

/**
 * Service for monitoring learning behavior and triggering review recommendations
 * Implements PRD Trigger Point 4 (触发点4)
 */
export class BehaviorMonitorService {
    private app: App;
    private settings: BehaviorMonitorSettings;
    private intervalId: ReturnType<typeof setInterval> | null = null;
    private status: SchedulerStatus;
    private recommendations: ReviewRecommendation[] = [];
    private lastResult: MonitoringResult | null = null;
    private onRecommendationCallback: ((rec: ReviewRecommendation[]) => void) | null = null;

    constructor(app: App, settings?: Partial<BehaviorMonitorSettings>) {
        this.app = app;
        this.settings = { ...DEFAULT_BEHAVIOR_MONITOR_SETTINGS, ...settings };
        this.status = {
            isRunning: false,
            lastCheck: null,
            nextCheck: null,
            totalChecks: 0,
            successfulChecks: 0,
            failedChecks: 0,
            intervalHours: this.settings.intervalHours,
        };
    }

    // ========================================================================
    // Configuration
    // ========================================================================

    /**
     * Get current settings
     */
    getSettings(): BehaviorMonitorSettings {
        return { ...this.settings };
    }

    /**
     * Update settings
     */
    updateSettings(newSettings: Partial<BehaviorMonitorSettings>): void {
        const wasRunning = this.status.isRunning;
        const oldInterval = this.settings.intervalHours;

        this.settings = { ...this.settings, ...newSettings };

        // If interval changed and monitoring is running, restart
        if (wasRunning && newSettings.intervalHours && newSettings.intervalHours !== oldInterval) {
            this.stop();
            this.start();
        }

        // If disabled, stop monitoring
        if (newSettings.enabled === false && wasRunning) {
            this.stop();
        }
    }

    /**
     * Set callback for when new recommendations are generated
     */
    setRecommendationCallback(callback: (recommendations: ReviewRecommendation[]) => void): void {
        this.onRecommendationCallback = callback;
    }

    // ========================================================================
    // Scheduler Control
    // ========================================================================

    /**
     * Start the monitoring scheduler
     */
    start(): void {
        if (!this.settings.enabled) {
            this.log('Behavior monitoring is disabled');
            return;
        }

        if (this.status.isRunning) {
            this.log('Monitoring already running');
            return;
        }

        const intervalMs = this.settings.intervalHours * 60 * 60 * 1000;

        // Run initial check
        this.runCheck().catch(err => this.log('Initial check error:', err));

        // Schedule periodic checks
        this.intervalId = setInterval(() => {
            this.runCheck().catch(err => this.log('Scheduled check error:', err));
        }, intervalMs);

        this.status.isRunning = true;
        this.status.intervalHours = this.settings.intervalHours;
        this.updateNextCheck();

        this.log(`Started behavior monitoring (interval: ${this.settings.intervalHours}h)`);
    }

    /**
     * Stop the monitoring scheduler
     */
    stop(): void {
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
        }

        this.status.isRunning = false;
        this.status.nextCheck = null;

        this.log('Stopped behavior monitoring');
    }

    /**
     * Get scheduler status
     */
    getStatus(): SchedulerStatus {
        return { ...this.status };
    }

    /**
     * Manually trigger a monitoring check
     */
    async triggerManualCheck(): Promise<MonitoringResult> {
        return this.runCheck();
    }

    // ========================================================================
    // Core Monitoring Logic
    // ========================================================================

    /**
     * Run a complete monitoring check
     * Non-blocking: errors are caught and logged, never thrown
     */
    private async runCheck(): Promise<MonitoringResult> {
        const startTime = Date.now();
        this.status.totalChecks++;

        try {
            this.log('Starting behavior monitoring check...');

            // Parallel fetch weakness clusters and stale reviews
            // Both return { data, error } to track partial failures
            const [weaknessResult, staleResult] = await Promise.all([
                this.detectWeaknessClusters(),
                this.detectStaleReviews(),
            ]);

            const weaknessClusters = weaknessResult.data;
            const staleReviewConcepts = staleResult.data;

            // Determine success: if BOTH APIs failed, mark as failed
            const bothFailed = weaknessResult.error !== null && staleResult.error !== null;
            let combinedError: string | undefined;
            if (bothFailed) {
                // If both errors are the same, use simplified message
                if (weaknessResult.error === staleResult.error) {
                    combinedError = weaknessResult.error ?? undefined;
                } else {
                    combinedError = `weakness: ${weaknessResult.error}; stale: ${staleResult.error}`;
                }
            }

            // Generate recommendations (even with partial data)
            const newRecommendations = this.generateRecommendations(weaknessClusters, staleReviewConcepts);

            // Add to recommendations list
            this.recommendations = [...newRecommendations, ...this.recommendations].slice(0, 100); // Keep last 100

            // Notify callback
            if (this.onRecommendationCallback && newRecommendations.length > 0) {
                this.onRecommendationCallback(newRecommendations);
            }

            const result: MonitoringResult = {
                timestamp: new Date(),
                success: !bothFailed,
                error: combinedError,
                durationMs: Date.now() - startTime,
                weaknessClusters,
                staleReviewConcepts,
                totalRecommendations: newRecommendations.length,
            };

            this.lastResult = result;
            if (bothFailed) {
                this.status.failedChecks++;
            } else {
                this.status.successfulChecks++;
            }
            this.status.lastCheck = new Date();
            this.updateNextCheck();

            this.log(`Check completed: ${weaknessClusters.length} clusters, ${staleReviewConcepts.length} stale, ${newRecommendations.length} recommendations${bothFailed ? ' (with errors)' : ''}`);

            return result;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);

            const result: MonitoringResult = {
                timestamp: new Date(),
                success: false,
                error: errorMessage,
                durationMs: Date.now() - startTime,
                weaknessClusters: [],
                staleReviewConcepts: [],
                totalRecommendations: 0,
            };

            this.lastResult = result;
            this.status.failedChecks++;
            this.status.lastCheck = new Date();
            this.updateNextCheck();

            // Non-blocking: log error but don't throw
            this.log('Check failed:', errorMessage);

            return result;
        }
    }

    /**
     * Detect weakness clusters (≥N red nodes in same community)
     * Returns { data, error } to allow tracking partial failures
     */
    private async detectWeaknessClusters(): Promise<{ data: WeaknessCluster[]; error: string | null }> {
        try {
            const response = await requestUrl({
                url: `${this.settings.apiBaseUrl}/memory/behavior/weakness-clusters`,
                method: 'GET',
                headers: { 'Content-Type': 'application/json' },
            });

            if (response.status !== 200) {
                this.log('Weakness cluster API returned non-200:', response.status);
                return { data: [], error: null }; // Non-200 is not a hard error
            }

            const data = response.json;
            const clusters: WeaknessCluster[] = (data?.clusters || []).map((c: any) => ({
                clusterId: c.cluster_id || c.clusterId,
                communityName: c.community_name || c.communityName || 'Unknown',
                canvasName: c.canvas_name || c.canvasName || '',
                redNodes: (c.red_nodes || c.redNodes || []).map((n: any) => ({
                    nodeId: n.node_id || n.nodeId,
                    conceptName: n.concept_name || n.conceptName,
                    daysSinceReview: n.days_since_review || n.daysSinceReview || 0,
                    memoryStrength: n.memory_strength || n.memoryStrength || 0,
                    relatedConcepts: n.related_concepts || n.relatedConcepts || [],
                })),
                totalNodes: c.total_nodes || c.totalNodes || 0,
                weaknessRatio: c.weakness_ratio || c.weaknessRatio || 0,
                recommendation: c.recommendation || '',
            }));

            // Filter by threshold
            return { data: clusters.filter(c => c.redNodes.length >= this.settings.weaknessClusterThreshold), error: null };
        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            this.log('Error detecting weakness clusters:', errorMsg);
            return { data: [], error: errorMsg };
        }
    }

    /**
     * Detect concepts that haven't been reviewed for extended period
     * Returns { data, error } to allow tracking partial failures
     */
    private async detectStaleReviews(): Promise<{ data: StaleReviewConcept[]; error: string | null }> {
        try {
            const response = await requestUrl({
                url: `${this.settings.apiBaseUrl}/memory/behavior/stale-reviews?days=${this.settings.daysWithoutReviewThreshold}`,
                method: 'GET',
                headers: { 'Content-Type': 'application/json' },
            });

            if (response.status !== 200) {
                this.log('Stale reviews API returned non-200:', response.status);
                return { data: [], error: null }; // Non-200 is not a hard error
            }

            const data = response.json;
            const concepts = (data?.stale_concepts || data?.staleConcepts || []).map((c: any) => ({
                conceptName: c.concept_name || c.conceptName,
                nodeId: c.node_id || c.nodeId,
                canvasName: c.canvas_name || c.canvasName || '',
                daysSinceReview: c.days_since_review || c.daysSinceReview || 0,
                lastReviewDate: c.last_review_date ? new Date(c.last_review_date) : null,
                estimatedRetention: c.estimated_retention || c.estimatedRetention || 0,
                reviewPriority: c.review_priority || c.reviewPriority || 50,
            }));
            return { data: concepts, error: null };
        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            this.log('Error detecting stale reviews:', errorMsg);
            return { data: [], error: errorMsg };
        }
    }

    /**
     * Generate review recommendations from detected issues
     */
    private generateRecommendations(
        clusters: WeaknessCluster[],
        staleConcepts: StaleReviewConcept[]
    ): ReviewRecommendation[] {
        const recommendations: ReviewRecommendation[] = [];
        const now = new Date();

        // Recommendations from weakness clusters
        for (const cluster of clusters) {
            recommendations.push({
                id: `cluster-${cluster.clusterId}-${now.getTime()}`,
                type: 'weakness_cluster',
                priority: Math.min(10, 5 + cluster.redNodes.length), // 5-10 based on severity
                title: `薄弱点聚集: ${cluster.communityName}`,
                description: `发现${cluster.redNodes.length}个红色节点在"${cluster.communityName}"社区中，薄弱比例${(cluster.weaknessRatio * 100).toFixed(0)}%`,
                concepts: cluster.redNodes.map(n => n.conceptName),
                canvasName: cluster.canvasName,
                suggestedAction: `建议集中复习"${cluster.communityName}"相关概念，从最基础的概念开始`,
                createdAt: now,
            });
        }

        // Recommendations from stale reviews (high priority ones)
        const urgentStale = staleConcepts.filter(c => c.daysSinceReview >= this.settings.daysWithoutReviewThreshold * 2);
        if (urgentStale.length > 0) {
            recommendations.push({
                id: `stale-urgent-${now.getTime()}`,
                type: 'stale_review',
                priority: 8,
                title: `紧急复习提醒: ${urgentStale.length}个概念`,
                description: `有${urgentStale.length}个概念超过${this.settings.daysWithoutReviewThreshold * 2}天未复习，记忆可能已显著衰退`,
                concepts: urgentStale.map(c => c.conceptName),
                canvasName: urgentStale[0]?.canvasName || '',
                suggestedAction: '建议立即进行复习以防止遗忘',
                createdAt: now,
            });
        }

        // Group normal stale by canvas
        const staleByCanvas = new Map<string, StaleReviewConcept[]>();
        for (const concept of staleConcepts.filter(c => c.daysSinceReview < this.settings.daysWithoutReviewThreshold * 2)) {
            const list = staleByCanvas.get(concept.canvasName) || [];
            list.push(concept);
            staleByCanvas.set(concept.canvasName, list);
        }

        for (const [canvasName, concepts] of staleByCanvas) {
            if (concepts.length >= 2) {
                recommendations.push({
                    id: `stale-${canvasName}-${now.getTime()}`,
                    type: 'stale_review',
                    priority: 5 + Math.min(3, Math.floor(concepts.length / 3)), // 5-8 based on count
                    title: `复习提醒: ${canvasName}`,
                    description: `${canvasName}中有${concepts.length}个概念需要复习`,
                    concepts: concepts.map(c => c.conceptName),
                    canvasName,
                    suggestedAction: '建议在本次学习时段内完成复习',
                    createdAt: now,
                });
            }
        }

        // Sort by priority (highest first)
        return recommendations.sort((a, b) => b.priority - a.priority);
    }

    // ========================================================================
    // Recommendations Access
    // ========================================================================

    /**
     * Get all current recommendations
     */
    getRecommendations(): ReviewRecommendation[] {
        return [...this.recommendations];
    }

    /**
     * Get recommendations filtered by type
     */
    getRecommendationsByType(type: ReviewRecommendation['type']): ReviewRecommendation[] {
        return this.recommendations.filter(r => r.type === type);
    }

    /**
     * Get high priority recommendations (priority >= 7)
     */
    getHighPriorityRecommendations(): ReviewRecommendation[] {
        return this.recommendations.filter(r => r.priority >= 7);
    }

    /**
     * Clear a specific recommendation by ID
     */
    clearRecommendation(id: string): void {
        this.recommendations = this.recommendations.filter(r => r.id !== id);
    }

    /**
     * Clear all recommendations
     */
    clearAllRecommendations(): void {
        this.recommendations = [];
    }

    /**
     * Get last monitoring result
     */
    getLastResult(): MonitoringResult | null {
        return this.lastResult;
    }

    // ========================================================================
    // Utility Methods
    // ========================================================================

    /**
     * Update next scheduled check time
     */
    private updateNextCheck(): void {
        if (this.status.isRunning) {
            const nextTime = new Date();
            nextTime.setHours(nextTime.getHours() + this.settings.intervalHours);
            this.status.nextCheck = nextTime;
        }
    }

    /**
     * Log message if logging is enabled
     */
    private log(...args: any[]): void {
        if (this.settings.enableLogging) {
            console.log('[BehaviorMonitor]', ...args);
        }
    }

    /**
     * Get monitoring statistics
     */
    getStatistics(): {
        totalChecks: number;
        successRate: number;
        averageDuration: number;
        recommendationsGenerated: number;
        lastCheckTime: Date | null;
    } {
        const successRate = this.status.totalChecks > 0
            ? (this.status.successfulChecks / this.status.totalChecks) * 100
            : 0;

        return {
            totalChecks: this.status.totalChecks,
            successRate: Math.round(successRate * 10) / 10,
            averageDuration: this.lastResult?.durationMs || 0,
            recommendationsGenerated: this.recommendations.length,
            lastCheckTime: this.status.lastCheck,
        };
    }
}

// ============================================================================
// Factory Function
// ============================================================================

/**
 * Create a new BehaviorMonitorService instance
 */
export function createBehaviorMonitorService(
    app: App,
    settings?: Partial<BehaviorMonitorSettings>
): BehaviorMonitorService {
    return new BehaviorMonitorService(app, settings);
}
