#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
为CS70HW2.canvas中的紫色节点添加黄色理解节点
"""

import json
import uuid

# 读取Canvas文件
canvas_path = r"C:\Users\ROG\托福\笔记库\CS70\CS70HW2\CS70HW2.canvas"

with open(canvas_path, 'r', encoding='utf-8') as f:
    canvas_data = json.load(f)

# 紫色节点的个人理解内容（根据每个节点的主题填写）
understanding_texts = {
    "341570c6a730b5b1": """# 我对改善引理的理解

**核心思想**：这个引理证明了求职者收到的offer质量只会越来越好，不会变差。

**关键点**：
1. **归纳证明的结构**：这是一个标准的数学归纳法证明
   - 基础情形：第k天求职者至少收到了J的offer
   - 归纳步骤：如果第i天成立，那么第i+1天也成立

2. **为什么offer不会变差？**
   - 因为算法规定offer不能被撤回
   - 求职者总是保留最好的那个offer
   - 所以后续收到的offer要么更好，要么还是保留原来的

3. **良序原则的作用**：
   - 良序原则说自然数集合总有最小元素
   - 这保证了"第一个反例"这个概念是有意义的
   - 归纳法本质上依赖于自然数的良好排序性质

**不太确定的地方**：
- 为什么整数不满足良序原则？因为整数可以无限小（负无穷）
- 良序原则和归纳法的等价性我需要再想想""",

    "682d611321261951": """# 我对良序原则和证明技巧的理解

**良序原则是什么**：
任何非空的自然数集合都有一个最小元素。这听起来很显然，但实际上是自然数的特殊性质。

**例子检查**：
- $S_1 = \\{5,2,11,7,8\\}$：最小元素是2 ✓
- $S_2 = \\{奇数\\}$：最小元素是1 ✓
- $S_3 = \\{素数\\}$：最小元素是2 ✓

**为什么整数不满足**：
整数可以是负数，比如 $\\{..., -3, -2, -1\\}$ 没有最小元素

**为什么实数不满足**：
比如 $(0,1)$ 这个开区间，没有最小元素（0不在集合内）

**两种证明的等价性**：
- 第一种证明：标准归纳法，证明P(k) → P(k+1)
- 第二种证明：假设存在第一个反例，然后推出矛盾
- 两者本质相同，都依赖于良序原则

**我的疑问**：
- 为什么说"这也是归纳证明"？因为它实际上是用反证法证明了归纳步骤的否定不成立""",

    "3555228bb82ac9e3": """# 我对引理4.3和定理4.1的理解

## 引理4.3：算法总产生匹配

**证明思路（反证法）**：
1. 假设有工作J没被匹配
2. 那么J必须被所有n位求职者拒绝过
3. 根据改善引理，这n位求职者都有更好的offer
4. 所以n位求职者保留着n份工作的offer（不包括J）
5. 矛盾！因为总共只有n份工作

**为什么巧妙**：利用了改善引理 + 计数论证

## 定理4.1：算法产生的匹配总是稳定的

**证明思路（直接证明）**：
证明不存在不稳定配对(J, C*)

1. 假设J更偏好C*而不是当前伙伴C
2. 因为J的列表上C*排在C前面，所以J必定先向C*提议过
3. 根据改善引理，C*最终的工作至少和J一样好
4. 所以C*不会愿意离开当前工作去J
5. 因此(J, C*)不是不稳定配对

**核心洞察**：
- 工作的角度：如果我更喜欢别人，那我肯定早就向她提议过了
- 求职者的角度：既然我拒绝了你，说明我有更好的选择

**我不太确定的**：
为什么只从工作角度证明就够了？是否需要从求职者角度也证明一遍？""",

    "9a87dc6b862693c3": """# 我对定义4.2（最优求职者）的理解

**最优求职者的定义**：
对于工作J，最优求职者是J偏好列表上排名最高的、且在某个稳定匹配中可能与J配对的求职者。

**关键点**：
1. **不是第一选择**：最优求职者不一定是工作的第一选择！
   - 因为第一选择可能导致不稳定匹配
   - 例如：工作2的第一选择是A，但A永远不会在稳定匹配中与2配对

2. **"某个稳定匹配"**：
   - 可能存在多个稳定匹配
   - 最优求职者是在所有稳定匹配中，该工作能得到的最好结果

3. **雇主最优匹配**：
   - 如果存在一个匹配，让所有工作都得到其最优求职者
   - 这个匹配就叫雇主最优匹配
   - 例子中的S就是这样的匹配

**我的理解**：
最优性是相对于"稳定性约束"而言的。不能只考虑自己的偏好，还要考虑对方是否愿意。

**疑问**：
为什么一定存在雇主最优匹配？是否所有工作的最优求职者能同时满足？""",

    "af5e1ba5b395f823": """# 我对定义4.3和定理4.2的理解

## 定义4.3：求职者的最优工作

类似于工作的最优求职者，但从求职者角度看：
- 求职者C的最优工作 = C偏好列表上排名最高的、且在某个稳定匹配中可能与C配对的工作
- 求职者最优匹配 = 所有求职者都得到其最优工作的匹配

**例子**：检查T是否是求职者最优匹配（我需要具体验证每个求职者）

## 定理4.2：提议-拒绝算法是雇主最优的

**证明思路（反证法 + 良序原则）**：

1. **假设**：匹配不是雇主最优的
2. **那么**：存在某天k，某工作J被其最优求职者C*拒绝
3. **设**：第k天是第一次发生这种情况（良序原则！）
4. **分析**：
   - C*拒绝J是因为更喜欢J*的offer
   - 存在稳定匹配T，其中(J, C*)配对
   - 在T中，假设J*与C'配对
5. **推出矛盾**：
   - C*更喜欢J*而不是J（因为她在算法中拒绝了J）
   - J*更喜欢C*而不是C'（因为第k天前J*没被最优求职者拒绝）
   - 所以(J*, C*)在T中是不稳定配对
   - 矛盾！T应该是稳定的

**良序原则的使用**：
"第k天是第一个发生这种情况的日子" - 这保证了第k天之前，所有工作都还没被其最优求职者拒绝过

**我的疑问**：
- 为什么"第k天前J*没被最优求职者拒绝"就能推出"J*更喜欢C*而不是C'"？
- 我觉得是因为：J*在第k天向C*提议，说明C*在J*的列表上排名很高，至少和J*的最优求职者一样高""",

    "73b50d9608b11e56": """# 我对定理4.3和算法分析的理解

## 定理4.3：雇主最优 = 求职者最差

**证明思路（反证法）**：

1. **设定**：T是雇主最优匹配，其中(J, C)配对
2. **假设**：存在稳定匹配S，其中C的工作J*比J差（即J不是C的最差工作）
3. **在S中**：(J*, C)和(J, C')配对
4. **推出矛盾**：
   - C更喜欢J而不是J*（因为J*排名更低）
   - J更喜欢C而不是C'（因为C是J在雇主最优匹配T中的伙伴）
   - 所以(J, C)在S中是不稳定配对
   - 矛盾！

**核心洞察**：
雇主最优 ⟺ 求职者最差。这是一个零和博弈！
- 提议方（雇主）得到最好的结果
- 接受方（求职者）得到最差的结果

**现实意义**：
- 历史上N.R.M.P.由医院提议 → 医院最优
- 90年代改为学生提议 → 学生最优
- 制度设计很重要！谁提议谁占优

**练习思考**：
要让求职者最优，只需要让求职者来提议！算法流程完全对称。

**我的理解**：
这个定理揭示了提议-拒绝算法的一个重要特征：它对提议方有利。这在现实中有重要的政策含义 - 我们需要保护弱势一方，所以应该让弱势一方来提议。

**不确定的地方**：
- 为什么"C是J在T中的伙伴"就能推出"J更喜欢C而不是C'"？
- 我想是因为：T是雇主最优，所以C是J能得到的最好结果，因此J肯定更喜欢C"""
}

# 为每个紫色节点创建对应的黄色理解节点
yellow_nodes = []
edges_to_add = []

for node in canvas_data['nodes']:
    if node.get('color') == '3' and node['id'] in understanding_texts:
        purple_id = node['id']
        purple_x = node['x']
        purple_y = node['y']
        purple_height = node['height']
        purple_width = node['width']

        # 创建黄色节点（在紫色节点右侧下方）
        yellow_id = str(uuid.uuid4()).replace('-', '')
        yellow_x = purple_x + purple_width + 100  # 右侧100px
        yellow_y = purple_y + 50  # 下移50px对齐

        yellow_node = {
            "id": yellow_id,
            "x": yellow_x,
            "y": yellow_y,
            "width": 600,
            "height": 500,
            "color": "6",  # 黄色
            "type": "text",
            "text": understanding_texts[purple_id]
        }

        yellow_nodes.append(yellow_node)

        # 创建从紫色到黄色的边
        edge_id = str(uuid.uuid4()).replace('-', '')
        edge = {
            "id": edge_id,
            "fromNode": purple_id,
            "fromSide": "right",
            "toNode": yellow_id,
            "toSide": "left",
            "label": "个人理解"
        }
        edges_to_add.append(edge)

# 添加新节点和边到Canvas
canvas_data['nodes'].extend(yellow_nodes)
canvas_data['edges'].extend(edges_to_add)

# 保存更新后的Canvas文件
with open(canvas_path, 'w', encoding='utf-8') as f:
    json.dump(canvas_data, f, ensure_ascii=False, indent='\t')

print(f"✅ 成功添加了 {len(yellow_nodes)} 个黄色理解节点！")
print(f"✅ 创建了 {len(edges_to_add)} 条连接边！")
print(f"\n节点分布：")
for i, (purple_id, yellow_node) in enumerate(zip(understanding_texts.keys(), yellow_nodes), 1):
    print(f"  {i}. 紫色节点 {purple_id[:8]}... → 黄色节点 {yellow_node['id'][:8]}...")
