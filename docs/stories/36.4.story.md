# Story 36.4: Canvas打开时全量Edge同步

## Status

Done

## Story

**As a** Canvas Learning System user,
**I want** all edges to be synced to Neo4j when a Canvas is opened,
**so that** the knowledge graph is always up-to-date with the Canvas structure after reopening.

## Acceptance Criteria

1. `POST /api/v1/canvas/{canvas_path}/sync-edges` endpoint is implemented
2. Endpoint reads all edges from the Canvas file and syncs each to Neo4j
3. Sync is idempotent - repeated calls do not create duplicate relationships (MERGE semantics)
4. Sync returns summary with total edges, synced count, and skipped count
5. Endpoint uses async processing - individual edge syncs run concurrently
6. Errors in single edge sync do not fail the entire batch - partial success is acceptable
7. Response time < 5 seconds for Canvas with up to 100 edges

## Tasks / Subtasks

- [x] Task 1: Create `sync_all_edges_to_neo4j()` method in CanvasService (AC: 2, 3, 5, 6)
  - [x] 1.1 Add method signature: `async def sync_all_edges_to_neo4j(self, canvas_name: str) -> SyncEdgesSummary`
  - [x] 1.2 Read Canvas file using existing `read_canvas()` method
  - [x] 1.3 Extract all edges from canvas_data["edges"]
  - [x] 1.4 Use `asyncio.gather()` to sync edges concurrently (reuse `_sync_edge_to_neo4j` from Story 36.3)
  - [x] 1.5 Collect results and build summary (total, synced, failed)

- [x] Task 2: Create API endpoint `POST /api/v1/canvas/{canvas_path}/sync-edges` (AC: 1, 4, 7)
  - [x] 2.1 Add endpoint to `backend/app/api/v1/endpoints/canvas.py`
  - [x] 2.2 Create `SyncEdgesSummary` Pydantic model in `backend/app/models/`
  - [x] 2.3 Inject CanvasService and Neo4jClient via dependencies
  - [x] 2.4 Return HTTP 200 with summary on success

- [x] Task 3: Implement idempotent sync using MERGE (AC: 3)
  - [x] 3.1 Verify Neo4jClient.create_edge_relationship() uses MERGE (already implemented in Story 30.5)
  - [x] 3.2 Add unit test to verify no duplicate relationships on repeated sync

- [x] Task 4: Add unit and integration tests (AC: 1-7)
  - [x] 4.1 Unit test: verify endpoint returns correct summary format
  - [x] 4.2 Unit test: verify concurrent edge sync execution
  - [x] 4.3 Integration test: sync Canvas with 50 edges, verify all appear in Neo4j
  - [x] 4.4 Integration test: call sync twice, verify no duplicates in Neo4j
  - [x] 4.5 Integration test: verify partial failure handling (mock one edge to fail)
  - [x] 4.6 Performance test: sync 100 edges in < 5 seconds

- [x] Task 5: Update OpenAPI specification (SDD Consistency)
  - [x] 5.1 Add `POST /canvas/{canvas_path}/sync-edges` endpoint to `specs/api/canvas-api.openapi.yml`
  - [x] 5.2 Add `SyncEdgesSummary` response schema to `components/schemas` section
  - [x] 5.3 Add endpoint under `Layer4-Knowledge` tag (consistent with knowledge graph operations)
  - [x] 5.4 Define HTTP 200 success response and HTTP 404 (canvas not found) error response

## Dev Notes

### SDD规范参考 (必填)

**API端点** (从OpenAPI specs):
- 端点路径和方法: `POST /api/v1/canvas/{canvas_path}/sync-edges` (新增端点 - Task 5添加到OpenAPI spec)
- 类似端点参考: `GET /canvas/{canvas_path}` → `[Source: specs/api/canvas-api.openapi.yml#L58-L76]`
- 请求Schema: 无请求体（路径参数 canvas_path）
- 响应Schema: 新增 `SyncEdgesSummary` schema (Task 5.2添加到OpenAPI spec):
  ```json
  {
    "canvas_path": "string",
    "total_edges": "integer",
    "synced_count": "integer",
    "failed_count": "integer",
    "skipped_count": "integer",
    "sync_time_ms": "number"
  }
  ```

**数据Schema** (从JSON Schema):
- 模型名称: `CanvasEdge`
- Schema来源: `[Source: specs/data/canvas-edge.schema.json]`
- 必填字段: `id`, `fromNode`, `toNode`
- 可选字段: `fromSide`, `toSide`, `label`
- ID验证规则: UUID格式 `^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$`

**Neo4j关系Schema**:
- 关系类型: `CONNECTS_TO` (节点间连接)
- 属性: `edge_id`, `label`, `created_at`
- 来源: `[Source: backend/app/clients/neo4j_client.py#L847-893]`
- 幂等保证: 使用 `MERGE` 语法，重复调用不创建重复关系

### ADR决策关联 (必填)

| ADR编号 | 决策标题 | 对Story的影响 |
|---------|----------|---------------|
| ADR-0003 | Graphiti Memory系统 | Neo4j存储架构，MERGE幂等语义，500ms单操作超时 |
| ADR-0004 | 异步执行引擎 | 使用`asyncio.gather()`并发同步，最大12并发 |
| ADR-009 | 错误处理重试策略 | tenacity重试(3次指数退避)，部分失败不阻塞整体 |

**关键约束** (从ADR Consequences提取):
- **ADR-0003**: MERGE语法保证幂等性，重复同步不产生重复数据
- **ADR-0004**: 并发执行使用Semaphore限制，避免Neo4j连接池耗尽
- **ADR-009**: 使用`asyncio.gather(..., return_exceptions=True)`捕获单个失败，不中断批处理

### 现有代码集成点

**canvas_service.py** (`backend/app/services/canvas_service.py`):
```python
# Story 36.3已添加的方法 (复用)
async def _sync_edge_to_neo4j(
    self,
    canvas_path: str,
    edge_id: str,
    from_node_id: str,
    to_node_id: str,
    edge_label: Optional[str] = None
) -> bool:
    """Fire-and-forget同步edge到Neo4j"""
    return await self.neo4j_client.create_edge_relationship(...)

# Line 485-522: 现有read_canvas()方法获取Canvas数据
async def read_canvas(self, canvas_name: str) -> Dict[str, Any]:
    # 返回 {"nodes": [...], "edges": [...]}
```

**neo4j_client.py** (`backend/app/clients/neo4j_client.py`):
```python
# Line 847-893: 已有的create_edge_relationship()方法
async def create_edge_relationship(
    self, canvas_path, edge_id, from_node_id, to_node_id, edge_label=None
) -> bool:
    query = """
    MERGE (c:Canvas {path: $canvasPath})
    MERGE (from:Node {id: $fromNodeId})
    MERGE (to:Node {id: $toNodeId})
    MERGE (from)-[r:CONNECTS_TO {edge_id: $edgeId}]->(to)
    SET r.label = $edgeLabel,
        r.created_at = coalesce(r.created_at, datetime())
    RETURN c, from, to, r
    """
    # 使用MERGE保证幂等性
```

**canvas.py router** (`backend/app/api/v1/endpoints/canvas.py`):
```python
# 现有端点模式 (参考)
@canvas_router.get("/{canvas_name}", response_model=CanvasResponse)
async def read_canvas(canvas_name: str) -> CanvasResponse:
    ...

# 新增端点应遵循相同模式
@canvas_router.post("/{canvas_path}/sync-edges", response_model=SyncEdgesSummary)
async def sync_edges(canvas_path: str, canvas_service: CanvasService = Depends(...)) -> SyncEdgesSummary:
    ...
```

### 实现参考代码

```python
# 在canvas_service.py中添加
from typing import NamedTuple

class SyncEdgesSummary(NamedTuple):
    canvas_path: str
    total_edges: int
    synced_count: int
    failed_count: int
    skipped_count: int
    sync_time_ms: float

class CanvasService:
    async def sync_all_edges_to_neo4j(self, canvas_name: str) -> SyncEdgesSummary:
        """
        同步Canvas所有edges到Neo4j (幂等操作).

        Story 36.4: 全量Edge同步端点
        - 读取Canvas所有edges
        - 并发同步到Neo4j
        - 返回同步摘要

        [Source: docs/stories/36.4.story.md]
        """
        import time
        start_time = time.time()

        # 1. 读取Canvas数据
        canvas_data = await self.read_canvas(canvas_name)
        edges = canvas_data.get("edges", [])
        total_edges = len(edges)

        if total_edges == 0:
            return SyncEdgesSummary(
                canvas_path=canvas_name,
                total_edges=0,
                synced_count=0,
                failed_count=0,
                skipped_count=0,
                sync_time_ms=0.0
            )

        # 2. 并发同步所有edges (使用Semaphore限制并发数)
        semaphore = asyncio.Semaphore(12)  # ADR-0004: 最大12并发

        async def sync_single_edge(edge: Dict[str, Any]) -> bool:
            async with semaphore:
                try:
                    return await self._sync_edge_to_neo4j(
                        canvas_path=canvas_name,
                        edge_id=edge["id"],
                        from_node_id=edge["fromNode"],
                        to_node_id=edge["toNode"],
                        edge_label=edge.get("label")
                    )
                except Exception as e:
                    logger.warning(f"Edge sync failed: {edge['id']}, error: {e}")
                    return False

        # ADR-009: return_exceptions=True 捕获单个失败，不中断批处理
        results = await asyncio.gather(
            *[sync_single_edge(edge) for edge in edges],
            return_exceptions=True
        )

        # 3. 计算统计
        synced_count = sum(1 for r in results if r is True)
        failed_count = sum(1 for r in results if r is False or isinstance(r, Exception))
        skipped_count = total_edges - synced_count - failed_count

        elapsed_ms = (time.time() - start_time) * 1000

        return SyncEdgesSummary(
            canvas_path=canvas_name,
            total_edges=total_edges,
            synced_count=synced_count,
            failed_count=failed_count,
            skipped_count=skipped_count,
            sync_time_ms=elapsed_ms
        )
```

```python
# 在canvas.py router中添加
from pydantic import BaseModel

class SyncEdgesSummaryResponse(BaseModel):
    """Edge同步结果摘要 - Story 36.4"""
    canvas_path: str
    total_edges: int
    synced_count: int
    failed_count: int
    skipped_count: int
    sync_time_ms: float

@canvas_router.post(
    "/{canvas_path}/sync-edges",
    response_model=SyncEdgesSummaryResponse,
    summary="Sync all Canvas edges to Neo4j",
    operation_id="sync_canvas_edges",
    tags=["Layer4-Knowledge"],
)
async def sync_edges(
    canvas_path: str,
    canvas_service: CanvasService = Depends(get_canvas_service),
) -> SyncEdgesSummaryResponse:
    """
    同步Canvas所有edges到Neo4j知识图谱.

    - **canvas_path**: Canvas文件路径
    - 幂等操作: 重复调用不创建重复关系
    - 并发处理: 最多12个edge同时同步

    Story 36.4: Canvas打开时全量Edge同步
    [Source: docs/stories/36.4.story.md]
    """
    summary = await canvas_service.sync_all_edges_to_neo4j(canvas_path)
    return SyncEdgesSummaryResponse(
        canvas_path=summary.canvas_path,
        total_edges=summary.total_edges,
        synced_count=summary.synced_count,
        failed_count=summary.failed_count,
        skipped_count=summary.skipped_count,
        sync_time_ms=summary.sync_time_ms
    )
```

### Testing

**测试文件位置**:
- `backend/tests/unit/test_canvas_edge_bulk_sync.py`
- `backend/tests/integration/test_edge_bulk_neo4j_sync.py`

**测试标准**:
- pytest框架 + pytest-asyncio
- 使用现有Mock模式：`@pytest.fixture` + `AsyncMock`
- 集成测试需要Neo4j Docker运行 (`NEO4J_MOCK=false`)

**测试场景**:
1. 单元测试：验证endpoint返回正确的summary格式
2. 单元测试：验证并发执行（mock neo4j_client，验证多个create_edge_relationship调用）
3. 集成测试：同步50 edges的Canvas，验证Neo4j中存在所有关系
4. 集成测试：调用sync两次，验证Neo4j中无重复关系（MERGE幂等性）
5. 集成测试：模拟1个edge失败，验证其他edges仍成功同步
6. 性能测试：100 edges在5秒内完成同步

**测试代码示例**:
```python
@pytest.mark.asyncio
async def test_sync_edges_idempotent():
    """测试幂等性 - 重复调用不创建重复关系"""
    # 第一次调用
    response1 = await client.post(f"/api/v1/canvas/{canvas_path}/sync-edges")
    assert response1.status_code == 200
    result1 = response1.json()

    # 第二次调用 (幂等)
    response2 = await client.post(f"/api/v1/canvas/{canvas_path}/sync-edges")
    assert response2.status_code == 200
    result2 = response2.json()

    # 两次结果应该相同 (MERGE不创建重复)
    assert result1["synced_count"] == result2["synced_count"]

    # 验证Neo4j中无重复关系
    query_result = await neo4j_client.run_query(
        "MATCH ()-[r:CONNECTS_TO]->() RETURN count(r) as count"
    )
    assert query_result[0]["count"] == result1["total_edges"]
```

## Dependencies

- **Story 36.3**: Canvas Edge自动同步到Neo4j (provides `_sync_edge_to_neo4j()` method)
- **Story 36.2**: GraphitiClient真实Neo4j调用实现 (provides working Neo4j connection)
- **EPIC-30 Story 30.2**: Neo4jClient真实驱动 (provides `create_edge_relationship()`)

## Estimated Effort

~280行新代码（含测试 + OpenAPI spec更新）

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-20 | 0.1 | Initial draft with full Dev Notes | SM Agent (Bob) |
| 2026-01-20 | 0.2 | Added Task 5: OpenAPI spec update (PO validation fix) | PO Agent (Sarah) |

## Dev Agent Record

### Agent Model Used

claude-opus-4-5-20251101 (Claude Opus 4.5)

### Debug Log References

- Unit test fix: Changed partial failure test mock from call_count-based to edge_id-based failure to persist failure across retries

### Completion Notes List

1. **Task 1**: Added `sync_all_edges_to_neo4j()` method to CanvasService (lines 374-445) with:
   - Semaphore(12) for ADR-0004 concurrency control
   - asyncio.gather with return_exceptions=True for ADR-009 partial failure handling
   - tenacity retry via existing `_sync_edge_to_neo4j()` method

2. **Task 2**: Created `POST /{canvas_name}/sync-edges` endpoint in canvas.py with:
   - `SyncEdgesSummaryResponse` Pydantic model
   - Layer4-Knowledge tag for OpenAPI categorization
   - CanvasServiceDep dependency injection

3. **Task 3**: Verified MERGE semantics in neo4j_client.py (line 880) - no changes needed

4. **Task 4**: Created comprehensive test suites:
   - 8 unit tests (all passing): success, empty canvas, partial failure, concurrent execution, no memory client, format, idempotency, performance
   - 4 integration tests for real Neo4j scenarios

5. **Task 5**: Updated specs/api/canvas-api.openapi.yml with endpoint definition and schema

### File List

| File | Action | Lines Changed |
|------|--------|---------------|
| `backend/app/services/canvas_service.py` | Modified | +72 (import time, sync_all_edges_to_neo4j method) |
| `backend/app/api/v1/endpoints/canvas.py` | Modified | +37 (SyncEdgesSummaryResponse model, sync_edges endpoint) |
| `specs/api/canvas-api.openapi.yml` | Modified | +89 (endpoint definition, SyncEdgesSummary schema) |
| `backend/tests/unit/test_canvas_edge_bulk_sync.py` | Created | +294 (8 test cases) |
| `backend/tests/integration/test_edge_bulk_neo4j_sync.py` | Created | +206 (4 integration tests) |

## QA Results

### Review Date: 2026-01-31

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: High Quality Implementation** ✅

Story 36.4 实现了 Canvas 打开时全量 Edge 同步到 Neo4j 的功能，代码质量优秀。

**亮点**:
1. **架构遵循 ADR**: 正确遵循 ADR-0003 (MERGE 幂等语义) 和 ADR-0004 (asyncio.gather + Semaphore)
2. **并发控制**: Semaphore(12) 限制最大并发数，防止 Neo4j 连接池耗尽
3. **部分失败处理**: 使用 `return_exceptions=True` 实现 AC-6，单个 edge 失败不阻塞批处理
4. **Fire-and-forget 模式**: `_sync_edge_to_neo4j` 返回 `None` 而非抛出异常，优雅降级
5. **tenacity 重试**: 3次指数退避重试 (1s, 2s, 4s) 符合 ADR-009
6. **Source 注释完整**: 所有关键方法都有 `[Source: ...]` 注释追溯到 Story/ADR

**代码复用**:
- 复用 Story 36.3 的 `_sync_edge_to_neo4j()` 方法
- 复用 Story 30.5 的 `create_edge_relationship()` MERGE 查询

### Refactoring Performed

无需重构 - 代码已符合最佳实践

### Compliance Check

- Coding Standards: ✓ 遵循 Python 异步编程最佳实践
- Project Structure: ✓ 文件位置符合 `backend/app/services/` 规范
- Testing Strategy: ✓ 单元测试(8个) + 集成测试(4个) 覆盖所有 AC
- All ACs Met: ✓ 7/7 验收标准全部满足

### Improvements Checklist

所有关键项已完成，以下为可选改进：

- [x] MERGE 语法幂等性 (AC-3) - `neo4j_client.py:880`
- [x] Semaphore(12) 并发控制 (AC-5) - `canvas_service.py:373`
- [x] `return_exceptions=True` 部分失败处理 (AC-6) - `canvas_service.py:393-395`
- [x] 性能测试 100 edges < 5s (AC-7) - `test_canvas_edge_bulk_sync.py:267-293`
- [x] OpenAPI spec 更新 (Task 5) - `canvas-api.openapi.yml:399-440`
- [ ] (可选) 考虑添加 `sync_time_ms` 到 INFO 日志以便监控
- [ ] (可选) 考虑添加 Prometheus metrics 记录批量同步指标

### Security Review

**无安全问题** ✅
- 无用户输入直接构造 Cypher 查询（使用参数化查询）
- 无敏感数据暴露
- 无权限提升风险

### Performance Considerations

**性能达标** ✅
- AC-7 验证：100 edges < 5 seconds
- Semaphore(12) 防止过度并发
- 早返回优化：空 Canvas 直接返回 `sync_time_ms: 0.0`

**潜在优化点** (非阻塞):
- 对于超大 Canvas (>1000 edges)，可考虑分批处理
- 可添加 batch size 参数支持更细粒度控制

### Files Modified During Review

无文件修改

### Gate Status

Gate: **PASS** → docs/qa/gates/36.4-canvas-edge-bulk-sync.yml

### Recommended Status

✓ Ready for Done

代码实现完整，测试覆盖全面，符合所有验收标准。
