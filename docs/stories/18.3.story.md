# Story 18.3: Rollback Engine - Canvas状态恢复

## Status
Draft

## Story

**As a** Canvas Learning System用户,
**I want** 回滚Canvas到之前的操作/快照/时间点,
**so that** 我可以从错误中恢复。

## Acceptance Criteria

1. `RollbackEngine`支持3种回滚: operation(单次撤销), snapshot(完整恢复), timepoint(最近快照)
2. 回滚前自动创建备份快照(可配置)
3. 操作回滚应用反向操作
4. 快照回滚完整替换Canvas状态
5. 时间点回滚找到最近的快照
6. POST `/api/v1/rollback/rollback` 执行回滚
7. 回滚失败自动从备份恢复
8. 所有代码有文档来源标注

## Tasks / Subtasks

- [ ] Task 1: 创建RollbackEngine核心类 (AC: 1)
  - [ ] 创建 `src/rollback/rollback_engine.py`
  - [ ] 定义RollbackType枚举 (operation, snapshot, timepoint)
  - [ ] 定义RollbackRequest dataclass
  - [ ] 定义RollbackResult dataclass
  - [ ] 实现 `RollbackEngine.__init__(tracker, snapshot_manager)`

- [ ] Task 2: 实现回滚前备份 (AC: 2)
  - [ ] 实现 `_create_backup_snapshot(canvas_path)` 方法
  - [ ] 添加 `create_backup` 配置选项 (默认True)
  - [ ] 在每种回滚操作前调用备份

- [ ] Task 3: 实现操作回滚 (AC: 3)
  - [ ] 实现 `rollback_operation(operation_id)` 方法
  - [ ] 实现 `_apply_reverse_operation(operation)` 方法
  - [ ] 为7种操作类型实现反向操作:
    - [ ] node_add → 删除节点
    - [ ] node_delete → 恢复节点
    - [ ] node_modify → 恢复before状态
    - [ ] node_color_change → 恢复before颜色
    - [ ] edge_add → 删除边
    - [ ] edge_delete → 恢复边
    - [ ] batch_operation → 批量反向操作

- [ ] Task 4: 实现快照回滚 (AC: 4)
  - [ ] 实现 `rollback_to_snapshot(snapshot_id)` 方法
  - [ ] 实现 `_replace_canvas_state(canvas_path, canvas_data)` 方法
  - [ ] 确保原子写入 (临时文件+重命名)

- [ ] Task 5: 实现时间点回滚 (AC: 5)
  - [ ] 实现 `rollback_to_timepoint(canvas_path, timestamp)` 方法
  - [ ] 实现 `_find_nearest_snapshot(canvas_path, timestamp)` 方法
  - [ ] 处理无快照的边界情况

- [ ] Task 6: 添加REST API端点 (AC: 6)
  - [ ] 在 `backend/app/api/v1/endpoints/rollback.py` 添加回滚端点
  - [ ] 实现 `POST /api/v1/rollback/rollback` 执行回滚
  - [ ] 更新Pydantic schemas (RollbackRequest, RollbackResult)

- [ ] Task 7: 实现回滚失败恢复 (AC: 7)
  - [ ] 实现 `_restore_from_backup(canvas_path, backup_snapshot_id)` 方法
  - [ ] 在rollback方法中添加try/except包装
  - [ ] 记录回滚失败日志

- [ ] Task 8: 集成测试 (AC: 8)
  - [ ] 创建 `src/tests/unit/test_rollback_engine.py`
  - [ ] 测试3种回滚类型
  - [ ] 测试7种操作的反向操作
  - [ ] 测试回滚失败恢复
  - [ ] 测试边界情况 (无快照、无操作等)
  - [ ] 确保测试覆盖率 >90%

## Dev Notes

### 技术验证报告 (Step 3.6)

**验证完成时间**: 2025-12-04
**验证执行人**: SM Agent (Bob)
**Quality Gate状态**: Pending

#### 技术栈清单

| 技术栈 | 查询方式 | 验证状态 | 文档位置 |
|--------|---------|---------|----------|
| orjson | Context7 | 待验证 | /ijl/orjson |
| shutil | Python stdlib | 已验证 | 标准库 |
| tempfile | Python stdlib | 已验证 | 标准库 |
| structlog | Local ADR | 已验证 | ADR-010 |

### SDD规范引用 (必填)

**API端点规范** (Epic 18 Rollback):
- `POST /api/v1/rollback/rollback` - 执行回滚
  - [Source: docs/architecture/rollback-recovery-architecture.md:344-380]
  - operationId: `executeRollback`
  - 请求Body: `RollbackRequest`
  - 响应Schema: `RollbackResult`

**RollbackRequest Schema** (Source: docs/architecture/rollback-recovery-architecture.md:344-380):
```typescript
interface RollbackRequest {
    canvas_path: string;           // Canvas文件路径
    rollback_type: RollbackType;   // operation | snapshot | timepoint
    target_id?: string;            // 操作ID或快照ID
    target_timestamp?: Date;       // 时间点 (timepoint类型)
    create_backup?: boolean;       // 是否创建备份 (默认true)
    preserve_graph?: boolean;      // 是否保留图谱状态 (默认false)
}

interface RollbackResult {
    success: boolean;
    canvas_path: string;
    rollback_type: RollbackType;
    backup_snapshot_id?: string;   // 备份快照ID
    restored_from?: string;        // 恢复来源 (操作ID/快照ID)
    message: string;
    graph_sync_status?: string;    // synced | pending | skipped
}
```

### ADR决策关联 (必填)

| ADR编号 | 决策标题 | 对Story的影响 |
|---------|----------|---------------|
| ADR-0009 | Error Handling | 回滚失败时的错误处理和恢复策略 |
| ADR-0010 | Logging Aggregation | 回滚操作日志使用structlog格式 |

**关键约束**:
- 回滚前必须创建备份快照(可配置禁用)
- 回滚失败时自动从备份恢复
- 所有回滚操作必须是原子的

### 架构设计参考

**架构文档引用**:
- RollbackEngine类设计: [Source: docs/architecture/rollback-recovery-architecture.md:380-480]
- 反向操作算法: [Source: docs/architecture/rollback-recovery-architecture.md:420-460]
- 失败恢复机制: [Source: docs/architecture/rollback-recovery-architecture.md:462-480]

### 代码示例库

**RollbackEngine类** (Source: docs/architecture/rollback-recovery-architecture.md:380-480):
```python
# src/rollback/rollback_engine.py
# ✅ Verified from Architecture Doc (rollback-recovery-architecture.md:380-480)
from datetime import datetime
from typing import Optional
from enum import Enum
import structlog

from .operation_tracker import OperationTracker
from .snapshot_manager import SnapshotManager
from .models import Operation, OperationType, Snapshot, SnapshotType

logger = structlog.get_logger(__name__)

class RollbackType(str, Enum):
    OPERATION = "operation"
    SNAPSHOT = "snapshot"
    TIMEPOINT = "timepoint"

class RollbackEngine:
    """Canvas状态回滚引擎

    [Source: docs/architecture/rollback-recovery-architecture.md:380-480]
    """

    def __init__(self,
                 tracker: OperationTracker,
                 snapshot_manager: SnapshotManager,
                 create_backup: bool = True):
        self.tracker = tracker
        self.snapshot_manager = snapshot_manager
        self.create_backup = create_backup

    async def rollback(self,
                       canvas_path: str,
                       rollback_type: RollbackType,
                       target_id: Optional[str] = None,
                       target_timestamp: Optional[datetime] = None,
                       preserve_graph: bool = False) -> dict:
        """执行回滚操作

        Args:
            canvas_path: Canvas文件路径
            rollback_type: 回滚类型
            target_id: 目标操作ID或快照ID
            target_timestamp: 目标时间点
            preserve_graph: 是否保留图谱状态

        Returns:
            RollbackResult字典
        """
        backup_snapshot_id = None

        # 创建备份快照
        if self.create_backup:
            backup = await self.snapshot_manager.create_snapshot(
                canvas_path,
                SnapshotType.CHECKPOINT,
                description="Pre-rollback backup"
            )
            backup_snapshot_id = backup.id

        try:
            if rollback_type == RollbackType.OPERATION:
                result = await self._rollback_operation(canvas_path, target_id)
            elif rollback_type == RollbackType.SNAPSHOT:
                result = await self._rollback_to_snapshot(canvas_path, target_id)
            elif rollback_type == RollbackType.TIMEPOINT:
                result = await self._rollback_to_timepoint(canvas_path, target_timestamp)
            else:
                raise ValueError(f"Unknown rollback type: {rollback_type}")

            return {
                "success": True,
                "canvas_path": canvas_path,
                "rollback_type": rollback_type.value,
                "backup_snapshot_id": backup_snapshot_id,
                "restored_from": target_id or str(target_timestamp),
                "message": "Rollback successful",
                "graph_sync_status": "skipped" if preserve_graph else "pending"
            }

        except Exception as e:
            logger.error("rollback.failed", error=str(e), canvas_path=canvas_path)

            # 从备份恢复
            if backup_snapshot_id:
                await self._restore_from_backup(canvas_path, backup_snapshot_id)

            return {
                "success": False,
                "canvas_path": canvas_path,
                "rollback_type": rollback_type.value,
                "backup_snapshot_id": backup_snapshot_id,
                "message": f"Rollback failed: {str(e)}. Restored from backup."
            }

    async def _rollback_operation(self, canvas_path: str, operation_id: str):
        """回滚单个操作 (应用反向操作)"""
        operation = self.tracker.get_operation(operation_id)
        if not operation:
            raise ValueError(f"Operation not found: {operation_id}")

        await self._apply_reverse_operation(canvas_path, operation)

    def _get_reverse_operation(self, operation: Operation) -> dict:
        """获取操作的反向操作"""
        reverse_map = {
            OperationType.NODE_ADD: self._reverse_node_add,
            OperationType.NODE_DELETE: self._reverse_node_delete,
            OperationType.NODE_MODIFY: self._reverse_node_modify,
            OperationType.NODE_COLOR_CHANGE: self._reverse_node_color_change,
            OperationType.EDGE_ADD: self._reverse_edge_add,
            OperationType.EDGE_DELETE: self._reverse_edge_delete,
            OperationType.BATCH_OPERATION: self._reverse_batch_operation,
        }
        return reverse_map[operation.type](operation)
```

### 文件路径参考

**需要新增的文件**:
- 新增: `src/rollback/rollback_engine.py` - RollbackEngine类
- 新增: `src/tests/unit/test_rollback_engine.py` - 单元测试

**需要修改的文件**:
- 修改: `src/rollback/models.py` - 添加RollbackType, RollbackRequest等
- 修改: `backend/app/api/v1/endpoints/rollback.py` - 添加回滚端点
- 修改: `backend/app/models/rollback.py` - 添加Pydantic schemas

### 依赖关系

**前置Story**:
- Story 18.1: Operation Tracker（提供操作历史）
- Story 18.2: Snapshot Manager（提供快照功能）

**后续影响**:
- Story 18.4: Graph Sync Service（集成图谱同步）
- Story 18.5: API和配置（完成API集成）

**可并行开发**:
- 本Story可与Story 18.4并行开发（两者独立）

### Definition of Done

- [ ] 所有AC通过验收测试
- [ ] `RollbackEngine` 支持3种回滚类型
- [ ] 7种操作类型都有正确的反向操作
- [ ] 回滚前备份功能正常
- [ ] 回滚失败自动恢复功能正常
- [ ] REST API端点可用
- [ ] 单元测试覆盖率≥90%
- [ ] 代码Review通过
- [ ] 所有代码有文档来源标注

### 风险和缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|---------|
| 反向操作逻辑错误 | 中 | 高 | 完整测试所有操作类型 |
| 大Canvas回滚性能 | 中 | 中 | 分块写入 |
| 并发回滚冲突 | 低 | 高 | 文件锁 + 操作队列 |
| 备份恢复失败 | 低 | 高 | 多层备份机制 |

### 估算

- **Story Points**: 8
- **预估工时**: 3天
- **复杂度**: 高（涉及复杂的回滚逻辑和错误恢复）

---

**文档版本**: v1.0.0
**创建时间**: 2025-12-04
**创建者**: SM Agent (Bob)
**Epic**: Epic 18 - 数据迁移和回滚
