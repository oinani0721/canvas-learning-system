# Story 30.6: Node Color Change Memory Trigger
# ËäÇÁÇπÈ¢úËâ≤ÂèòÂåñÁõëÂê¨‰∏éËÆ∞ÂøÜËß¶Âèë

**Epic**: [EPIC-30: Memory System Complete Activation](../epics/EPIC-30-MEMORY-SYSTEM-COMPLETE-ACTIVATION.md)
**Story ID**: 30.6
**Priority**: P1
**Status**: Complete
**Created**: 2026-01-16

---

## Story

**As a** Canvas Learning System user,
**I want** automatic memory event triggers when Canvas node colors change,
**so that** my learning progress (red‚Üíyellow‚Üígreen transitions) is persistently recorded to Neo4j, enabling accurate tracking of concept mastery evolution and intelligent review scheduling.

---

## Acceptance Criteria

- **AC-30.6.1**: ÁõëÂê¨`.canvas`Êñá‰ª∂ÂèòÂåñÔºåÊ£ÄÊµãËäÇÁÇπÈ¢úËâ≤Â±ûÊÄßÂèòÊõ¥
- **AC-30.6.2**: È¢úËâ≤Êò†Â∞ÑËßÑÂàôÔºö
  - `"1"` (Á∫¢Ëâ≤) ‚Üí `not_understood` (Êú™ÊéåÊè°)
  - `"6"` (ÈªÑËâ≤) ‚Üí `learning` (Â≠¶‰π†‰∏≠)
  - `"2"` (ÁªøËâ≤) ‚Üí `mastered` (Â∑≤ÊéåÊè°)
  - `"3"` (Á¥´Ëâ≤) ‚Üí `pending_verification` (ÂæÖÈ™åËØÅ)
- **AC-30.6.3**: È¢úËâ≤ÂèòÂåñÊó∂POSTÂà∞`/api/v1/memory/episodes`ËÆ∞ÂΩïÂ≠¶‰π†‰∫ã‰ª∂
- **AC-30.6.4**: 500msÈò≤ÊäñÊú∫Âà∂ÈÅøÂÖç‰∫ã‰ª∂È£éÊö¥ (file watcherËß¶ÂèëÈ¢ëÁπÅ)
- **AC-30.6.5**: ÊâπÈáèÂèòÂåñÊó∂ÂêàÂπ∂‰∏∫ÂçïÊ¨°APIË∞ÉÁî® (Â§öËäÇÁÇπÂêåÊó∂ÂèòËâ≤)

---

## Tasks / Subtasks

- [x] **Task 1: Create NodeColorChangeWatcher Service** (AC-30.6.1)
  - [x] 1.1 Create `canvas-progress-tracker/obsidian-plugin/src/services/NodeColorChangeWatcher.ts`
  - [x] 1.2 Define `NodeColorChangeWatcherSettings` interface (enabled, debounceMs, apiBaseUrl)
  - [x] 1.3 Implement `App.vault.on('modify')` event listener for `.canvas` files
  - [x] 1.4 Create `extractColorChanges()` method to compare old/new canvas data
  - [x] 1.5 Maintain `previousCanvasState: Map<string, CanvasData>` for diff detection

- [x] **Task 2: Implement Color Mapping Logic** (AC-30.6.2)
  - [x] 2.1 Create `ColorMasteryLevel` enum: `NOT_UNDERSTOOD`, `LEARNING`, `MASTERED`, `PENDING_VERIFICATION`
  - [x] 2.2 Create `mapCanvasColorToMasteryLevel(color: string): ColorMasteryLevel` function
  - [x] 2.3 Create `ColorChangeEvent` interface: `{ nodeId, canvasPath, oldColor, newColor, oldLevel, newLevel, timestamp }`
  - [x] 2.4 Validate color string is in valid range ("1"-"6") per canvas-node.schema.json

- [x] **Task 3: Implement Debounce Mechanism** (AC-30.6.4)
  - [x] 3.1 Use `debounce()` utility with 500ms delay
  - [x] 3.2 Accumulate color changes during debounce window
  - [x] 3.3 Flush accumulated changes after debounce timeout
  - [x] 3.4 Handle rapid file saves (Obsidian auto-save triggers multiple events)

- [x] **Task 4: Implement Batch API Call** (AC-30.6.3, AC-30.6.5)
  - [x] 4.1 Create `ColorChangeEventBatch` interface for batched events
  - [x] 4.2 Implement `flushColorChanges()` method with batch POST to `/api/v1/memory/episodes`
  - [x] 4.3 Use `requestUrl` from Obsidian API (per BehaviorMonitorService.ts pattern)
  - [x] 4.4 Implement fire-and-forget pattern with 500ms timeout (per ADR-0004)
  - [x] 4.5 Silent degradation on API failure (log error, don't block UI)

- [x] **Task 5: Integrate with main.ts Plugin Lifecycle** (AC-30.6.1)
  - [x] 5.1 Add `private nodeColorWatcher: NodeColorChangeWatcher | null = null;` to plugin class
  - [x] 5.2 Initialize watcher in `initializeManagers()` method
  - [x] 5.3 Start watcher after plugin settings loaded
  - [x] 5.4 Stop watcher in `onunload()` lifecycle method
  - [ ] 5.5 Add settings UI toggle in PluginSettingsTab (optional) - deferred

- [x] **Task 6: Unit Tests**
  - [x] 6.1 Test color mapping for all 4 mastery levels
  - [x] 6.2 Test color change detection (diff algorithm)
  - [x] 6.3 Test debounce accumulation
  - [x] 6.4 Test batch merge logic
  - [x] 6.5 Test silent degradation on API failure

- [x] **Task 7: Integration Tests**
  - [x] 7.1 Test end-to-end: canvas file change ‚Üí API call
  - [x] 7.2 Test multiple rapid color changes batch correctly
  - [x] 7.3 Test watcher lifecycle (start/stop)

---

## Dev Notes

### Existing Implementation Reference

**Plugin Main Class** (main.ts):

| Service | Line | Pattern |
|---------|------|---------|
| `BehaviorMonitorService` | N/A | Scheduled monitoring with `requestUrl` API calls |
| `App.vault.on('modify')` | N/A | File watcher pattern from Obsidian API |
| `NodeRequestQueue` | 69-143 | Async queue pattern for sequential processing |

**BehaviorMonitorService Pattern** (src/services/BehaviorMonitorService.ts:410-447):
```typescript
// ‚úÖ Verified from existing codebase: BehaviorMonitorService.ts
private async detectWeaknessClusters(): Promise<{ data: WeaknessCluster[]; error: string | null }> {
    try {
        const response = await requestUrl({
            url: `${this.settings.apiBaseUrl}/memory/behavior/weakness-clusters`,
            method: 'GET',
            headers: { 'Content-Type': 'application/json' },
        });
        // ... process response
    } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        this.log('Error:', errorMsg);
        return { data: [], error: errorMsg };
    }
}
```

### Proposed Implementation Pattern

**NodeColorChangeWatcher.ts Structure**:
```typescript
// canvas-progress-tracker/obsidian-plugin/src/services/NodeColorChangeWatcher.ts

import { App, TFile, requestUrl } from 'obsidian';

/**
 * Color mastery level enum
 * [Source: tech-stack.md#È¢úËâ≤Á≥ªÁªü]
 */
export enum ColorMasteryLevel {
    NOT_UNDERSTOOD = 'not_understood',      // color "1" (red)
    LEARNING = 'learning',                   // color "6" (yellow)
    MASTERED = 'mastered',                   // color "2" (green)
    PENDING_VERIFICATION = 'pending_verification', // color "3" (purple)
}

/**
 * Color change event
 * [Source: specs/data/temporal-event.schema.json]
 */
export interface ColorChangeEvent {
    nodeId: string;
    canvasPath: string;
    oldColor: string | null;
    newColor: string;
    oldLevel: ColorMasteryLevel | null;
    newLevel: ColorMasteryLevel;
    timestamp: Date;
}

/**
 * Service settings
 */
export interface NodeColorChangeWatcherSettings {
    enabled: boolean;
    debounceMs: number;      // default: 500
    apiBaseUrl: string;      // default: 'http://localhost:8000/api/v1'
    timeout: number;         // default: 500 (per ADR-0004)
    enableLogging: boolean;
}

export const DEFAULT_NODE_COLOR_WATCHER_SETTINGS: NodeColorChangeWatcherSettings = {
    enabled: true,
    debounceMs: 500,
    apiBaseUrl: 'http://localhost:8000/api/v1',
    timeout: 500,
    enableLogging: false,
};

export class NodeColorChangeWatcher {
    private app: App;
    private settings: NodeColorChangeWatcherSettings;
    private previousCanvasState: Map<string, Map<string, string>> = new Map(); // canvasPath -> nodeId -> color
    private pendingChanges: ColorChangeEvent[] = [];
    private debounceTimeout: ReturnType<typeof setTimeout> | null = null;
    private eventRef: any = null; // Obsidian event reference for cleanup

    constructor(app: App, settings?: Partial<NodeColorChangeWatcherSettings>) {
        this.app = app;
        this.settings = { ...DEFAULT_NODE_COLOR_WATCHER_SETTINGS, ...settings };
    }

    /**
     * Start watching canvas files for color changes
     * [Source: Context7:/obsidianmd/obsidian-api - Vault.on('modify')]
     */
    start(): void {
        if (!this.settings.enabled) return;

        this.eventRef = this.app.vault.on('modify', async (file: TFile) => {
            if (file.extension === 'canvas') {
                await this.handleCanvasModify(file);
            }
        });

        this.log('Started watching canvas color changes');
    }

    /**
     * Stop watching
     */
    stop(): void {
        if (this.eventRef) {
            this.app.vault.offref(this.eventRef);
            this.eventRef = null;
        }
        if (this.debounceTimeout) {
            clearTimeout(this.debounceTimeout);
            this.flushChanges(); // Flush any pending changes
        }
        this.log('Stopped watching canvas color changes');
    }

    /**
     * Handle canvas file modification
     */
    private async handleCanvasModify(file: TFile): Promise<void> {
        try {
            const content = await this.app.vault.read(file);
            const canvasData = JSON.parse(content);
            const changes = this.detectColorChanges(file.path, canvasData);

            if (changes.length > 0) {
                this.accumulateChanges(changes);
            }
        } catch (error) {
            this.log('Error processing canvas:', error);
        }
    }

    /**
     * Detect color changes by comparing with previous state
     * [Source: specs/data/canvas-node.schema.json#/properties/color]
     */
    private detectColorChanges(canvasPath: string, canvasData: any): ColorChangeEvent[] {
        const changes: ColorChangeEvent[] = [];
        const now = new Date();

        // Get previous state for this canvas
        const prevState = this.previousCanvasState.get(canvasPath) || new Map();
        const newState = new Map<string, string>();

        // Build new state and detect changes
        for (const node of canvasData.nodes || []) {
            const nodeId = node.id;
            const newColor = node.color || null;

            if (newColor) {
                newState.set(nodeId, newColor);
                const oldColor = prevState.get(nodeId) || null;

                if (oldColor !== newColor) {
                    changes.push({
                        nodeId,
                        canvasPath,
                        oldColor,
                        newColor,
                        oldLevel: oldColor ? this.mapColorToLevel(oldColor) : null,
                        newLevel: this.mapColorToLevel(newColor),
                        timestamp: now,
                    });
                }
            }
        }

        // Update state
        this.previousCanvasState.set(canvasPath, newState);

        return changes;
    }

    /**
     * Map canvas color code to mastery level
     * [Source: tech-stack.md#È¢úËâ≤Á≥ªÁªü]
     */
    private mapColorToLevel(color: string): ColorMasteryLevel {
        switch (color) {
            case '1': return ColorMasteryLevel.NOT_UNDERSTOOD;  // red
            case '2': return ColorMasteryLevel.MASTERED;         // green
            case '3': return ColorMasteryLevel.PENDING_VERIFICATION; // purple
            case '6': return ColorMasteryLevel.LEARNING;         // yellow
            default: return ColorMasteryLevel.LEARNING;          // fallback
        }
    }

    /**
     * Accumulate changes with debounce
     * [Source: AC-30.6.4 - 500msÈò≤ÊäñÊú∫Âà∂]
     */
    private accumulateChanges(changes: ColorChangeEvent[]): void {
        this.pendingChanges.push(...changes);

        // Reset debounce timer
        if (this.debounceTimeout) {
            clearTimeout(this.debounceTimeout);
        }

        this.debounceTimeout = setTimeout(() => {
            this.flushChanges();
        }, this.settings.debounceMs);
    }

    /**
     * Flush accumulated changes to API
     * [Source: ADR-0004 - Fire-and-forget pattern with timeout]
     * [Source: AC-30.6.5 - ÊâπÈáèÂêàÂπ∂ÂçïÊ¨°APIË∞ÉÁî®]
     */
    private async flushChanges(): Promise<void> {
        if (this.pendingChanges.length === 0) return;

        const changesToSend = [...this.pendingChanges];
        this.pendingChanges = [];

        try {
            // Fire-and-forget with timeout
            await Promise.race([
                this.postColorChangeEvents(changesToSend),
                new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Timeout')), this.settings.timeout)
                )
            ]);
            this.log(`Flushed ${changesToSend.length} color changes`);
        } catch (error) {
            // Silent degradation - log but don't throw
            this.log('Failed to post color changes:', error);
        }
    }

    /**
     * POST color change events to memory API
     * [Source: specs/data/temporal-event.schema.json]
     */
    private async postColorChangeEvents(events: ColorChangeEvent[]): Promise<void> {
        const payload = {
            events: events.map(e => ({
                event_type: 'color_changed',
                timestamp: e.timestamp.toISOString(),
                canvas_path: e.canvasPath,
                node_id: e.nodeId,
                metadata: {
                    old_color: e.oldColor,
                    new_color: e.newColor,
                    old_level: e.oldLevel,
                    new_level: e.newLevel,
                }
            }))
        };

        await requestUrl({
            url: `${this.settings.apiBaseUrl}/memory/episodes/batch`,
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
        });
    }

    private log(...args: any[]): void {
        if (this.settings.enableLogging) {
            console.log('[NodeColorWatcher]', ...args);
        }
    }
}

export function createNodeColorChangeWatcher(
    app: App,
    settings?: Partial<NodeColorChangeWatcherSettings>
): NodeColorChangeWatcher {
    return new NodeColorChangeWatcher(app, settings);
}
```

### Color System Reference

**Canvas Color Codes** (from canvas-node.schema.json + tech-stack.md):

| Canvas Code | Visual Color | Our Semantic | Mastery Level |
|-------------|--------------|--------------|---------------|
| `"1"` | üî¥ Red | ‰∏çÁêÜËß£/Êú™ÈÄöËøá | `NOT_UNDERSTOOD` |
| `"2"` | üü¢ Green | ÂÆåÂÖ®ÁêÜËß£/Â∑≤ÈÄöËøá | `MASTERED` |
| `"3"` | üü£ Purple | ‰ººÊáÇÈùûÊáÇ/ÂæÖÊ£ÄÈ™å | `PENDING_VERIFICATION` |
| `"6"` | üü° Yellow | ‰∏™‰∫∫ÁêÜËß£ËæìÂá∫Âå∫ | `LEARNING` |

**Important Note**: Colors `"4"` (cyan) and `"5"` (blue) are not used in our learning system.

---

## SDDËßÑËåÉÂèÇËÄÉ (ÂøÖÂ°´)

### APIÁ´ØÁÇπ

**Memory Episodes BatchÁ´ØÁÇπ** (Êú¨StoryË∞ÉÁî®):

| Á´ØÁÇπ | ÊñπÊ≥ï | Áî®ÈÄî | ËßÑËåÉÊù•Ê∫ê |
|------|------|------|----------|
| `/api/v1/memory/episodes/batch` | POST | ÊâπÈáèËÆ∞ÂΩïÂ≠¶‰π†‰∫ã‰ª∂ | Story 30.3 Memory API |

**ËØ∑Ê±ÇSchema** (Âü∫‰∫étemporal-event.schema.json):
```json
{
  "events": [
    {
      "event_type": "color_changed",
      "timestamp": "2026-01-16T12:00:00Z",
      "canvas_path": "Á¶ªÊï£Êï∞Â≠¶/ÂëΩÈ¢òÈÄªËæë.canvas",
      "node_id": "b33c50660173e5d3",
      "metadata": {
        "old_color": "1",
        "new_color": "2",
        "old_level": "not_understood",
        "new_level": "mastered"
      }
    }
  ]
}
```

### Êï∞ÊçÆSchema

**CanvasNode.color** (from canvas-node.schema.json):
- ËßÑËåÉÊù•Ê∫ê: `[Source: specs/data/canvas-node.schema.json#/properties/color]`
- Á±ªÂûã: `string`
- ÂÖÅËÆ∏ÂÄº: `["1", "2", "3", "4", "5", "6"]`
- ÊèèËø∞: CanvasËäÇÁÇπÈ¢úËâ≤‰ª£Á†Å

**TemporalEvent Schema**:
- ËßÑËåÉÊù•Ê∫ê: `[Source: specs/data/temporal-event.schema.json]`
- ÂøÖÂ°´Â≠óÊÆµ: `event_id`, `session_id`, `event_type`, `timestamp`
- ÂèØÈÄâÂ≠óÊÆµ: `canvas_path`, `node_id`, `metadata`

### Obsidian API

**Vault.on('modify')** (from Context7:/obsidianmd/obsidian-api):
- Áî®ÈÄî: ÁõëÂê¨Vault‰∏≠Êñá‰ª∂‰øÆÊîπ‰∫ã‰ª∂
- Á≠æÂêç: `vault.on('modify', callback: (file: TFile) => any)`
- Ê∏ÖÁêÜ: `vault.offref(eventRef)` Âú® `onunload()` ‰∏≠Ë∞ÉÁî®

**requestUrl** (from Context7:/obsidianmd/obsidian-api):
- Áî®ÈÄî: HTTPËØ∑Ê±ÇÂ∑•ÂÖ∑ (Êõø‰ª£fetch)
- Á≠æÂêç: `requestUrl(options: RequestUrlParam): Promise<RequestUrlResponse>`
- ‰ºòÂäø: ÊîØÊåÅCORSÁªïËøá„ÄÅÁªü‰∏ÄÈîôËØØÂ§ÑÁêÜ

---

## ADRÂÜ≥Á≠ñÂÖ≥ËÅî (ÂøÖÂ°´)

| ADRÁºñÂè∑ | ÂÜ≥Á≠ñÊ†áÈ¢ò | ÂØπStoryÁöÑÂΩ±Âìç |
|---------|----------|---------------|
| ADR-0001 | Use Obsidian Canvas | CanvasÊñá‰ª∂Ê†ºÂºè‰∏∫JSONÔºåcolorÂ±ûÊÄß‰∏∫Â≠óÁ¨¶‰∏≤"1"-"6" |
| ADR-0003 | Graphiti Memory Architecture | ËÆ∞ÂøÜÂÜôÂÖ•ÂøÖÈ°ªÈÄöËøáMemory API‚ÜíNeo4j |
| ADR-0004 | Async Execution Engine | ‰ΩøÁî®fire-and-forgetÊ®°ÂºèÔºå500msË∂ÖÊó∂ÔºåÈùôÈªòÈôçÁ∫ß |

### ÂÖ≥ÈîÆÁ∫¶Êùü (‰ªéADR ConsequencesÊèêÂèñ):

**‰ªé ADR-0001** (Obsidian Canvas):
- CanvasÊñá‰ª∂ÊòØÁ∫ØJSONÊ†ºÂºè (`.canvas`Êâ©Â±ïÂêç)
- È¢úËâ≤ÂÄºÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤ `"1"`-`"6"`Ôºå‰∏çËÉΩÊòØÊï∞Â≠ó
- Áî®Êà∑ÂèØ‰ª•Áõ¥Êé•Âú®Obsidian‰∏≠ÁºñËæëCanvas

**‰ªé ADR-0003** (Graphiti Memory):
- ÊâÄÊúâËÆ∞ÂøÜÂÜôÂÖ•ÂøÖÈ°ªÊòØÂºÇÊ≠•ÁöÑ (`async/await`)
- Neo4jËøûÊé•Â§±Ë¥•Êó∂ÂøÖÈ°ª‰ºòÈõÖÈôçÁ∫ß
- ÁºìÂ≠òÂ§±ÊïàÁ≠ñÁï•: write-through

**‰ªé ADR-0004** (Async Execution):
- Ê®°Âºè: Fire-and-forget (`Promise.race` with timeout)
- Âçï‰∏™‰ªªÂä°Ë∂ÖÊó∂‰∏çÂ∫îÂΩ±ÂìçÊï¥‰ΩìÊâßË°å
- Ë∂ÖÊó∂‰øùÊä§: 500ms
- Â§±Ë¥•Êó∂ÈùôÈªòÈôçÁ∫ßÔºåËÆ∞ÂΩïÈîôËØØÊó•Âøó

Êù•Ê∫êÂºïÁî®: `[Source: ADR-0001]`, `[Source: ADR-0003]`, `[Source: ADR-0004]`

---

## Dependencies

### ÂâçÁΩÆStory

| Story | Ê†áÈ¢ò | Áä∂ÊÄÅ | ‰æùËµñÁ±ªÂûã |
|-------|------|------|----------|
| 30.1 | Neo4j DockerÁéØÂ¢ÉÈÉ®ÁΩ≤ | Draft | P0 BLOCKER |
| 30.2 | Neo4jClientÁúüÂÆûÈ©±Âä®ÂÆûÁé∞ | Draft | P0 BLOCKER |
| 30.3 | Memory APIÁ´ØÁÇπÈõÜÊàêÈ™åËØÅ | Draft | P1 (ÈúÄË¶Å /memory/episodes/batch Á´ØÁÇπ) |
| 30.7 | ObsidianÊèí‰ª∂ËÆ∞ÂøÜÊúçÂä°ÂàùÂßãÂåñ | Draft | P0 BLOCKER (Êèí‰ª∂ÂàùÂßãÂåñÊû∂ÊûÑ) |

**Note**: Story 30.6ÂèØ‰∏é30.7Âπ∂Ë°åÂºÄÂèëÔºå‰ΩÜ30.7ÈúÄË¶ÅÂÖàÂÆåÊàêÊèí‰ª∂ËÆ∞ÂøÜÊúçÂä°ÂàùÂßãÂåñÊû∂ÊûÑ„ÄÇ

### ÊäÄÊúØ‰æùËµñ

- Obsidian API (`App`, `TFile`, `Vault.on`, `requestUrl`)
- TypeScript 5.x
- JSON Canvas Spec 1.0

---

## Testing

### Test File Locations
- Unit tests: `canvas-progress-tracker/obsidian-plugin/tests/services/NodeColorChangeWatcher.test.ts` (Êñ∞Âª∫)
- Integration tests: `canvas-progress-tracker/obsidian-plugin/tests/integration/color-change-memory.test.ts` (Êñ∞Âª∫)

### Testing Standards
- Framework: Jest (Obsidian plugin testing)
- Mock: Mock Obsidian `App`, `Vault` APIs
- Pattern: ÂèÇËÄÉ BehaviorMonitorService ÊµãËØïÊ®°Âºè

### Testing Patterns

```typescript
describe('NodeColorChangeWatcher', () => {
    let mockApp: MockApp;
    let watcher: NodeColorChangeWatcher;

    beforeEach(() => {
        mockApp = createMockApp();
        watcher = new NodeColorChangeWatcher(mockApp as App, {
            enabled: true,
            debounceMs: 100, // Short for testing
            enableLogging: true,
        });
    });

    afterEach(() => {
        watcher.stop();
    });

    describe('mapColorToLevel', () => {
        it('should map red (1) to NOT_UNDERSTOOD', () => {
            expect(watcher['mapColorToLevel']('1')).toBe(ColorMasteryLevel.NOT_UNDERSTOOD);
        });

        it('should map green (2) to MASTERED', () => {
            expect(watcher['mapColorToLevel']('2')).toBe(ColorMasteryLevel.MASTERED);
        });

        it('should map purple (3) to PENDING_VERIFICATION', () => {
            expect(watcher['mapColorToLevel']('3')).toBe(ColorMasteryLevel.PENDING_VERIFICATION);
        });

        it('should map yellow (6) to LEARNING', () => {
            expect(watcher['mapColorToLevel']('6')).toBe(ColorMasteryLevel.LEARNING);
        });
    });

    describe('detectColorChanges', () => {
        it('should detect new node with color', () => {
            const changes = watcher['detectColorChanges']('test.canvas', {
                nodes: [{ id: 'node1', color: '1' }]
            });
            expect(changes).toHaveLength(1);
            expect(changes[0].newColor).toBe('1');
            expect(changes[0].oldColor).toBeNull();
        });

        it('should detect color change from red to green', () => {
            // First call: set initial state
            watcher['detectColorChanges']('test.canvas', {
                nodes: [{ id: 'node1', color: '1' }]
            });
            // Second call: change color
            const changes = watcher['detectColorChanges']('test.canvas', {
                nodes: [{ id: 'node1', color: '2' }]
            });
            expect(changes).toHaveLength(1);
            expect(changes[0].oldColor).toBe('1');
            expect(changes[0].newColor).toBe('2');
        });
    });

    describe('debounce', () => {
        it('should batch multiple rapid changes', async () => {
            const postSpy = jest.spyOn(watcher as any, 'postColorChangeEvents').mockResolvedValue(undefined);

            // Simulate rapid file changes
            await watcher['handleCanvasModify']({ path: 'test.canvas', extension: 'canvas' } as TFile);
            await watcher['handleCanvasModify']({ path: 'test.canvas', extension: 'canvas' } as TFile);

            // Wait for debounce
            await new Promise(r => setTimeout(r, 150));

            // Should be called once with batched changes
            expect(postSpy).toHaveBeenCalledTimes(1);
        });
    });
});
```

### Key Test Cases
1. Color mapping for all 4 mastery levels (red, green, purple, yellow)
2. Color change detection (new node, color change, no change)
3. Debounce accumulation (multiple rapid changes batched)
4. Batch merge logic (multiple nodes, same canvas)
5. Silent degradation on API failure (no exception thrown)
6. Watcher lifecycle (start/stop properly cleanup)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-16 | 0.1 | Initial draft created by SM Agent with UltraThink | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
- Test run output: All 49 tests pass (36 unit tests, 13 integration tests)
- Fixed async callback issue in test mocks (`_triggerModify` made async with `Promise.all`)
- Fixed test state seeding (initial state must be captured before detecting changes)

### Completion Notes List
1. **NodeColorChangeWatcher.ts** (~496 lines) - Complete service implementation with:
   - `ColorMasteryLevel` enum for mastery level mapping
   - `ColorChangeEvent` and `ColorChangeEventBatch` interfaces
   - `NodeColorChangeWatcherSettings` with sensible defaults
   - Canvas file modification watcher using Obsidian Vault API
   - Color change detection with previous state tracking
   - 500ms debounce mechanism (AC-30.6.4)
   - Batch API calls to `/memory/episodes/batch` (AC-30.6.5)
   - Fire-and-forget pattern with 500ms timeout (ADR-0004)
   - Silent degradation on API failure
   - Factory function `createNodeColorChangeWatcher()`

2. **main.ts integration** - Added:
   - Import statement for NodeColorChangeWatcher
   - Private member declaration
   - Initialization in `initializeManagers()` inside `neo4jEnabled` block
   - Cleanup in `cleanupManagers()`

3. **Unit tests** (NodeColorChangeWatcher.test.ts, ~760 lines) - 36 tests covering:
   - Color mapping for all 4 mastery levels
   - Color change detection (diff algorithm)
   - Debounce accumulation
   - Batch merge logic
   - Silent degradation on API failure
   - Watcher lifecycle (start/stop)
   - Constructor and settings
   - API payload format
   - Edge cases

4. **Integration tests** (color-change-memory.test.ts, ~640 lines) - 13 tests covering:
   - End-to-end flow: canvas file change ‚Üí API call
   - Learning progression tracking (red‚Üíyellow‚Üígreen)
   - Rapid changes batching (Obsidian auto-save)
   - Multi-node and multi-canvas batching
   - Watcher lifecycle (start/stop/enable/disable)
   - Error recovery

### File List
**Files created:**
- `canvas-progress-tracker/obsidian-plugin/src/services/NodeColorChangeWatcher.ts` (Êñ∞Âª∫ ~496Ë°å)
- `canvas-progress-tracker/obsidian-plugin/tests/services/NodeColorChangeWatcher.test.ts` (Êñ∞Âª∫ ~760Ë°å)
- `canvas-progress-tracker/obsidian-plugin/tests/integration/color-change-memory.test.ts` (Êñ∞Âª∫ ~640Ë°å)

**Files modified:**
- `canvas-progress-tracker/obsidian-plugin/main.ts` (‰øÆÊîπ ~20Ë°å, Ê∑ªÂä†watcherÂàùÂßãÂåñÂíåÊ∏ÖÁêÜ)

---

## QA Results

### Review Date: 2026-01-17

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Rating: EXCELLENT** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

The implementation demonstrates exemplary code quality with comprehensive test coverage, proper adherence to ADR patterns, and clean TypeScript architecture. The NodeColorChangeWatcher service follows established patterns from the codebase (BehaviorMonitorService) and correctly implements all acceptance criteria.

**Strengths:**
- Clean separation of concerns with public/private method boundaries
- Comprehensive JSDoc documentation with `[Source: ...]` references to ADRs and specs
- Factory function pattern for testability
- Observer pattern implementation using Obsidian Vault API
- Proper debounce and batch patterns matching ADR-0004

### Requirements Traceability (Given-When-Then)

| AC | Requirement | Implementation | Test Coverage | Status |
|----|-------------|----------------|---------------|--------|
| AC-30.6.1 | Monitor .canvas file changes | `NodeColorChangeWatcher.ts:196-200` - Vault.on('modify') | Unit: 9 tests, Integration: 2 tests | ‚úÖ |
| AC-30.6.2 | Color mapping rules | `NodeColorChangeWatcher.ts:347-365` - mapColorToLevel() | Unit: 6 tests (all 4 levels + unknown) | ‚úÖ |
| AC-30.6.3 | POST to /api/v1/memory/episodes/batch | `NodeColorChangeWatcher.ts:440-463` | Unit: API payload test, Integration: E2E | ‚úÖ |
| AC-30.6.4 | 500ms debounce mechanism | `NodeColorChangeWatcher.ts:384-396` + default setting | Unit: 2 debounce tests | ‚úÖ |
| AC-30.6.5 | Batch multiple changes | `NodeColorChangeWatcher.ts:404-428` | Unit: 2 tests, Integration: 3 tests | ‚úÖ |

**Test Evidence:**
- 49 tests total (36 unit + 13 integration)
- All ACs have corresponding tests with Given-When-Then patterns
- Backend batch endpoint verified: `memory.py:355-404`
- Schema compliance verified: `batch-episodes-request.schema.json`

### Refactoring Performed

No refactoring required - implementation quality is production-ready.

### Compliance Check

- Coding Standards: ‚úÖ Clean TypeScript, proper exports, JSDoc comments
- Project Structure: ‚úÖ Service in `src/services/`, tests in `tests/services/` and `tests/integration/`
- Testing Strategy: ‚úÖ Unit + Integration test pattern, Jest framework, proper mocking
- All ACs Met: ‚úÖ 5/5 acceptance criteria fully implemented and tested

### Improvements Checklist

- [x] Fire-and-forget pattern with 500ms timeout (ADR-0004 compliant)
- [x] Silent degradation on API failure
- [x] Proper Vault event listener cleanup
- [x] Debounce accumulation with timer reset
- [x] Batch merge for multiple canvases
- [x] Factory function for testability
- [ ] Consider adding maxItems: 50 validation (schema limit) - MINOR, backend handles this

### Security Review

**Status: PASS**
- No sensitive data exposure
- Local API only (localhost:8000)
- No authentication tokens in payload
- No user credentials handled

### Performance Considerations

**Status: PASS**
- 500ms debounce prevents event storms from Obsidian auto-save
- 500ms timeout prevents blocking UI (ADR-0004)
- Batch API reduces network calls (AC-30.6.5)
- Fire-and-forget pattern maintains UI responsiveness

### NFR Validation

| NFR | Status | Notes |
|-----|--------|-------|
| Security | ‚úÖ PASS | No sensitive data, local API only |
| Performance | ‚úÖ PASS | Debounce + batch + fire-and-forget |
| Reliability | ‚úÖ PASS | Silent degradation, proper cleanup |
| Maintainability | ‚úÖ PASS | Clean code, comprehensive docs |

### ADR Compliance

| ADR | Decision | Implementation | Status |
|-----|----------|----------------|--------|
| ADR-0001 | Obsidian Canvas | Color values as strings "1"-"6" | ‚úÖ |
| ADR-0003 | Graphiti Memory | Async writes, graceful degradation | ‚úÖ |
| ADR-0004 | Async Execution | Fire-and-forget, 500ms timeout, silent fail | ‚úÖ |

### Files Modified During Review

No files modified - implementation meets quality standards.

### Gate Status

**Gate: PASS** ‚Üí `docs/qa/gates/30.6-node-color-change-memory-trigger.yml`

| Metric | Value |
|--------|-------|
| Quality Score | 100/100 |
| Tests Reviewed | 49 |
| Risks Identified | 0 |
| AC Coverage | 5/5 (100%) |

### Recommended Status

**‚úÖ Ready for Done** - All acceptance criteria met, comprehensive test coverage, ADR compliant, no blocking issues.
