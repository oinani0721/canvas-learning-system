# Story 22.4: 学习历史存储与查询API

## Status
⏳ Ready for Development

## Story

**As a** 前端应用,
**I want** 能够通过API存储和查询学习历史,
**so that** 展示学习进度和推荐复习内容。

## Acceptance Criteria

1. AC-22.4.1: POST /api/v1/memory/episodes 存储学习事件
2. AC-22.4.2: GET /api/v1/memory/episodes 查询学习历史
3. AC-22.4.3: GET /api/v1/memory/concepts/{id}/history 查询概念学习历史
4. AC-22.4.4: GET /api/v1/memory/review-suggestions 获取复习建议
5. AC-22.4.5: 支持分页和过滤参数
6. AC-22.4.6: 单元测试和集成测试覆盖API

## Tasks / Subtasks

- [ ] Task 1: 创建MemoryService (AC: 1-4)
  - [ ] 定义MemoryService类
  - [ ] 注入Neo4jClient和TemporalClient
  - [ ] 实现record_learning_event方法
  - [ ] 实现get_learning_history方法
  - [ ] 实现get_review_suggestions方法

- [ ] Task 2: 创建Pydantic模型 (AC: 1-5)
  - [ ] 定义LearningEpisodeCreate请求模型
  - [ ] 定义LearningEpisodeResponse响应模型
  - [ ] 定义ReviewSuggestion模型
  - [ ] 定义分页参数模型

- [ ] Task 3: 实现POST /episodes端点 (AC: 1)
  - [ ] 创建memory.py路由文件
  - [ ] 实现存储学习事件接口
  - [ ] 添加请求验证
  - [ ] 返回episode_id

- [ ] Task 4: 实现GET /episodes端点 (AC: 2, 5)
  - [ ] 支持start_date和end_date过滤
  - [ ] 支持concept过滤
  - [ ] 支持分页 (page, page_size)
  - [ ] 返回分页响应

- [ ] Task 5: 实现GET /concepts/{id}/history端点 (AC: 3)
  - [ ] 按概念ID查询学习历史
  - [ ] 返回时间线数据
  - [ ] 包含得分变化

- [ ] Task 6: 实现GET /review-suggestions端点 (AC: 4)
  - [ ] 基于艾宾浩斯遗忘曲线
  - [ ] 返回需要复习的概念
  - [ ] 包含优先级排序

- [ ] Task 7: 编写测试 (AC: 6)
  - [ ] 单元测试MemoryService
  - [ ] 集成测试API端点
  - [ ] 测试分页功能

## Dev Notes

### 架构上下文

**问题根因** [Source: docs/prd/EPIC-22-MEMORY-SYSTEM-NEO4J-GRAPHITI.md#问题分析]

学习历史API不存在，前端无法获取学习进度:

```
期望API:
- POST /api/v1/memory/episodes - 记录学习事件
- GET /api/v1/memory/episodes - 查询学习历史
- GET /api/v1/memory/review-suggestions - 复习建议

实际状态: 这些端点都不存在
```

### 实现参考

**MemoryService实现** [Source: docs/prd/EPIC-22-MEMORY-SYSTEM-NEO4J-GRAPHITI.md#Story-22.4]

```python
# backend/app/services/memory_service.py

from typing import List, Dict, Optional
from datetime import datetime
from backend.app.clients.neo4j_client import Neo4jClient
from src.agentic_rag.clients.temporal_client import TemporalClient
import logging

logger = logging.getLogger(__name__)

class MemoryService:
    """学习记忆服务"""

    def __init__(
        self,
        neo4j_client: Neo4jClient,
        temporal_client: TemporalClient
    ):
        self.neo4j = neo4j_client
        self.temporal = temporal_client

    async def record_learning_event(
        self,
        user_id: str,
        canvas_path: str,
        node_id: str,
        concept: str,
        agent_type: str,
        score: Optional[int] = None,
        duration_seconds: Optional[int] = None
    ) -> str:
        """
        记录学习事件

        同时存储到Neo4j知识图谱和Graphiti时序数据库
        """
        # 存储到Neo4j - 创建学习关系
        await self._create_neo4j_learning_relationship(
            user_id, concept, score
        )

        # 存储到Graphiti - 添加Episode
        content = f"User {user_id} learned '{concept}' using {agent_type}"
        if score:
            content += f" with score {score}"

        episode_id = await self.temporal.add_learning_episode(
            content=content,
            episode_type="learning",
            metadata={
                "user_id": user_id,
                "canvas_path": canvas_path,
                "node_id": node_id,
                "concept": concept,
                "agent_type": agent_type,
                "score": score,
                "duration_seconds": duration_seconds
            }
        )

        logger.info(f"Recorded learning event: {episode_id}")
        return episode_id

    async def get_learning_history(
        self,
        user_id: str,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        concept: Optional[str] = None,
        page: int = 1,
        page_size: int = 50
    ) -> Dict:
        """获取学习历史 (分页)"""
        # 从Graphiti查询时序数据
        if start_date and end_date:
            episodes = await self.temporal.search_by_time_range(
                start_time=start_date,
                end_time=end_date,
                limit=page_size * page  # 获取足够的数据用于分页
            )
        else:
            episodes = []  # 默认查询实现

        # 应用concept过滤
        if concept:
            episodes = [e for e in episodes if concept.lower() in str(e).lower()]

        # 分页
        start_idx = (page - 1) * page_size
        end_idx = start_idx + page_size
        paginated = episodes[start_idx:end_idx]

        return {
            "items": paginated,
            "total": len(episodes),
            "page": page,
            "page_size": page_size,
            "pages": (len(episodes) + page_size - 1) // page_size
        }

    async def get_review_suggestions(
        self,
        user_id: str,
        limit: int = 10
    ) -> List[Dict]:
        """
        获取复习建议 (基于艾宾浩斯遗忘曲线)

        查询Neo4j中next_review时间已过的概念
        """
        query = """
        MATCH (u:User {id: $userId})-[r:LEARNED]->(c:Concept)
        WHERE r.next_review < datetime()
        RETURN c.name as concept,
               c.id as concept_id,
               r.last_score as last_score,
               r.review_count as review_count,
               r.next_review as due_date
        ORDER BY r.next_review
        LIMIT $limit
        """
        results = await self.neo4j.run_query(query, userId=user_id, limit=limit)

        # 添加优先级
        suggestions = []
        for r in results:
            priority = "high" if r.get("review_count", 0) < 3 else "medium"
            suggestions.append({
                **r,
                "priority": priority
            })

        return suggestions

    async def _create_neo4j_learning_relationship(
        self,
        user_id: str,
        concept: str,
        score: Optional[int]
    ):
        """在Neo4j中创建学习关系"""
        query = """
        MERGE (u:User {id: $userId})
        MERGE (c:Concept {name: $concept})
        MERGE (u)-[r:LEARNED]->(c)
        SET r.timestamp = datetime(),
            r.score = $score,
            r.next_review = datetime() + duration('P1D')
        RETURN r
        """
        await self.neo4j.run_query(
            query,
            userId=user_id,
            concept=concept,
            score=score
        )
```

**API端点实现**:

```python
# backend/app/api/v1/endpoints/memory.py

from fastapi import APIRouter, Depends, Query
from typing import Optional
from datetime import datetime
from backend.app.services.memory_service import MemoryService
from backend.app.models.memory_schemas import (
    LearningEpisodeCreate,
    LearningEpisodeResponse,
    LearningHistoryResponse,
    ReviewSuggestionResponse
)

memory_router = APIRouter(prefix="/memory", tags=["memory"])

@memory_router.post("/episodes", response_model=LearningEpisodeResponse)
async def create_learning_episode(
    episode: LearningEpisodeCreate,
    memory_service: MemoryService = Depends(get_memory_service)
):
    """记录学习事件"""
    episode_id = await memory_service.record_learning_event(
        user_id=episode.user_id,
        canvas_path=episode.canvas_path,
        node_id=episode.node_id,
        concept=episode.concept,
        agent_type=episode.agent_type,
        score=episode.score,
        duration_seconds=episode.duration_seconds
    )
    return {"episode_id": episode_id, "status": "created"}

@memory_router.get("/episodes", response_model=LearningHistoryResponse)
async def get_learning_history(
    user_id: str,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    concept: Optional[str] = None,
    page: int = Query(1, ge=1),
    page_size: int = Query(50, ge=1, le=100),
    memory_service: MemoryService = Depends(get_memory_service)
):
    """查询学习历史"""
    return await memory_service.get_learning_history(
        user_id=user_id,
        start_date=start_date,
        end_date=end_date,
        concept=concept,
        page=page,
        page_size=page_size
    )

@memory_router.get("/review-suggestions", response_model=list[ReviewSuggestionResponse])
async def get_review_suggestions(
    user_id: str,
    limit: int = Query(10, ge=1, le=50),
    memory_service: MemoryService = Depends(get_memory_service)
):
    """获取复习建议"""
    return await memory_service.get_review_suggestions(
        user_id=user_id,
        limit=limit
    )
```

**Pydantic模型**:

```python
# backend/app/models/memory_schemas.py

from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime

class LearningEpisodeCreate(BaseModel):
    user_id: str = Field(..., description="用户ID")
    canvas_path: str = Field(..., description="Canvas文件路径")
    node_id: str = Field(..., description="Canvas节点ID")
    concept: str = Field(..., description="学习概念")
    agent_type: str = Field(..., description="使用的Agent类型")
    score: Optional[int] = Field(None, ge=0, le=100, description="得分")
    duration_seconds: Optional[int] = Field(None, ge=0, description="学习时长")

class LearningEpisodeResponse(BaseModel):
    episode_id: str
    status: str

class ReviewSuggestionResponse(BaseModel):
    concept: str
    concept_id: str
    last_score: Optional[int]
    review_count: int
    due_date: datetime
    priority: str  # high, medium, low
```

### 关键文件

- `backend/app/services/memory_service.py` - 新增服务
- `backend/app/api/v1/endpoints/memory.py` - 新增API路由
- `backend/app/models/memory_schemas.py` - 新增Pydantic模型
- `backend/app/api/v1/__init__.py` - 注册路由
- `tests/unit/test_memory_service.py` - 新增单元测试
- `tests/integration/test_memory_api.py` - 新增集成测试

### API规范

```yaml
# Memory API

POST /api/v1/memory/episodes:
  description: 记录学习事件
  body:
    user_id: string (required)
    canvas_path: string (required)
    node_id: string (required)
    concept: string (required)
    agent_type: string (required)
    score: int (optional, 0-100)
    duration_seconds: int (optional)
  response:
    episode_id: string
    status: "created"

GET /api/v1/memory/episodes:
  description: 查询学习历史
  params:
    user_id: string (required)
    start_date: datetime (optional)
    end_date: datetime (optional)
    concept: string (optional)
    page: int (default: 1)
    page_size: int (default: 50, max: 100)
  response:
    items: array
    total: int
    page: int
    page_size: int
    pages: int

GET /api/v1/memory/review-suggestions:
  description: 获取复习建议
  params:
    user_id: string (required)
    limit: int (default: 10, max: 50)
  response:
    - concept: string
      concept_id: string
      last_score: int
      review_count: int
      due_date: datetime
      priority: high|medium|low
```

### 测试要求

**单元测试覆盖**:
- 测试record_learning_event
- 测试get_learning_history分页
- 测试get_review_suggestions
- Mock Neo4j和Temporal客户端

**集成测试覆盖**:
- 测试POST /episodes端点
- 测试GET /episodes端点
- 测试GET /review-suggestions端点
- 测试错误处理

## SDD规范引用

- **OpenAPI Spec**: `specs/api/canvas-api.openapi.yml#/paths/~1memory~1episodes`
- **架构文档**: `docs/prd/EPIC-22-MEMORY-SYSTEM-NEO4J-GRAPHITI.md#附录C-API端点规范`

## ADR关联

- ADR-0008: Memory API设计决策 (如存在)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-12 | 1.0 | 初始Story创建 | SM Agent (Bob) |
