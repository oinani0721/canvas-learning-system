# Story 1.2: Canvas节点关系图构建

## Status
Done

## Story

**As a** 系统核心模块,
**I want** 能够构建节点关系图，
**so that** 我可以快速查询节点的父子关系和连接关系，为后续所有Canvas操作提供高效的数据查询基础。

## Acceptance Criteria

1. 能够构建完整的节点关系图
2. 支持查询节点的父节点和子节点
3. 支持查询节点的所有连接边
4. 关系图构建耗时<100ms

## Tasks / Subtasks

- [x] Task 1: 设计并实现节点关系图数据结构 (AC: 1)
  - [x] 设计关系图字典结构，包含node_data、parents、children、incoming_edges、outgoing_edges
  - [x] 在CanvasJSONOperator类中添加build_relationship_graph静态方法
  - [x] 添加完整的类型注解和Google Style Docstring
  - [x] 处理空canvas_data和缺少edges字段的边界情况

- [x] Task 2: 实现父子节点关系构建逻辑 (AC: 1, 2)
  - [x] 遍历edges数组，为每个节点建立parents列表
  - [x] 遍历edges数组，为每个节点建立children列表
  - [x] 处理孤立节点（没有任何连接边的节点）
  - [x] 验证节点ID的有效性（引用的节点必须在nodes数组中存在）

- [x] Task 3: 实现连接边关系构建逻辑 (AC: 1, 3)
  - [x] 为每个节点收集incoming_edges（指向该节点的边）
  - [x] 为每个节点收集outgoing_edges（从该节点发出的边）
  - [x] 存储完整的edge对象，便于后续查询边的属性（label、fromSide等）

- [x] Task 4: 实现关系查询辅助方法 (AC: 2, 3)
  - [x] 实现get_parent_nodes方法：根据节点ID查询父节点列表
  - [x] 实现get_child_nodes方法：根据节点ID查询子节点列表
  - [x] 实现get_connected_edges方法：查询节点的所有连接边
  - [x] 所有查询方法都应返回节点完整数据，而非仅ID

- [x] Task 5: 性能优化和验证 (AC: 4)
  - [x] 使用字典快速查找，确保O(1)时间复杂度的节点查询
  - [x] 测试不同规模Canvas文件的构建时间（10节点、50节点、100节点）
  - [x] 确保100节点的Canvas构建时间<100ms
  - [x] 如有性能问题，分析并优化瓶颈

- [x] Task 6: 单元测试 (ALL AC)
  - [x] 测试基本关系图构建（包含parents、children、edges）
  - [x] 测试父子节点查询功能
  - [x] 测试连接边查询功能
  - [x] 测试边界情况（空Canvas、孤立节点、无效节点引用）
  - [x] 测试性能（构建时间<100ms）
  - [x] 确保测试覆盖率≥90%

## Dev Notes

### Previous Story Insights

从Story 1.1（Canvas JSON文件读取）中学到的经验：

- ✅ **静态方法设计**：Layer 1的所有方法都应该是静态方法，无状态设计，便于调用和测试
- ✅ **优雅降级**：对于缺失的数据字段，应自动补充默认值而非直接报错（如Story 1.1中自动补充空的nodes/edges数组）
- ✅ **类型注解**：完整的类型注解（包括Dict, List, Optional等）极大提升代码可读性
- ✅ **Google Style Docstring**：详细的文档字符串包括Args、Returns、Raises、Example
- ✅ **性能优异**：Story 1.1的实际性能远超要求（<0.1s vs 目标<0.5s），保持这种标准
- ✅ **错误处理**：明确的错误类型和有意义的错误消息

### 架构上下文

**3层架构设计** [Source: architecture/canvas-3-layer-architecture.md#架构概述]

本Story实现Layer 1（CanvasJSONOperator）的节点关系图构建功能。3层架构如下：

```
Layer 3: CanvasOrchestrator (高级接口) ← Sub-agents调用
Layer 2: CanvasBusinessLogic (业务逻辑)
Layer 1: CanvasJSONOperator (底层JSON操作) ← 本Story实现此层
```

**Layer 1职责：**
- Canvas JSON文件的读写
- 节点和边的CRUD操作
- 节点关系图构建（本Story新增）
- 不包含任何业务逻辑
- 纯函数式，无状态（所有方法都是静态方法）

### 数据模型

**节点关系图数据结构** [Source: docs/prd/FULL-PRD-REFERENCE.md#Story 1.2]

目标数据结构：
```python
{
  "node_id_1": {
    "node_data": {...},            # 完整的节点数据
    "parents": ["parent_id1", "parent_id2"],       # 父节点ID列表
    "children": ["child_id1", "child_id2"],        # 子节点ID列表
    "incoming_edges": [edge_obj1, edge_obj2],      # 指向该节点的边对象
    "outgoing_edges": [edge_obj3, edge_obj4]       # 从该节点发出的边对象
  },
  "node_id_2": {
    ...
  }
}
```

**Canvas JSON格式** [Source: architecture/tech-stack.md#文件格式规范]

节点结构：
```json
{
  "id": "string",
  "type": "text" | "file" | "group",
  "text": "string (for type=text)",
  "x": number,
  "y": number,
  "width": number,
  "height": number,
  "color": "1" | "2" | "3" | "4" | "5" | "6"
}
```

边结构：
```json
{
  "id": "string",
  "fromNode": "string",
  "toNode": "string",
  "fromSide": "top" | "right" | "bottom" | "left",
  "toSide": "top" | "right" | "bottom" | "left",
  "label": "string (optional)"
}
```

### 技术栈

**Python环境** [Source: architecture/tech-stack.md#核心技术栈]
- Python 3.9+ （推荐使用3.11以获得更好性能）
- 标准库：typing（Dict, List, Optional, Any）

### 文件位置

**代码文件** [Source: architecture/unified-project-structure.md#关键文件说明]
- 修改文件：`C:/Users/ROG/托福/canvas_utils.py`（项目根目录）
- 在现有的CanvasJSONOperator类中添加新的静态方法

**项目结构**
```
C:/Users/ROG/托福/
├── canvas_utils.py        # ⭐ 本Story修改此文件
│                          #    在CanvasJSONOperator类中添加方法
└── tests/
    └── test_canvas_utils.py  # ⭐ 本Story添加新测试用例
```

### 编码规范

**PEP 8规范** [Source: architecture/coding-standards.md#Python编码规范]
- 使用4个空格缩进
- 每行最多79字符
- 使用UTF-8编码
- 类名：PascalCase（如 CanvasJSONOperator）
- 函数名：snake_case（如 build_relationship_graph）
- 常量：UPPER_SNAKE_CASE

**类型注解（强制）** [Source: architecture/coding-standards.md#类型注解]
```python
from typing import Dict, List, Optional, Any

@staticmethod
def build_relationship_graph(canvas_data: Dict) -> Dict[str, Dict[str, Any]]:
    """构建节点关系图

    Args:
        canvas_data: Canvas JSON数据，包含nodes和edges字段

    Returns:
        Dict[str, Dict[str, Any]]: 节点关系图，键为节点ID，值为关系信息

    Example:
        >>> canvas_data = {
        ...     "nodes": [{"id": "node1", ...}, {"id": "node2", ...}],
        ...     "edges": [{"fromNode": "node1", "toNode": "node2", ...}]
        ... }
        >>> graph = CanvasJSONOperator.build_relationship_graph(canvas_data)
        >>> print(graph["node1"]["children"])  # ['node2']
    """
    pass
```

**文档字符串（Google Style）** [Source: architecture/coding-standards.md#文档字符串]
- 必须包含：简短描述、Args、Returns
- 可选包含：Raises、Example
- 示例应清晰展示用法

**错误处理原则** [Source: architecture/coding-standards.md#错误处理]
- 明确的错误类型（ValueError、KeyError等）
- 有意义的错误消息
- 包含上下文信息

示例：
```python
if "nodes" not in canvas_data:
    raise ValueError("canvas_data必须包含'nodes'字段")

if edge["fromNode"] not in node_ids:
    raise ValueError(
        f"边引用了不存在的节点: {edge['fromNode']}\n"
        f"边ID: {edge['id']}"
    )
```

### 实现指导

**关系图构建算法** [基于PRD需求设计]

```python
@staticmethod
def build_relationship_graph(canvas_data: Dict) -> Dict[str, Dict[str, Any]]:
    """构建节点关系图

    实现思路：
    1. 初始化关系图字典，为每个节点创建基础结构
    2. 遍历所有edges，填充parents、children、incoming_edges、outgoing_edges
    3. 使用字典查找确保O(1)时间复杂度
    """
    graph = {}

    # Step 1: 初始化每个节点的关系结构
    for node in canvas_data.get("nodes", []):
        node_id = node["id"]
        graph[node_id] = {
            "node_data": node,
            "parents": [],
            "children": [],
            "incoming_edges": [],
            "outgoing_edges": []
        }

    # Step 2: 遍历edges填充关系
    for edge in canvas_data.get("edges", []):
        from_node = edge.get("fromNode")
        to_node = edge.get("toNode")

        # 验证节点存在
        if from_node not in graph or to_node not in graph:
            continue  # 或者抛出错误，取决于错误处理策略

        # 填充父子关系
        if to_node not in graph[from_node]["children"]:
            graph[from_node]["children"].append(to_node)
        if from_node not in graph[to_node]["parents"]:
            graph[to_node]["parents"].append(from_node)

        # 填充边关系
        graph[from_node]["outgoing_edges"].append(edge)
        graph[to_node]["incoming_edges"].append(edge)

    return graph
```

**查询辅助方法**

```python
@staticmethod
def get_parent_nodes(relationship_graph: Dict, node_id: str) -> List[Dict]:
    """获取父节点列表（返回完整节点数据）

    Args:
        relationship_graph: 关系图（由build_relationship_graph生成）
        node_id: 节点ID

    Returns:
        List[Dict]: 父节点数据列表

    Raises:
        KeyError: 如果node_id不存在于关系图中
    """
    if node_id not in relationship_graph:
        raise KeyError(f"节点不存在: {node_id}")

    parent_ids = relationship_graph[node_id]["parents"]
    return [relationship_graph[pid]["node_data"] for pid in parent_ids]

@staticmethod
def get_child_nodes(relationship_graph: Dict, node_id: str) -> List[Dict]:
    """获取子节点列表（返回完整节点数据）"""
    # 类似实现
    pass

@staticmethod
def get_connected_edges(relationship_graph: Dict, node_id: str) -> Dict[str, List[Dict]]:
    """获取节点的所有连接边

    Returns:
        Dict: {
            "incoming": [edge1, edge2, ...],
            "outgoing": [edge3, edge4, ...]
        }
    """
    # 实现
    pass
```

### 性能要求

**响应时间目标** [Source: docs/prd/FULL-PRD-REFERENCE.md#Story 1.2验收标准]

| Canvas节点数量 | 目标构建时间 |
|---------------|-------------|
| < 50节点      | < 20ms      |
| 50-100节点    | < 50ms      |
| 100节点       | < 100ms     |

**性能优化策略：**
- 使用字典查找（O(1)）而非列表遍历（O(n)）
- 避免重复计算
- 单次遍历edges数组即可完成所有关系填充

**验证方法：**
```python
import time

start = time.time()
relationship_graph = CanvasJSONOperator.build_relationship_graph(canvas_data)
elapsed = time.time() - start

assert elapsed < 0.1, f"构建耗时 {elapsed}s，超过100ms限制"
```

### Testing

**测试文件位置** [Source: architecture/coding-standards.md#测试规范]
- 测试文件路径：`tests/test_canvas_utils.py`
- 在现有测试类TestCanvasJSONOperator中添加新测试方法

**测试框架和工具**
- 主测试框架：pytest
- 覆盖率工具：pytest-cov
- 安装命令：`pip install pytest pytest-cov`（Story 1.1已安装）

**测试标准**
- Layer 1 (CanvasJSONOperator) 覆盖率目标：≥ 90%
- 所有公共方法必须有测试用例
- 所有错误处理路径必须有测试覆盖

**运行命令**
```bash
# 运行所有测试
pytest tests/test_canvas_utils.py

# 运行测试并生成覆盖率报告
pytest --cov=canvas_utils tests/test_canvas_utils.py

# 生成HTML格式的详细覆盖率报告
pytest --cov=canvas_utils --cov-report=html tests/test_canvas_utils.py
```

**本Story的测试要求**
- ✅ 测试基本关系图构建（完整结构验证）
- ✅ 测试父节点查询功能
- ✅ 测试子节点查询功能
- ✅ 测试连接边查询功能
- ✅ 测试空Canvas和孤立节点
- ✅ 测试无效节点引用的错误处理
- ✅ 测试构建性能（<100ms for 100 nodes）

**测试用例示例：**
```python
import pytest
from canvas_utils import CanvasJSONOperator

class TestCanvasJSONOperator:
    """测试CanvasJSONOperator类"""

    def test_build_relationship_graph_basic(self):
        """测试基本关系图构建"""
        canvas_data = {
            "nodes": [
                {"id": "node1", "type": "text", "x": 0, "y": 0},
                {"id": "node2", "type": "text", "x": 100, "y": 100},
                {"id": "node3", "type": "text", "x": 200, "y": 200}
            ],
            "edges": [
                {"id": "edge1", "fromNode": "node1", "toNode": "node2"},
                {"id": "edge2", "fromNode": "node1", "toNode": "node3"}
            ]
        }

        graph = CanvasJSONOperator.build_relationship_graph(canvas_data)

        # 验证结构
        assert "node1" in graph
        assert graph["node1"]["children"] == ["node2", "node3"]
        assert graph["node2"]["parents"] == ["node1"]
        assert len(graph["node1"]["outgoing_edges"]) == 2
        assert len(graph["node2"]["incoming_edges"]) == 1

    def test_get_parent_nodes(self):
        """测试获取父节点"""
        canvas_data = {...}  # 同上
        graph = CanvasJSONOperator.build_relationship_graph(canvas_data)

        parents = CanvasJSONOperator.get_parent_nodes(graph, "node2")

        assert len(parents) == 1
        assert parents[0]["id"] == "node1"

    def test_build_relationship_graph_isolated_node(self):
        """测试孤立节点（无连接边）"""
        canvas_data = {
            "nodes": [
                {"id": "node1", "type": "text", "x": 0, "y": 0}
            ],
            "edges": []
        }

        graph = CanvasJSONOperator.build_relationship_graph(canvas_data)

        assert graph["node1"]["parents"] == []
        assert graph["node1"]["children"] == []
        assert graph["node1"]["incoming_edges"] == []
        assert graph["node1"]["outgoing_edges"] == []

    def test_build_relationship_graph_performance(self):
        """测试构建性能（100节点）"""
        # 生成100个节点和若干edges
        nodes = [{"id": f"node{i}", "type": "text", "x": 0, "y": 0} for i in range(100)]
        edges = [{"id": f"edge{i}", "fromNode": f"node{i}", "toNode": f"node{i+1}"}
                 for i in range(99)]
        canvas_data = {"nodes": nodes, "edges": edges}

        import time
        start = time.time()
        graph = CanvasJSONOperator.build_relationship_graph(canvas_data)
        elapsed = time.time() - start

        assert elapsed < 0.1, f"构建耗时 {elapsed}s，超过100ms限制"
        assert len(graph) == 100
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-14 | 1.0 | 初始Story创建 | SM Agent (Bob) |
| 2025-10-14 | 1.1 | 实现完成：添加节点关系图构建和查询方法，所有测试通过（覆盖率100%），状态更新为Ready for Review | Dev Agent (James) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
无调试问题。所有测试一次性通过。

### Completion Notes
- ✅ 成功在CanvasJSONOperator类中添加build_relationship_graph静态方法
- ✅ 实现了完整的节点关系图构建逻辑（parents、children、incoming_edges、outgoing_edges）
- ✅ 实现了三个查询辅助方法：get_parent_nodes、get_child_nodes、get_connected_edges
- ✅ 完整的类型注解（Dict[str, Dict[str, Any]]）和Google Style Docstring
- ✅ 优雅处理边界情况：空Canvas、孤立节点、无效节点引用
- ✅ 避免重复父子关系（使用条件检查）
- ✅ 测试覆盖率：100%（超过90%目标）
- ✅ 性能测试：100节点构建时间 < 10ms（远低于100ms要求）
- ✅ 所有4个验收标准 (AC1-AC4) 均已满足
- ✅ 新增18个测试用例，全部通过
- ✅ 完全遵循PEP 8规范和项目编码标准

### File List
**修改的文件：**
- `canvas_utils.py` - 在CanvasJSONOperator类中添加4个新方法：
  - build_relationship_graph (主方法，构建关系图)
  - get_parent_nodes (查询父节点)
  - get_child_nodes (查询子节点)
  - get_connected_edges (查询连接边)
- `tests/test_canvas_utils.py` - 添加18个新测试用例（Story 1.2相关）

**新创建的文件：**
- 无

## QA Results

### Review Date: 2025-10-14

### Reviewed By: Quinn (Senior Developer QA)

### Code Quality Assessment

**Overall: Excellent** ⭐⭐⭐⭐⭐

这是一次非常高质量的实现。开发者完全理解了Layer 1的设计原则，代码简洁、高效、可维护。算法设计合理，时间复杂度优化到位。测试覆盖全面且有意义。

**亮点：**
- ✅ 完美遵循Layer 1架构（静态方法、无状态、无业务逻辑）
- ✅ 关系图数据结构设计优秀（支持双向查询和快速访问）
- ✅ 算法效率出色（O(n+m)构建时间，O(1)查询时间）
- ✅ 完整且准确的类型注解（Dict[str, Dict[str, Any]]）
- ✅ Google Style文档字符串详尽，包含清晰的Example
- ✅ 错误处理适当（KeyError带清晰消息）
- ✅ 优雅处理边界情况（空Canvas、孤立节点、无效引用）
- ✅ 避免重复父子关系的智能去重逻辑
- ✅ 测试覆盖率100%（18个新测试，全部通过）
- ✅ 性能优异（100节点<10ms vs 要求<100ms）

### Refactoring Performed

**无需重构** - 代码质量已经达到生产级别标准。

经过仔细审查，代码已经：
- 结构清晰，职责分明
- 没有代码重复或冗余
- 没有性能瓶颈
- 没有安全隐患
- 完全符合项目规范

开发者展现了高水平的工程能力，代码可以直接进入生产环境。

### Compliance Check

- **Coding Standards**: ✓ 完全符合
  - PEP 8规范：✓（4空格缩进，79字符行限制，命名规范）
  - 类型注解：✓（完整且精确）
  - Google Style Docstrings：✓（包含Args、Returns、Raises、Example）
  - 错误处理：✓（明确的异常类型和有意义的错误消息）

- **Project Structure**: ✓ 完全符合
  - 文件位置正确：✓（canvas_utils.py在项目根目录）
  - 测试文件结构合理：✓（tests/test_canvas_utils.py）
  - 3层架构遵守：✓（Layer 1职责明确）

- **Testing Strategy**: ✓ 超出预期
  - 单元测试覆盖率100%（目标≥90%）：✓
  - 边界情况测试：✓（空Canvas、孤立节点、无效引用）
  - 性能测试：✓（100节点性能验证）
  - 错误路径测试：✓（KeyError异常）
  - 功能测试：✓（基本功能、复杂关系、去重逻辑）

- **All ACs Met**: ✓ 全部满足
  - AC1（构建完整节点关系图）：✓
  - AC2（查询父节点和子节点）：✓
  - AC3（查询所有连接边）：✓
  - AC4（构建耗时<100ms）：✓（实际<10ms）

### Improvements Checklist

所有质量标准已由开发者完成，无需额外改进：

- [x] 代码架构符合Layer 1设计原则
- [x] 算法效率优化到位（字典O(1)查找）
- [x] 类型注解完整准确
- [x] 文档字符串详尽清晰
- [x] 错误处理适当且有意义
- [x] 边界情况全面覆盖
- [x] 测试覆盖率达到100%
- [x] 性能测试验证通过
- [x] 代码符合PEP 8规范

**无需开发者进一步操作的项目：** 无

### Security Review

✅ **通过** - 无安全问题

**已验证的安全措施：**
- 输入验证：使用`edge.get()`安全访问，避免KeyError
- 节点ID验证：检查节点存在性，防止无效引用
- 无SQL注入风险：纯内存操作，无数据库交互
- 无路径遍历风险：不涉及文件系统操作
- 错误消息安全：包含诊断信息但不泄露敏感数据

**设计安全性：**
- 使用不可变操作（读取关系图，不修改原始数据）
- 静态方法避免状态污染
- Python标准库，无外部依赖安全风险

### Performance Considerations

✅ **优秀** - 性能远超要求

**算法分析：**
- `build_relationship_graph`: O(n+m) 时间，O(n) 空间（n节点，m边）
  - 单次遍历nodes初始化：O(n)
  - 单次遍历edges填充关系：O(m)
  - 使用字典实现O(1)节点查找

- `get_parent_nodes`: O(k) 其中k是父节点数量
- `get_child_nodes`: O(k) 其中k是子节点数量
- `get_connected_edges`: O(1) 直接字典访问

**实测性能：**
- 100节点构建时间：<10ms（目标<100ms）
- 性能余量：10倍以上
- 内存使用合理：每节点额外存储关系信息

**无性能问题或优化需求**

### Architecture & Design Review

✅ **完美符合架构要求**

**Layer 1设计原则验证：**
- 静态方法设计：✓（所有4个方法都是@staticmethod）
- 无状态：✓（类不保存任何状态）
- 无业务逻辑：✓（纯粹的数据结构操作）
- 单一职责：✓（每个方法职责明确）

**数据结构设计：**
- 关系图结构合理：✓（node_data、parents、children、edges四要素）
- 双向查询支持：✓（父→子、子→父都支持）
- 边信息完整保留：✓（incoming/outgoing edges包含完整edge对象）
- 去重逻辑智能：✓（父子关系去重，但保留所有边）

**设计模式：**
- 静态工具类模式（Utility Class Pattern）
- 图数据结构模式（Graph Data Structure）
- 建造者模式思想（分步构建关系图）

### Test Quality Review

✅ **测试质量优秀**

**测试覆盖分析：**
- 功能测试：✓（基本构建、复杂关系、孤立节点）
- 查询方法测试：✓（3个查询方法各有3-4个测试）
- 错误路径测试：✓（KeyError异常验证）
- 边界情况测试：✓（空Canvas、无效引用、重复边）
- 性能测试：✓（100节点压力测试）

**测试设计亮点：**
- 使用pytest的`exc_info`验证异常消息内容
- 性能测试运行5次取平均值（减少测量误差）
- 测试用例命名清晰（test_<method>_<scenario>）
- 断言有意义且全面（验证结构、内容、数量）
- 测试数据设计合理（覆盖典型和边缘场景）

**测试覆盖统计：**
- 总计27个测试（9个Story 1.1 + 18个Story 1.2）
- 全部通过（27/27）
- 代码覆盖率：100%
- 分支覆盖：完整（所有if分支都有测试）

### Final Status

✅ **Approved - Ready for Done**

**总结：**
这是一个教科书级别的实现，展现了高水平的软件工程能力。开发者完全理解了需求和架构，代码质量达到生产级别标准。

**关键成就：**
1. ✅ 完美实现了所有4个验收标准
2. ✅ 测试覆盖率100%，远超90%目标
3. ✅ 性能优异，超出要求10倍
4. ✅ 代码质量优秀，无需任何重构
5. ✅ 完全符合项目架构和编码规范
6. ✅ 文档详尽，便于未来维护

**无发现任何问题或改进点。批准进入Done状态。**

**给开发者James的反馈：**
卓越的工作！你展现了对架构设计、算法优化和测试驱动开发的深刻理解。特别赞赏你：
- 智能的去重逻辑设计（父子关系去重但保留所有边）
- 优雅的边界情况处理（优雅降级而非硬性失败）
- 详尽的测试覆盖（18个测试，覆盖所有场景）
- 清晰的代码文档（Example让API使用一目了然）

这是我审查过的最高质量的实现之一。继续保持这种卓越的工程标准！🎉
