# Story 5.1: 智能响应时间优化

## Status
Draft

## Story

**As a** 学习者,
**I want** 系统在执行耗时操作时提供明确的进度提示和响应时间反馈,
**so that** 我知道系统正在工作而不是卡死，并能预估等待时间，提升使用体验。

## Acceptance Criteria

1. 对于耗时>10秒的操作，在开始前显示预估时间提示
2. 对于耗时>30秒的操作，提供阶段性进度更新
3. 所有Agent调用操作记录实际响应时间
4. 基础操作响应时间<3秒（如读取Canvas、创建节点）
5. 复杂操作响应时间<40秒（如生成检验白板、批量评分）
6. Canvas文件I/O操作<1秒
7. 操作超时（>60秒）时提供清晰的错误提示和重试建议

## Tasks / Subtasks

- [ ] Task 1: 在canvas-orchestrator.md中添加操作时间监控机制 (AC: 3, 4, 5, 6)
  - [ ] 定义操作时间监控装饰器或计时逻辑
  - [ ] 为所有主要操作添加时间记录
  - [ ] 定义操作类型和预估时间表（基础操作、复杂操作、Agent调用）
  - [ ] 记录实际执行时间与预估时间的对比

- [ ] Task 2: 实现耗时操作的进度提示机制 (AC: 1, 2)
  - [ ] 识别耗时>10秒的操作列表（生成检验白板、批量评分、深度拆解等）
  - [ ] 在操作开始前输出提示："🔄 正在{操作名称}，预计需要{X}秒..."
  - [ ] 对于>30秒操作，添加阶段性进度提示（如"✓ 已完成50%..."）
  - [ ] 使用自然语言描述操作进度（避免纯数字百分比）

- [ ] Task 3: 优化Canvas文件I/O性能 (AC: 6)
  - [ ] 验证`read_canvas()`方法使用`with`语句管理文件资源
  - [ ] 验证`write_canvas()`方法使用原子写入（写临时文件后重命名）
  - [ ] 添加I/O操作性能测试（目标<1秒）
  - [ ] 对于大型Canvas文件（>1MB），添加性能优化提示

- [ ] Task 4: 实现操作超时检测和重试建议 (AC: 7)
  - [ ] 定义操作超时阈值（默认60秒）
  - [ ] 检测Agent调用超时情况
  - [ ] 提供友好的超时错误信息："⏱️ 操作超时（{X}秒）。可能原因：..."
  - [ ] 提供重试建议（如"尝试拆解为更小的问题"、"简化输入材料"）

- [ ] Task 5: 更新canvas-orchestrator性能指导文档 (AC: 1-7)
  - [ ] 在canvas-orchestrator.md的"性能优化建议"章节添加响应时间规范
  - [ ] 添加操作时间对照表（操作类型 → 预估时间 → 实际基准）
  - [ ] 添加性能优化最佳实践（批量操作、避免重复I/O）
  - [ ] 添加用户体验指导（何时显示进度、如何描述等待）

- [ ] Task 6: 创建性能测试用例 (AC: 4, 5, 6)
  - [ ] 测试Canvas读取操作<1秒（使用典型大小的Canvas文件）
  - [ ] 测试节点创建操作<3秒（创建5个节点）
  - [ ] 测试批量评分操作<40秒（评分10个黄色节点）
  - [ ] 测试检验白板生成<40秒（从20个节点生成检验白板）
  - [ ] 性能回归测试：确保优化后性能不低于基线

## Dev Notes

### Story 5.1的核心性质

**Story 5.1是用户体验优化Story，而非技术性能优化**

**关键理解**：
- 这不是要重写底层代码来提升性能（那是Story 5.2的工作）
- 这是要让用户**感知**到系统的响应，避免"卡死"的错觉
- 核心交付物是**进度提示机制**和**时间监控文档**

**Story目标**：
为canvas-orchestrator添加智能的响应时间管理和用户进度提示机制，确保用户始终知道系统状态。

### Previous Story Insights

[Source: Epic 4已完成，所有Story 4.1-4.9 Done]

**从Epic 4学到的性能经验**：
1. ✅ 检验白板生成操作耗时较长（10-30秒），需要进度提示
2. ✅ 批量评分操作（Story 2.8）可能耗时>20秒
3. ✅ Canvas文件I/O已实现，但未明确性能监控
4. ✅ 用户在长时间等待时缺乏反馈

**对Story 5.1的启示**：
- 重点优化长时间操作的用户体验（检验白板、批量评分）
- 添加阶段性进度提示（如"✓ 已提取15个问题..."、"✓ 正在聚类..."）
- 不需要重写现有代码，主要是添加监控和提示逻辑

### 系统性能指标

[Source: docs/prd/FULL-PRD-REFERENCE.md lines 55-58]

**PRD定义的性能目标**：
```
系统性能指标：
- Agent响应时间：基础操作<3秒，复杂操作<10秒
- Canvas更新操作<1秒
- 评分系统准确度：与真实理解水平误差±10分以内
```

**重要澄清**：
- **基础操作<3秒**：读取Canvas、创建单个节点、更新节点颜色
- **复杂操作<10秒**：调用单个Sub-agent、生成单个解释
- **特殊操作<40秒**：批量评分、生成检验白板（允许更长时间，但需进度提示）

**Story 5.1的重新定义**：
- AC 5中的"复杂操作<40秒"是修正后的现实目标（基于Epic 1-4实施经验）
- PRD的"复杂操作<10秒"过于理想化，实际检验白板生成需20-30秒
- Story 5.1接受现实性能，重点是**用户体验**而非底层优化

### 操作类型与预估时间表

[Source: 基于Epic 1-4实施经验总结]

**操作时间对照表**：

| 操作类型 | 操作示例 | 预估时间 | 需要进度提示 |
|---------|---------|---------|-------------|
| **基础操作** | 读取Canvas文件 | <1秒 | ❌ 否 |
| **基础操作** | 创建1-3个节点 | <3秒 | ❌ 否 |
| **基础操作** | 更新节点颜色 | <1秒 | ❌ 否 |
| **中等操作** | 调用单个Sub-agent（如basic-decomposition） | 5-10秒 | ⚠️ 可选 |
| **中等操作** | 生成单个解释文档（oral-explanation） | 15-20秒 | ✅ 是 |
| **复杂操作** | 批量评分10个黄色节点 | 20-30秒 | ✅ 是 + 阶段性更新 |
| **复杂操作** | 生成检验白板（20个节点） | 25-40秒 | ✅ 是 + 阶段性更新 |
| **复杂操作** | 对比分析两个Canvas | 5-10秒 | ⚠️ 可选 |

**进度提示策略**：
- **<10秒**：无需提示（快速完成）
- **10-30秒**：开始前提示 "🔄 正在{操作}，预计需要{X}秒..."
- **>30秒**：开始前提示 + 每10秒阶段性更新

### 进度提示设计规范

[Source: docs/architecture/canvas-orchestrator.md + UX最佳实践]

**提示语设计原则**：
1. **使用emoji增强可读性**：🔄（进行中）、✓（完成）、⚠️（警告）、⏱️（超时）
2. **使用自然语言**：避免"Processing... 50%"，使用"✓ 已提取15个问题，正在生成检验问题..."
3. **提供时间预估**：具体秒数（如"预计需要25秒"）
4. **阶段性描述**：说明当前在做什么，而不仅是百分比

**进度提示示例**：

**场景1：生成检验白板（25-40秒）**
```
🔄 正在生成检验白板，预计需要30秒...
  ✓ 已提取18个红色和紫色节点
  ✓ 正在生成检验问题...
  ✓ 已生成25个检验问题
  ✓ 正在按主题聚类...
  ✓ 已完成聚类（5个主题）
  ✓ 正在创建Canvas文件...
  ✓ 检验白板已生成！文件：离散数学-检验白板-20250115.canvas
```

**场景2：批量评分（20-30秒）**
```
🔄 正在批量评分10个黄色节点，预计需要25秒...
  ✓ 已评分 3/10（通过: 2, 未通过: 1）
  ✓ 已评分 6/10（通过: 4, 未通过: 2）
  ✓ 已评分 10/10（通过: 7, 未通过: 3）
  ✓ 批量评分完成！通过率: 70%
```

**场景3：操作超时（>60秒）**
```
⏱️ 操作超时（65秒）。可能原因：
  - 输入材料过于复杂（>2000字）
  - 网络连接不稳定

💡 建议：
  1. 尝试拆解为更小的问题
  2. 简化输入材料（提取核心段落）
  3. 检查网络连接后重试
```

### 文件位置

[Source: docs/architecture/unified-project-structure.md]

**本Story涉及的文件**：

```
C:/Users/ROG/托福/
├── .claude/agents/
│   └── canvas-orchestrator.md       # ⭐ 修改：添加性能监控和进度提示机制
│       # 新增章节：
│       # - "五.1 操作时间监控"
│       # - "五.2 进度提示规范"
│       # - "五.3 操作时间对照表"
│
├── canvas_utils.py                  # ⭐ 可选修改：添加性能计时装饰器（如需要）
│   # 可选：添加@performance_monitor装饰器
│   # 记录关键操作的执行时间
│
└── tests/
    └── test_performance.py          # ⭐ 新建：性能测试文件
        # TestPerformanceBenchmarks类
        # - test_canvas_read_under_1_second()
        # - test_basic_operations_under_3_seconds()
        # - test_complex_operations_under_40_seconds()
```

### 实现策略：文档优先

**Story 5.1的实现方式与Epic 1-4不同**：

**Epic 1-4的实现方式**：
- 实现Python代码 → 编写Agent文件 → 编写测试

**Story 5.1的实现方式（文档优先）**：
1. **更新canvas-orchestrator.md文档** - 定义性能规范和进度提示标准
2. **编写性能测试** - 验证现有代码已符合性能目标
3. **（可选）添加计时逻辑** - 如果测试发现性能问题

**理由**：
- 现有代码（Epic 1-4）性能可能已经达标，只是缺乏文档化
- 进度提示主要是**Orchestrator层的用户沟通**，不需要修改底层代码
- 先用测试验证现状，避免过度优化

### 不需要修改的内容

**Layer 1 (CanvasJSONOperator)** - 无需修改：
- `read_canvas()` 和 `write_canvas()` 已使用`with`语句
- 文件I/O性能已优化（原子写入）
- 只需添加性能测试验证

**Layer 2 (CanvasBusinessLogic)** - 无需修改：
- 业务逻辑方法已批量操作优化
- Story 2.8的批量评分已实现

**Layer 3 (CanvasOrchestrator)** - 主要工作在这一层：
- 添加进度提示输出（用户可见）
- 添加时间监控逻辑（记录实际时间）
- 更新文档规范

### 性能监控实现建议

[Source: docs/architecture/coding-standards.md 性能最佳实践]

**选项1：装饰器方式（如果需要代码级监控）**

```python
import time
import functools

def performance_monitor(operation_name: str, estimated_seconds: int):
    """性能监控装饰器"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()

            # 如果预估时间>10秒，显示提示
            if estimated_seconds > 10:
                print(f"🔄 正在{operation_name}，预计需要{estimated_seconds}秒...")

            result = func(*args, **kwargs)

            elapsed = time.time() - start_time
            print(f"✓ {operation_name}完成（实际耗时：{elapsed:.1f}秒）")

            return result
        return wrapper
    return decorator

# 使用示例
@performance_monitor("生成检验白板", 30)
def generate_review_canvas_file(self, clusters):
    # ... 实现逻辑
    pass
```

**选项2：文档化方式（推荐用于Story 5.1）**

在canvas-orchestrator.md中添加性能规范文档：

```markdown
### 五.1 操作时间监控与用户提示

#### 操作类型定义

**基础操作（<3秒）** - 无需进度提示：
- 读取Canvas文件
- 创建1-3个节点
- 更新节点颜色

**中等操作（5-15秒）** - 开始前提示：
- 调用单个Sub-agent
- 生成单个解释文档

**复杂操作（20-40秒）** - 开始前提示 + 阶段性更新：
- 批量评分（>5个节点）
- 生成检验白板
- 深度拆解（>7个子问题）

#### 进度提示模板

**开始前提示**：
```
🔄 正在{操作名称}，预计需要{X}秒...
```

**阶段性更新**：
```
  ✓ {阶段描述}
  ✓ {阶段描述}
```

**完成提示**：
```
✓ {操作名称}完成！{结果摘要}
```
```

## Testing

### Testing Standards

[Source: docs/architecture/coding-standards.md lines 453-511]

**测试文件位置**：
- 新建文件：`tests/test_performance.py`
- 测试Canvas I/O：使用`tests/fixtures/test-original.canvas`

**测试框架**：
- 使用pytest框架
- 使用`time.time()`测量执行时间
- 性能基准测试（非功能测试）

**测试命名规范**：
- 测试类：`TestPerformanceBenchmarks`
- 测试方法：`test_{operation}_under_{threshold}_seconds`

### Test Cases

**测试场景1：Canvas读取性能**

**前置条件**：
- 使用test-original.canvas（典型大小：~20KB，约30个节点）

**测试步骤**：
```python
def test_canvas_read_under_1_second():
    """测试Canvas读取操作<1秒（AC 6）"""
    import time

    # Arrange
    canvas_path = "tests/fixtures/test-original.canvas"
    operator = CanvasJSONOperator()

    # Act
    start_time = time.time()
    canvas_data = operator.read_canvas(canvas_path)
    elapsed = time.time() - start_time

    # Assert
    assert elapsed < 1.0, f"Canvas读取耗时{elapsed:.2f}秒，超过1秒阈值"
    assert canvas_data is not None
    assert "nodes" in canvas_data
```

**期望结果**：
- 读取操作<1秒
- Canvas数据正确解析

**验收标准对应**：AC 6

---

**测试场景2：基础操作性能**

**测试步骤**：
```python
def test_basic_operations_under_3_seconds():
    """测试基础操作（创建5个节点）<3秒（AC 4）"""
    import time

    # Arrange
    logic = CanvasBusinessLogic("tests/fixtures/test-original.canvas")
    canvas_data = logic.operator.read_canvas(logic.canvas_path)

    # Act
    start_time = time.time()
    for i in range(5):
        logic.operator.create_node(
            canvas_data,
            node_type="text",
            x=100 + i * 100,
            y=100,
            text=f"测试节点 {i+1}"
        )
    elapsed = time.time() - start_time

    # Assert
    assert elapsed < 3.0, f"创建5个节点耗时{elapsed:.2f}秒，超过3秒阈值"
    assert len(canvas_data["nodes"]) >= 5
```

**期望结果**：
- 创建5个节点<3秒
- 所有节点成功创建

**验收标准对应**：AC 4

---

**测试场景3：复杂操作性能（检验白板生成）**

**测试步骤**：
```python
def test_review_canvas_generation_under_40_seconds():
    """测试检验白板生成<40秒（AC 5）"""
    import time

    # Arrange
    logic = CanvasBusinessLogic("tests/fixtures/test-original.canvas")
    nodes = logic.extract_verification_nodes()
    questions = logic.generate_verification_questions(nodes)
    clusters = logic.cluster_questions_by_topic(questions, nodes)

    # Act
    start_time = time.time()
    result = logic.generate_review_canvas_file(clusters)
    elapsed = time.time() - start_time

    # Assert
    assert elapsed < 40.0, f"检验白板生成耗时{elapsed:.2f}秒，超过40秒阈值"
    assert result["success"] is True
    assert os.path.exists(result["review_canvas_path"])

    # Cleanup
    os.remove(result["review_canvas_path"])
```

**期望结果**：
- 检验白板生成<40秒
- 文件成功创建

**验收标准对应**：AC 5

---

**测试场景4：批量评分性能**

**前置条件**：
- 准备Canvas文件，包含10个黄色节点

**测试步骤**：
```python
def test_batch_scoring_under_40_seconds():
    """测试批量评分10个节点<40秒（AC 5）"""
    import time

    # Arrange
    orchestrator = CanvasOrchestrator("tests/fixtures/test-canvas-with-10-yellow.canvas")

    # Act
    start_time = time.time()
    report = orchestrator.batch_score_all_yellow_nodes()
    elapsed = time.time() - start_time

    # Assert
    assert elapsed < 40.0, f"批量评分耗时{elapsed:.2f}秒，超过40秒阈值"
    assert report["total"] == 10
    assert "passed" in report
    assert "failed" in report
```

**期望结果**：
- 批量评分10个节点<40秒
- 评分报告正确生成

**验收标准对应**：AC 5

---

**测试场景5：Canvas写入性能**

**测试步骤**：
```python
def test_canvas_write_under_1_second():
    """测试Canvas写入操作<1秒（AC 6）"""
    import time
    import tempfile
    import shutil

    # Arrange
    operator = CanvasJSONOperator()
    original_path = "tests/fixtures/test-original.canvas"
    canvas_data = operator.read_canvas(original_path)

    # 创建临时文件
    temp_path = tempfile.mktemp(suffix=".canvas")

    try:
        # Act
        start_time = time.time()
        operator.write_canvas(temp_path, canvas_data)
        elapsed = time.time() - start_time

        # Assert
        assert elapsed < 1.0, f"Canvas写入耗时{elapsed:.2f}秒，超过1秒阈值"
        assert os.path.exists(temp_path)
    finally:
        # Cleanup
        if os.path.exists(temp_path):
            os.remove(temp_path)
```

**期望结果**：
- Canvas写入<1秒
- 文件成功保存

**验收标准对应**：AC 6

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-15 | 1.0 | 初始Story创建（智能响应时间优化） | SM Agent (Bob) |

---
