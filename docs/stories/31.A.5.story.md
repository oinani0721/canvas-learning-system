# Story 31.A.5: 集成测试补全

## 元数据

| 属性 | 值 |
|------|------|
| Story ID | 31.A.5 |
| EPIC | 31.A - 记忆系统管道修复 |
| 优先级 | P1 - High |
| 状态 | Pending |
| 修复断点 | 测试缺口: 1193 Mocks, 0 E2E 测试 |

---

## 1. 问题描述

### 1.1 当前状态

通过调研发现的测试现状：

| 指标 | 值 | 问题 |
|------|------|------|
| 单元测试数量 | 152 | 看似充足 |
| Mock 使用数量 | 1193 | **过度依赖** |
| 端到端测试 | 0 | **完全缺失** |
| 集成测试（真实 Neo4j） | 0 | **完全缺失** |

### 1.2 影响

- Mock 过度掩盖了真实集成问题
- 4 个断点在单元测试中全部"通过"（因为 Mock 了正确行为）
- 重启后数据丢失的问题无法被测试发现
- 依赖注入错误在 Mock 环境下不会暴露

### 1.3 测试金字塔现状

```
当前状态:              期望状态:

    ┌───┐              ┌───┐
    │E2E│ = 0          │E2E│ = 5+
    ├───┤              ├───┤
    │集成│ = 0          │集成│ = 10+
    ├───┴──┤           ├───┴──┤
    │ 单元  │ = 152     │ 单元  │ = 152
    └──────┘           └──────┘
```

---

## 2. 验收标准

### AC-31.A.5.1: 跨会话持久化测试

**文件**: `backend/tests/integration/test_memory_persistence.py` (新建)

**测试场景**:
```python
@pytest.mark.integration
@pytest.mark.asyncio
async def test_cross_session_persistence(real_neo4j_client):
    """验证跨会话数据持久化"""
    # Session 1: 写入
    service1 = MemoryService(neo4j_client=real_neo4j_client)
    await service1.initialize()
    await service1.record_learning_event(
        user_id="test_user",
        canvas_path="test/canvas.canvas",  # 必填参数
        node_id="test_node_001",            # 必填参数
        concept="线性代数",
        agent_type="scoring",               # 必填参数
        score=90,
        subject="数学"
    )
    await service1.close()

    # 模拟重启（清空内存）

    # Session 2: 读取
    service2 = MemoryService(neo4j_client=real_neo4j_client)
    await service2.initialize()
    result = await service2.get_learning_history(user_id="test_user")

    # 验证
    assert len(result["items"]) > 0
    assert any(item["concept"] == "线性代数" for item in result["items"])
```

**验收条件**:
- [ ] 使用真实 Neo4j 实例（通过 Docker）
- [ ] Session 1 写入数据
- [ ] 模拟服务重启（新建 MemoryService 实例）
- [ ] Session 2 能读取 Session 1 的数据
- [ ] 测试在 CI 中可运行

---

### AC-31.A.5.2: 依赖注入验证测试

**文件**: `backend/tests/integration/test_dependency_injection.py` (新建)

**测试场景**:
```python
@pytest.mark.integration
@pytest.mark.asyncio
async def test_verification_service_has_graphiti_client():
    """验证 VerificationService 正确注入 GraphitiClient"""
    # 使用真实的依赖注入
    from app.dependencies import get_verification_service

    service = await get_verification_service()

    # 验证 graphiti_client 已注入（通过 LearningMemoryClient）
    assert service._graphiti_client is not None
    # 验证实际存在的方法（非 search_verification_questions）
    assert hasattr(service._graphiti_client, 'search_memories')

@pytest.mark.integration
@pytest.mark.asyncio
async def test_graphiti_search_memories_callable():
    """验证 search_memories 可调用"""
    from app.dependencies import get_verification_service

    service = await get_verification_service()

    # 使用实际存在的 search_memories 方法
    try:
        result = await service._graphiti_client.search_memories(
            query="测试概念",
            user_id="test_user"
        )
        assert isinstance(result, list)
    except AttributeError as e:
        pytest.fail(f"GraphitiClient not properly injected: {e}")
```

**验收条件**:
- [ ] 验证 `graphiti_client` 不为 None（通过 LearningMemoryClient）
- [ ] 验证 `search_memories()` 方法可调用（实际存在的方法）
- [ ] 不使用 Mock

---

### AC-31.A.5.3: 双写一致性测试

**文件**: `backend/tests/integration/test_dual_write_consistency.py` (新建)

**测试场景**:
```python
@pytest.mark.integration
@pytest.mark.asyncio
async def test_dual_write_neo4j_and_graphiti():
    """验证数据同时写入 Neo4j 和 Graphiti"""
    service = MemoryService(
        neo4j_client=real_neo4j,
        learning_memory=real_graphiti
    )
    await service.initialize()

    # 写入
    await service.record_learning_event(
        user_id="test_user",
        canvas_path="test/dual_write.canvas",  # 必填参数
        node_id="dual_write_node_001",          # 必填参数
        concept="微积分",
        agent_type="scoring",                   # 必填参数
        score=85
    )

    # 等待异步写入完成
    await asyncio.sleep(2)

    # 验证 Neo4j
    neo4j_result = await real_neo4j.get_learning_history(user_id="test_user")
    assert any(item["concept"] == "微积分" for item in neo4j_result)

    # 验证 Graphiti（如果可查询）
    # graphiti_result = await real_graphiti.search_episodes(...)
```

**验收条件**:
- [ ] 数据写入 Neo4j 成功
- [ ] 数据写入 Graphiti 成功（或重试后失败有日志）
- [ ] 两个存储的数据一致

---

### AC-31.A.5.4: 端到端 API 测试

**文件**: `backend/tests/e2e/test_memory_api_e2e.py` (新建)

**测试场景**:
```python
@pytest.mark.e2e
@pytest.mark.asyncio
async def test_memory_api_full_cycle():
    """端到端测试: 写入 → 重启 → 读取"""
    async with AsyncClient(app=app, base_url="http://test") as client:
        # 1. 写入学习事件
        write_response = await client.post(
            "/api/v1/memory/episodes",  # 正确端点：/episodes 而非 /events
            json={
                "user_id": "e2e_user",
                "canvas_path": "test/e2e.canvas",  # 必填参数
                "node_id": "e2e_node_001",          # 必填参数
                "concept": "概率论",
                "agent_type": "scoring",            # 必填参数
                "score": 88,
                "subject": "数学"
            }
        )
        assert write_response.status_code == 201  # 正确状态码：201 Created

        # 2. 读取学习历史
        read_response = await client.get(
            "/api/v1/memory/episodes",
            params={"user_id": "e2e_user"}
        )
        assert read_response.status_code == 200
        data = read_response.json()

        # 3. 验证数据
        assert len(data["items"]) > 0
        assert any(item["concept"] == "概率论" for item in data["items"])
```

**验收条件**:
- [ ] 通过真实 HTTP 请求测试
- [ ] 覆盖完整的写入-读取周期
- [ ] 验证 API 响应格式正确

---

## 3. 技术实现

### 3.1 新建文件清单

| 文件 | 测试类型 | 测试数量 |
|------|---------|---------|
| `backend/tests/integration/test_memory_persistence.py` | 集成 | 3+ |
| `backend/tests/integration/test_dependency_injection.py` | 集成 | 3+ |
| `backend/tests/integration/test_dual_write_consistency.py` | 集成 | 2+ |
| `backend/tests/e2e/test_memory_api_e2e.py` | E2E | 2+ |
| `backend/tests/conftest.py` | Fixture | - |

### 3.2 测试基础设施

**pytest fixture for real Neo4j**:
```python
# conftest.py

@pytest.fixture(scope="module")
async def real_neo4j_client():
    """真实 Neo4j 客户端 (需要 Docker)"""
    client = Neo4jClient(
        uri="bolt://localhost:7687",
        user="neo4j",
        password="test_password"
    )
    await client.connect()

    # 清理测试数据
    await client.run_query("MATCH (n:TestNode) DETACH DELETE n")

    yield client

    # 清理
    await client.run_query("MATCH (n:TestNode) DETACH DELETE n")
    await client.close()
```

### 3.3 CI 配置

```yaml
# .github/workflows/integration-tests.yml
name: Integration Tests

on: [push, pull_request]

jobs:
  integration:
    runs-on: ubuntu-latest
    services:
      neo4j:
        image: neo4j:5.15
        ports:
          - 7687:7687
        env:
          NEO4J_AUTH: neo4j/test_password

    steps:
      - uses: actions/checkout@v3
      - name: Run integration tests
        run: |
          pytest backend/tests/integration -v --tb=short
        env:
          NEO4J_URI: bolt://localhost:7687
          NEO4J_USER: neo4j
          NEO4J_PASSWORD: test_password
```

---

## 4. 测试计划

### 4.1 测试分类

| 类型 | 标记 | 运行条件 |
|------|------|---------|
| 单元测试 | `@pytest.mark.unit` | 始终运行 |
| 集成测试 | `@pytest.mark.integration` | 需要 Neo4j |
| E2E 测试 | `@pytest.mark.e2e` | 需要完整环境 |

### 4.2 运行命令

```bash
# 仅单元测试
pytest backend/tests/unit -v

# 集成测试（需要 Docker）
docker-compose up -d neo4j
pytest backend/tests/integration -v -m integration

# E2E 测试
pytest backend/tests/e2e -v -m e2e

# 全部测试
pytest backend/tests -v
```

---

## 5. 风险与缓解

| 风险 | 缓解措施 |
|------|---------|
| CI 中 Neo4j 服务不可用 | 使用 Docker services |
| 测试数据污染 | 使用独立测试数据库/清理脚本 |
| 测试运行时间过长 | 并行运行，分阶段 |
| 环境变量配置错误 | 提供默认值和文档 |

---

## 6. Definition of Done

- [ ] 所有 AC 完成并通过验证
- [ ] 集成测试使用真实 Neo4j
- [ ] E2E 测试覆盖完整数据流
- [ ] CI 配置完成并通过
- [ ] 测试覆盖 4 个断点的修复验证
- [ ] 代码 review 通过

---

## 7. 依赖关系

```
31.A.5 集成测试补全
    ├── 依赖 31.A.1 (验证依赖注入)
    ├── 依赖 31.A.2 (验证跨会话持久化)
    ├── 依赖 31.A.3 (验证写入可靠性)
    └── 依赖 31.A.4 (验证前端连接) *前端测试单独运行
```

---

---

## 8. Dev Notes

### 8.1 SDD规范参考 (必填)

> 以下规范从实际代码提取，确保与代码实现一致

**API 端点** (来源: `backend/app/api/v1/endpoints/memory.py`):

| 端点 | 方法 | 状态码 | 规范来源 |
|------|------|--------|----------|
| `/api/v1/memory/episodes` | POST | 201 Created | `memory.py:110-116` |
| `/api/v1/memory/episodes` | GET | 200 OK | `memory.py:130-135` |

**请求 Schema** (来源: `backend/app/schemas/memory_schemas.py`):
```python
class LearningEventCreate(BaseModel):
    user_id: str                          # 必填
    canvas_path: str                      # 必填
    node_id: str                          # 必填
    concept: str                          # 必填
    agent_type: str                       # 必填
    score: Optional[int] = None
    duration_seconds: Optional[int] = None
    subject: Optional[str] = None
```

**服务层方法签名** (来源: `backend/app/services/memory_service.py:213`):
```python
async def record_learning_event(
    self,
    user_id: str,
    canvas_path: str,       # 必填 - Story 之前遗漏
    node_id: str,           # 必填 - Story 之前遗漏
    concept: str,
    agent_type: str,        # 必填 - Story 之前遗漏
    score: Optional[int] = None,
    duration_seconds: Optional[int] = None,
    subject: Optional[str] = None
) -> str
```

**Graphiti Client 实际可用方法** (来源: `backend/app/clients/graphiti_client.py`):
- `add_learning_episode()` ✅
- `search_memories(query, user_id)` ✅
- `get_learning_history(user_id)` ✅
- ~~`search_verification_questions()`~~ ❌ 不存在

---

### 8.2 ADR决策关联 (必填)

> 从实际代码提取的架构决策

| 决策点 | 实现位置 | 决策内容 |
|--------|----------|----------|
| **双写策略** | `memory_service.py:300-312` | Neo4j 同步 + Graphiti 异步 fire-and-forget |
| **Graphiti 超时** | `memory_service.py:69` | `GRAPHITI_JSON_WRITE_TIMEOUT = 0.5` (500ms) |
| **Neo4j 重试** | `neo4j_client.py:85-92` | Tenacity 库，3 次重试，指数退避 (1s, 2s, 4s) |
| **异步模式** | `memory_service.py:305` | `asyncio.create_task()` 无等待 |

**关键架构约束**:

1. **Graphiti 写入失败静默降级** (来源: `memory_service.py:310-312`):
```python
asyncio.create_task(
    self._write_to_graphiti_json(...)
)  # fire-and-forget，无重试
```

2. **Neo4j 重试配置** (来源: `neo4j_client.py:85-92`):
```python
@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=4),
    retry=retry_if_exception_type(ServiceUnavailable)
)
```

3. **VerificationService 依赖** (来源: `dependencies.py:531-535`):
   - 需注入 `graphiti_client` 参数
   - 当前断点: 未传入导致 `_graphiti_client = None`

---

### 8.3 Testing 标准 (必填)

> 从实际测试配置提取

**pytest 配置** (来源: `backend/pytest.ini`):
```ini
[pytest]
asyncio_mode = auto
addopts = -v --tb=short --cov=app --cov-fail-under=85
markers =
    integration: marks tests as integration tests (deselect with '-m "not integration"')
    e2e: marks tests as end-to-end tests (deselect with '-m "not e2e"')
    slow: marks tests as slow (deselect with '-m "not slow"')
```

**现有 Fixture** (来源: `backend/tests/conftest.py`):
```python
@pytest.fixture
async def async_client() -> AsyncGenerator[AsyncClient, None]:
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        yield client
```

**测试命名规范**:
- 文件: `test_<module>_<type>.py` (如 `test_memory_persistence.py`)
- 函数: `test_<action>_<expected_result>` (如 `test_cross_session_persistence`)
- 标记: `@pytest.mark.integration` 或 `@pytest.mark.e2e`

**覆盖率要求**: ≥85% (由 `--cov-fail-under=85` 强制)

---

## 版本历史

| 版本 | 日期 | 变更 |
|------|------|------|
| 1.0 | 2026-02-05 | 初始创建 |
| 1.1 | 2026-02-05 | 修复 5 个验证问题：API 端点、状态码、方法调用、参数、Dev Notes |
