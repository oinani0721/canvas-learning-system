# Story 12.5: LangGraph StateGraph构建

## Status: Approved

## Epic Context & Background

**所属Epic**: EPIC-12 - 三层记忆系统 + Agentic RAG
**Epic文档**: [EPIC-12-STORY-MAP.md](../epics/EPIC-12-STORY-MAP.md)

**本Story在Epic中的定位**:
- Phase 2 (检索融合层) 的核心Story
- 实现LangGraph StateGraph作为Agentic RAG的编排核心
- **依赖**: Story 12.1 (Graphiti时序知识图谱集成), Story 12.2 (LanceDB POC验证), Story 12.4 (Temporal Memory实现)
- **被依赖**: Story 12.6, 12.7, 12.8, 12.9, 12.10, 12.11, 12.12 (后续检索融合Story依赖StateGraph框架)

**Epic核心问题回顾**:

### Problem 7: 缺乏多源检索编排能力
- **现象**: 系统无法协调多个记忆层的检索结果
- **根因**: 没有状态图框架进行检索流程编排
- **修复**: 实现LangGraph StateGraph + 5个核心检索节点
- **本Story验证**: 验证StateGraph可以编排retrieve→fuse→rerank流程

### Problem 8: 检索质量无法自适应
- **现象**: 检索结果质量不稳定，无法自动重试
- **根因**: 缺乏质量检查和自适应循环机制
- **修复**: 实现check_quality节点 + 条件边重试逻辑
- **本Story验证**: 验证质量检查和重试机制工作正常

---

## Story

**As a** Canvas学习系统,
**I want** 使用LangGraph StateGraph编排多源检索流程,
**so that** 能够协调Graphiti和LanceDB的检索结果，实现高质量的Agentic RAG

---

## Acceptance Criteria

### AC 1: CanvasRAGState Schema定义 (验证Problem 7基础)
- **继承**: 继承LangGraph `MessagesState`
- **必需字段**:
  - `session_id: str` - 会话标识
  - `canvas_path: str` - Canvas文件路径
  - `operation: Literal["decomposition", "scoring", "explanation", "verification", "review"]`
- **可选字段**:
  - `messages: List[BaseMessage]` - 消息历史 (from MessagesState)
  - `target_nodes: List[str]` - 目标节点ID列表
  - `graphiti_results: List[Dict]` - Graphiti检索结果
  - `lancedb_results: List[Dict]` - LanceDB检索结果
  - `fused_results: List[Dict]` - 融合后结果
  - `reranked_results: List[Dict]` - 重排序后结果
  - `quality_score: float` - 质量评分 (0-1)
  - `retry_count: int` - 重试次数
- **Context7来源**: `/langchain-ai/langgraph` - MessagesState

### AC 2: CanvasRAGConfig Context Schema (验证Problem 7)
- **配置字段**:
  - `graphiti_endpoint: str` - Graphiti Neo4j连接配置
  - `lancedb_path: str` - LanceDB数据库路径
  - `fusion_strategy: Literal["rrf", "weighted", "cascade"]` - 融合策略
  - `rerank_model: str` - 重排序模型
  - `quality_threshold: float` - 质量阈值 (default: 0.7)
  - `max_retries: int` - 最大重试次数 (default: 3)
- **使用方式**: `graph.invoke(state, config={"configurable": {...}})`
- **Context7来源**: `/langchain-ai/langgraph` - Configurable Parameters

### AC 3: 5个核心检索节点实现 (验证Problem 7核心)
- **节点1**: `retrieve_graphiti` - 从Graphiti检索概念关系
  - 输入: query from state
  - 输出: graphiti_results
  - 依赖: Story 12.1 Graphiti集成
- **节点2**: `retrieve_lancedb` - 从LanceDB检索语义向量
  - 输入: query from state
  - 输出: lancedb_results
  - 依赖: Story 12.2 LanceDB POC
- **节点3**: `fuse_results` - 融合多源检索结果
  - 输入: graphiti_results, lancedb_results
  - 输出: fused_results
  - 策略: 根据config选择RRF/Weighted/Cascade
- **节点4**: `rerank_results` - 重排序融合结果
  - 输入: fused_results
  - 输出: reranked_results
  - 模型: 根据config选择reranker
- **节点5**: `check_quality` - 质量检查
  - 输入: reranked_results
  - 输出: quality_score, 决定是否重试
  - 逻辑: quality_score < threshold AND retry_count < max_retries → 重试

### AC 4: StateGraph Compile成功 (验证Problem 7)
- **图结构**:
  ```
  START → retrieve_graphiti ─┐
                             ├→ fuse_results → rerank_results → check_quality → END
  START → retrieve_lancedb ──┘                                        │
                                                                      ↓ (quality < threshold)
                                                               retrieve_graphiti (retry)
  ```
- **条件边**: `check_quality` → `END` (pass) 或 → `retrieve_graphiti` (retry)
- **编译**: `graph = builder.compile(checkpointer=MemorySaver())`
- **Context7来源**: `/langchain-ai/langgraph` - StateGraph

### AC 5: 端到端测试通过 (验证Problem 7, 8)
- **测试场景1**: 单次检索成功
  - 输入: canvas_path="离散数学.canvas", operation="explanation"
  - 预期: quality_score >= 0.7, retry_count = 0
- **测试场景2**: 重试后成功
  - 模拟: 首次quality_score = 0.5
  - 预期: 自动重试, 最终quality_score >= 0.7
- **测试场景3**: 达到最大重试
  - 模拟: 持续低质量
  - 预期: retry_count = 3后返回best effort结果
- **性能要求**: 单次检索流程 < 2秒 (不含LLM调用)

---

## Tasks / Subtasks

### 任务1: 创建StateGraph模块结构 (AC: 1, 2, 3, 4, 5)
- [ ] 1.1: 创建目录 `src/agentic_rag/`
- [ ] 1.2: 创建文件结构:
  ```
  src/agentic_rag/
  ├── __init__.py
  ├── state.py              # CanvasRAGState定义
  ├── config.py             # CanvasRAGConfig定义
  ├── nodes/
  │   ├── __init__.py
  │   ├── retrieve_graphiti.py
  │   ├── retrieve_lancedb.py
  │   ├── fuse_results.py
  │   ├── rerank_results.py
  │   └── check_quality.py
  ├── graph.py              # StateGraph构建
  └── utils.py              # 工具函数
  ```
- [ ] 1.3: 创建测试目录 `src/tests/agentic_rag/`

### 任务2: 实现CanvasRAGState (AC: 1)
- [ ] 2.1: 创建 `state.py`
  ```python
  # ✅ Verified from LangGraph Skill - MessagesState pattern
  from typing import List, Dict, Literal, Optional, Annotated
  from langgraph.graph import MessagesState
  from langchain_core.messages import BaseMessage

  class CanvasRAGState(MessagesState):
      """Canvas RAG检索状态"""
      session_id: str
      canvas_path: str
      operation: Literal["decomposition", "scoring", "explanation", "verification", "review"]
      target_nodes: Optional[List[str]] = None
      graphiti_results: Annotated[List[Dict], "Graphiti检索结果"] = []
      lancedb_results: Annotated[List[Dict], "LanceDB检索结果"] = []
      fused_results: List[Dict] = []
      reranked_results: List[Dict] = []
      quality_score: float = 0.0
      retry_count: int = 0
  ```
- [ ] 2.2: 测试: 验证State继承MessagesState正确

### 任务3: 实现CanvasRAGConfig (AC: 2)
- [ ] 3.1: 创建 `config.py`
  ```python
  # ✅ Verified from LangGraph Skill - Configurable pattern
  from dataclasses import dataclass
  from typing import Literal

  @dataclass
  class CanvasRAGConfig:
      """Canvas RAG配置"""
      graphiti_endpoint: str = "bolt://localhost:7687"
      lancedb_path: str = "~/.lancedb"
      fusion_strategy: Literal["rrf", "weighted", "cascade"] = "rrf"
      rerank_model: str = "cross-encoder/ms-marco-MiniLM-L-6-v2"
      quality_threshold: float = 0.7
      max_retries: int = 3
  ```
- [ ] 3.2: 实现config从环境变量加载
- [ ] 3.3: 测试: 验证config解析正确

### 任务4: 实现5个核心节点 (AC: 3)
- [ ] 4.1: 实现 `retrieve_graphiti.py`
  ```python
  # ✅ Verified from Graphiti Skill - search pattern
  async def retrieve_graphiti(state: CanvasRAGState, config: RunnableConfig) -> dict:
      """从Graphiti检索概念关系"""
      # 使用Graphiti client进行检索
      pass
  ```
- [ ] 4.2: 实现 `retrieve_lancedb.py`
  ```python
  # ✅ Verified from Context7 LanceDB - vector search
  async def retrieve_lancedb(state: CanvasRAGState, config: RunnableConfig) -> dict:
      """从LanceDB检索语义向量"""
      pass
  ```
- [ ] 4.3: 实现 `fuse_results.py`
  ```python
  def fuse_results(state: CanvasRAGState, config: RunnableConfig) -> dict:
      """融合多源检索结果"""
      # 根据fusion_strategy选择算法
      pass
  ```
- [ ] 4.4: 实现 `rerank_results.py`
  ```python
  def rerank_results(state: CanvasRAGState, config: RunnableConfig) -> dict:
      """重排序融合结果"""
      pass
  ```
- [ ] 4.5: 实现 `check_quality.py`
  ```python
  def check_quality(state: CanvasRAGState, config: RunnableConfig) -> dict:
      """质量检查，决定是否重试"""
      pass
  ```

### 任务5: 构建StateGraph (AC: 4)
- [ ] 5.1: 创建 `graph.py`
  ```python
  # ✅ Verified from LangGraph Skill - StateGraph pattern
  from langgraph.graph import StateGraph, START, END
  from langgraph.checkpoint.memory import MemorySaver

  def build_canvas_rag_graph() -> CompiledGraph:
      builder = StateGraph(CanvasRAGState)

      # 添加节点
      builder.add_node("retrieve_graphiti", retrieve_graphiti)
      builder.add_node("retrieve_lancedb", retrieve_lancedb)
      builder.add_node("fuse_results", fuse_results)
      builder.add_node("rerank_results", rerank_results)
      builder.add_node("check_quality", check_quality)

      # 添加边 - 并行检索
      builder.add_edge(START, "retrieve_graphiti")
      builder.add_edge(START, "retrieve_lancedb")
      builder.add_edge("retrieve_graphiti", "fuse_results")
      builder.add_edge("retrieve_lancedb", "fuse_results")
      builder.add_edge("fuse_results", "rerank_results")
      builder.add_edge("rerank_results", "check_quality")

      # 条件边 - 质量检查
      builder.add_conditional_edges(
          "check_quality",
          should_retry,
          {"retry": "retrieve_graphiti", "end": END}
      )

      return builder.compile(checkpointer=MemorySaver())
  ```
- [ ] 5.2: 实现 `should_retry` 条件函数
- [ ] 5.3: 测试: 验证图结构正确

### 任务6: 端到端测试 (AC: 5)
- [ ] 6.1: 创建 `src/tests/agentic_rag/test_canvas_rag_graph.py`
- [ ] 6.2: 测试场景1: 单次检索成功
- [ ] 6.3: 测试场景2: 重试后成功
- [ ] 6.4: 测试场景3: 达到最大重试
- [ ] 6.5: 性能测试: 验证 < 2秒

---

## Dev Notes

### Dependencies Verification

**前置依赖验证** (必须先完成):
- [ ] **Story 12.1已完成**: Graphiti时序知识图谱集成
- [ ] **Story 12.2已完成**: LanceDB POC验证通过
- [ ] **Story 12.4已完成**: Temporal Memory实现
- [ ] Python 3.9+ 环境就绪
- [ ] Neo4j服务运行中

**技术栈依赖**:
- [ ] langgraph >= 0.2.55 (Context7验证版本)
- [ ] langchain-core >= 0.3.0
- [ ] graphiti-core (from Story 12.1)
- [ ] lancedb (from Story 12.2)
- [ ] sentence-transformers (reranker)
- [ ] pytest-asyncio (异步测试)

### SDD规范参考

**LangGraph StateGraph API** [Source: LangGraph Skill + Context7 /langchain-ai/langgraph]:

```python
# ✅ Verified from LangGraph Skill - StateGraph initialization
from langgraph.graph import StateGraph, START, END
from langgraph.graph.state import CompiledGraph

builder = StateGraph(MyState)
builder.add_node("node_name", node_function)
builder.add_edge(START, "node_name")
builder.add_edge("node_name", END)

# ✅ Verified from LangGraph Skill - Conditional edges
builder.add_conditional_edges(
    "source_node",
    condition_function,  # Returns str key
    {"key1": "target1", "key2": "target2"}
)

# ✅ Verified from LangGraph Skill - Compile with checkpointer
from langgraph.checkpoint.memory import MemorySaver
graph = builder.compile(checkpointer=MemorySaver())
```

**MessagesState继承** [Source: LangGraph Skill]:
```python
# ✅ Verified from LangGraph Skill - MessagesState pattern
from langgraph.graph import MessagesState

class MyState(MessagesState):
    # 自动包含 messages: List[BaseMessage]
    custom_field: str
```

**Configurable参数** [Source: LangGraph Skill]:
```python
# ✅ Verified from LangGraph Skill - Config pattern
from langchain_core.runnables import RunnableConfig

def my_node(state: MyState, config: RunnableConfig) -> dict:
    configurable = config.get("configurable", {})
    my_param = configurable.get("my_param", "default")
    return {"field": value}

# 调用时传入config
result = graph.invoke(
    initial_state,
    config={"configurable": {"my_param": "value"}}
)
```

### 条件函数示例 (should_retry) [Source: LangGraph Skill - Conditional Edges]

```python
# ✅ Verified from LangGraph Skill - Conditional edge pattern
from typing import Literal
from langchain_core.runnables import RunnableConfig

def should_retry(state: CanvasRAGState, config: RunnableConfig) -> Literal["retry", "end"]:
    """
    质量检查条件函数: 决定是否重试检索流程

    逻辑:
    1. 如果 quality_score >= threshold → 返回 "end" (结束)
    2. 如果 quality_score < threshold AND retry_count < max_retries → 返回 "retry" (重试)
    3. 如果 retry_count >= max_retries → 返回 "end" (达到最大重试次数)

    Returns:
        "retry": 触发重新检索流程 (返回retrieve_graphiti节点)
        "end": 结束检索流程 (进入END节点)
    """
    configurable = config.get("configurable", {})
    quality_threshold = configurable.get("quality_threshold", 0.7)
    max_retries = configurable.get("max_retries", 3)

    # 检查是否达到质量阈值
    if state.quality_score >= quality_threshold:
        return "end"

    # 检查是否达到最大重试次数
    if state.retry_count >= max_retries:
        # 达到最大重试次数，返回best effort结果
        return "end"

    # 质量不达标且未达到最大重试次数，触发重试
    return "retry"


# ✅ 在StateGraph中使用条件边
builder.add_conditional_edges(
    "check_quality",
    should_retry,
    {
        "retry": "retrieve_graphiti",  # 重试时回到retrieve节点
        "end": END                      # 结束时进入END
    }
)
```

**注意事项**:
- `should_retry`必须返回`str`类型，匹配`add_conditional_edges`的路由映射
- 重试时需要在`check_quality`节点内部更新`retry_count`
- 建议在重试时应用Query重写策略以提高检索质量

---

### ADR决策关联

**ADR-002: LangGraph Multi-Agent System** [Source: docs/architecture/decisions/0002-langgraph-agents.md]:
- **决策**: 使用LangGraph作为多Agent编排框架
- **版本锁定**: langgraph >= 0.2.55
- **StateGraph**: 状态图作为核心编排机制
- **本Story关系**: 直接实现ADR-002的StateGraph架构

**ADR-003: Graphiti Memory System** [Source: docs/architecture/decisions/0003-graphiti-memory.md]:
- **决策**: 使用Graphiti + Neo4j作为时序知识图谱
- **3层记忆**: Layer 1 (Temporal) → Layer 2 (Graphiti) → Layer 3 (Semantic)
- **本Story关系**: 编排Layer 2和Layer 3的检索流程

**JSON Schema参考** [Source: specs/data/langgraph-state.schema.json]:
```json
{
  "required": ["session_id", "canvas_path", "operation"],
  "properties": {
    "operation": {"enum": ["decomposition", "scoring", "explanation", "verification", "review"]}
  }
}
```

### Testing Standards

**测试文件位置**: `src/tests/agentic_rag/`

**测试类型**:
- 单元测试 (各节点函数)
- 集成测试 (StateGraph端到端)
- 性能测试 (延迟基准)

**Mock策略**:
- Graphiti使用Mock (避免Neo4j依赖)
- LanceDB使用内存数据库
- Reranker使用轻量级模型

**覆盖率目标**: ≥80%

### Related Documentation

**Epic和Story文档**:
- [EPIC-12-STORY-MAP.md](../epics/EPIC-12-STORY-MAP.md) - Epic 12完整Story Map
- [12.1.story.md](./12.1.story.md) - Graphiti时序知识图谱集成
- [12.2.story.md](./12.2.story.md) - LanceDB POC验证
- [12.4.story.md](./12.4.story.md) - Temporal Memory实现

**架构文档** [Source: docs/architecture/]:
- [LANGGRAPH-MEMORY-INTEGRATION-DESIGN.md](../architecture/LANGGRAPH-MEMORY-INTEGRATION-DESIGN.md) - LangGraph集成设计
- [0002-langgraph-agents.md](../architecture/decisions/0002-langgraph-agents.md) - LangGraph ADR
- [0003-graphiti-memory.md](../architecture/decisions/0003-graphiti-memory.md) - Graphiti ADR
- [FUSION-ALGORITHM-DESIGN.md](../architecture/FUSION-ALGORITHM-DESIGN.md) - 融合算法设计

**外部文档**:
- LangGraph Skill: `.claude/skills/langgraph/SKILL.md`
- Graphiti Skill: `.claude/skills/graphiti/SKILL.md`
- Context7 LangGraph: `/langchain-ai/langgraph`

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-28 | 1.0 | 初始创建 - SM Agent *draft | Bob (SM Agent) |

---

## Dev Agent Record

### Agent Model Used
*待填写*

### Debug Log References
*待填写*

### Completion Notes List
*待填写*

### File List
*待填写*

---

## QA Results

*待QA Agent审查*
