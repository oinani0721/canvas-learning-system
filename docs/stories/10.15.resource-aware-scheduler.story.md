# Story 10.15: ResourceAwareScheduler - 资源感知调度器实现

## Status
TODO

## Story

**As a** Canvas学习系统用户（迁移到LangGraph后），
**I want** 系统能够智能地基于实际系统资源（内存、CPU）动态调整并发数，
**so that** 我能够在移除API限制后获得最大化的并发性能，同时避免系统资源过载导致崩溃。

## Background Context

**变更触发**: LangGraph迁移后，Agent API调用将不再受GLM-4.6 Max API并发限制（原限制20并发），可以实现无限制并发。

**现状问题**:
- 当前Epic 10并发模型基于错误假设（GLM-4.6 Max API限制）
- 并发值保守（Agent: 20, Node: 12, Task: 5）
- 缺乏系统资源保护机制

**目标状态**:
- 并发值大幅提升（Agent: 100, Node: 50, Task: 20）
- 基于系统资源（内存、CPU）的动态并发调整
- 防止资源过载的保护机制

**相关SCP**: SCP-005 - 移除API并发限制后的Epic 10调整

## Acceptance Criteria

### AC 1: ResourceAwareScheduler核心实现

#### 1.1 初始化配置
- [x] 支持配置最大内存使用百分比（默认80%）
- [x] 支持配置最大CPU使用百分比（默认80%）
- [x] 初始并发值直接设置为目标值（Agent: 100, Node: 50, Task: 20）
- [x] 支持配置最小并发数（默认10）
- [x] 支持配置调整间隔（默认1.0秒）

#### 1.2 实时资源监控
- [x] 每秒监控系统内存使用百分比（使用psutil）
- [x] 每秒监控系统CPU使用百分比（使用psutil）
- [x] 记录资源使用历史数据（用于分析）
- [x] 提供资源使用查询接口

#### 1.3 动态并发调整
- [x] **紧急降低**（Memory > 90% OR CPU > 90%）:
  - Agent并发 → min_concurrency (10)
  - Node并发 → min_concurrency (10)
  - Task并发 → max(5, min_concurrency // 2)
  - 记录WARNING日志
- [x] **降低并发**（Memory > 80% OR CPU > 80%）:
  - 所有并发值 × 0.7
  - 不低于min_concurrency
  - 记录INFO日志
- [x] **提升并发**（Memory < 50% AND CPU < 60%）:
  - Agent并发 × 1.3（不超过100）
  - Node并发 × 1.3（不超过100）
  - Task并发 × 1.2（不超过20）
  - 记录DEBUG日志

#### 1.4 并发限制查询接口
```python
def get_current_limits(self) -> Dict[str, int]:
    """返回当前的动态并发限制"""
    return {
        "agent_concurrency": self.agent_concurrency,
        "node_concurrency": self.node_concurrency,
        "task_concurrency": self.task_concurrency
    }
```

### AC 2: 与现有系统集成

#### 2.1 ReviewBoardAgentSelector集成
```python
class ReviewBoardAgentSelector:
    def __init__(self, resource_scheduler: ResourceAwareScheduler):
        self.resource_scheduler = resource_scheduler

    async def process_multiple_agents(
        self,
        node_id: str,
        agent_recommendations: List[str]
    ) -> Dict:
        """使用动态并发限制处理Agent"""
        # 获取当前并发限制
        limits = self.resource_scheduler.get_current_limits()
        current_limit = limits["agent_concurrency"]

        # 创建动态Semaphore
        semaphore = asyncio.Semaphore(current_limit)

        # 执行任务...
```

#### 2.2 IntelligentParallelScheduler集成
```python
class IntelligentParallelScheduler:
    def __init__(self, resource_scheduler: ResourceAwareScheduler):
        self.resource_scheduler = resource_scheduler

    async def execute_node_groups_parallel(
        self,
        task_groups: List[Dict]
    ) -> Dict:
        """使用动态节点级并发限制"""
        limits = self.resource_scheduler.get_current_limits()
        semaphore = asyncio.Semaphore(limits["node_concurrency"])

        # 执行任务...
```

#### 2.3 启动和停止管理
- 在IntelligentParallelCommandHandler初始化时启动监控
- 在命令执行完成后停止监控
- 支持优雅停止（cancel monitoring task）

### AC 3: 监控和日志

#### 3.1 日志记录
- 紧急降低: `WARNING` 级别，包含Memory%和CPU%
- 降低并发: `INFO` 级别，包含Memory%和CPU%
- 提升并发: `DEBUG` 级别，包含Memory%和CPU%
- 错误处理: `ERROR` 级别，包含异常堆栈

#### 3.2 监控指标
记录以下指标到日志或监控系统：
- `agent_concurrency_current`: 当前Agent并发数
- `node_concurrency_current`: 当前Node并发数
- `task_concurrency_current`: 当前Task并发数
- `memory_percent`: 当前内存使用百分比
- `cpu_percent`: 当前CPU使用百分比
- `concurrency_adjustment_events`: 并发调整事件计数

### AC 4: 性能和可靠性

#### 4.1 性能指标
- 资源监控开销 < 5% CPU
- 并发调整响应时间 < 100ms
- 内存使用（监控本身）< 50MB

#### 4.2 可靠性要求
- 监控循环异常不影响主任务执行
- 支持asyncio.CancelledError优雅退出
- 并发调整幂等性（重复调整不会导致问题）

#### 4.3 测试覆盖
- 单元测试: 各调整场景（紧急降低、降低、提升）
- 集成测试: 与ReviewBoardAgentSelector/IntelligentParallelScheduler集成
- 性能测试: 验证3-7倍性能提升（相比旧限制）
- 压力测试: 模拟高负载场景（Memory > 90%, CPU > 90%）

## Dev Notes

### Technical Context

**ResourceAwareScheduler完整实现** [Source: docs/architecture/epic10-concurrency-definition.md]:
```python
class ResourceAwareScheduler:
    """
    资源感知调度器

    职责:
    1. 实时监控系统资源（内存、CPU）
    2. 动态调整并发限制
    3. 防止资源过载
    4. 优化资源利用率
    """

    def __init__(
        self,
        max_memory_percent: float = 80.0,
        max_cpu_percent: float = 80.0,
        initial_agent_concurrency: int = 100,
        initial_node_concurrency: int = 50,
        initial_task_concurrency: int = 20,
        min_concurrency: int = 10,
        adjustment_interval: float = 1.0
    ):
        self.max_memory_percent = max_memory_percent
        self.max_cpu_percent = max_cpu_percent

        # 并发限制（动态调整）
        self.agent_concurrency = initial_agent_concurrency
        self.node_concurrency = initial_node_concurrency
        self.task_concurrency = initial_task_concurrency

        # 边界值
        self.min_concurrency = min_concurrency
        self.max_agent_concurrency = 100
        self.max_node_concurrency = 100
        self.max_task_concurrency = 20

        # 调整参数
        self.adjustment_interval = adjustment_interval
        self.monitoring_task = None

    async def start_monitoring(self):
        """启动资源监控循环"""
        self.monitoring_task = asyncio.create_task(self._monitor_loop())

    async def stop_monitoring(self):
        """停止资源监控"""
        if self.monitoring_task:
            self.monitoring_task.cancel()

    async def _monitor_loop(self):
        """监控循环"""
        while True:
            try:
                await asyncio.sleep(self.adjustment_interval)
                await self._adjust_concurrency_by_resources()
            except asyncio.CancelledError:
                break
            except Exception as e:
                logging.error(f"Resource monitoring error: {e}")

    async def _adjust_concurrency_by_resources(self):
        """基于实时资源动态调整并发数"""
        import psutil

        memory_percent = psutil.virtual_memory().percent
        cpu_percent = psutil.cpu_percent(interval=0.1)

        # 资源压力过高（>90%），紧急降低并发
        if memory_percent > 90 or cpu_percent > 90:
            self.agent_concurrency = self.min_concurrency
            self.node_concurrency = self.min_concurrency
            self.task_concurrency = max(5, self.min_concurrency // 2)
            logging.warning(
                f"Emergency concurrency reduction: "
                f"Memory={memory_percent}%, CPU={cpu_percent}%"
            )

        # 资源压力较高（80-90%），降低并发
        elif memory_percent > 80 or cpu_percent > 80:
            self.agent_concurrency = max(
                self.min_concurrency,
                int(self.agent_concurrency * 0.7)
            )
            self.node_concurrency = max(
                self.min_concurrency,
                int(self.node_concurrency * 0.7)
            )
            self.task_concurrency = max(
                5,
                int(self.task_concurrency * 0.7)
            )
            logging.info(
                f"Concurrency reduction: "
                f"Memory={memory_percent}%, CPU={cpu_percent}%"
            )

        # 资源充足（<50%），提升并发
        elif memory_percent < 50 and cpu_percent < 60:
            self.agent_concurrency = min(
                self.max_agent_concurrency,
                int(self.agent_concurrency * 1.3)
            )
            self.node_concurrency = min(
                self.max_node_concurrency,
                int(self.node_concurrency * 1.3)
            )
            self.task_concurrency = min(
                self.max_task_concurrency,
                int(self.task_concurrency * 1.2)
            )
            logging.debug(
                f"Concurrency increase: "
                f"Memory={memory_percent}%, CPU={cpu_percent}%"
            )

    def get_current_limits(self) -> Dict[str, int]:
        """获取当前并发限制"""
        return {
            "agent_concurrency": self.agent_concurrency,
            "node_concurrency": self.node_concurrency,
            "task_concurrency": self.task_concurrency
        }
```

### Implementation Plan

#### Phase 1: 核心ResourceAwareScheduler实现
1. 创建`resource_aware_scheduler.py`模块
2. 实现ResourceAwareScheduler类（上述完整代码）
3. 添加单元测试（test_resource_aware_scheduler.py）
4. 验证动态调整逻辑（紧急降低、降低、提升）

#### Phase 2: 系统集成
1. 修改ReviewBoardAgentSelector接受resource_scheduler参数
2. 修改IntelligentParallelScheduler接受resource_scheduler参数
3. 修改IntelligentParallelCommandHandler初始化scheduler
4. 更新所有调用点使用动态并发限制

#### Phase 3: 监控和日志
1. 配置日志级别（WARNING/INFO/DEBUG）
2. 添加监控指标收集
3. 创建监控仪表盘（可选）

#### Phase 4: 测试和验证
1. 单元测试: 覆盖所有调整场景
2. 集成测试: 验证与现有系统集成
3. 性能测试: 验证性能提升（3-7倍）
4. 压力测试: 验证资源保护机制

### Performance Expectations

| 场景 | 旧限制（API限制） | 新限制（资源感知） | 性能提升 |
|------|-----------------|-------------------|---------|
| 轻量任务（CPU<30%） | 20 agents | 100 agents | **5倍** |
| 标准任务（CPU 50-70%） | 20 agents | 60 agents | **3倍** |
| 重度任务（CPU>80%） | 20 agents | 10-20 agents | **持平（保护）** |
| 100节点批处理 | 12组 × 3agent = 36并发 | 50组 × 5agent = 250并发 | **7倍** |

### Dependencies

- **依赖库**: `psutil` (用于系统资源监控)
- **依赖Story**:
  - Story 10.1 (ReviewBoardAgentSelector)
  - Story 10.2 (IntelligentParallelScheduler)
  - Story 10.3 (IntelligentParallelCommandHandler)
- **配置更新**:
  - `epic10-concurrency-definition.md` (已更新)
  - PRD Section 3.4并发限制矩阵（待更新）

### Test Cases

#### Test 1: 紧急降低场景
```python
async def test_emergency_reduction():
    """测试Memory > 90%时紧急降低并发"""
    scheduler = ResourceAwareScheduler(
        initial_agent_concurrency=100,
        initial_node_concurrency=50,
        initial_task_concurrency=20
    )

    # Mock psutil返回高资源使用
    with patch('psutil.virtual_memory') as mock_mem:
        mock_mem.return_value.percent = 95
        with patch('psutil.cpu_percent') as mock_cpu:
            mock_cpu.return_value = 85

            await scheduler._adjust_concurrency_by_resources()

            # 验证紧急降低
            limits = scheduler.get_current_limits()
            assert limits["agent_concurrency"] == 10
            assert limits["node_concurrency"] == 10
            assert limits["task_concurrency"] == 5
```

#### Test 2: 降低并发场景
```python
async def test_concurrency_reduction():
    """测试Memory > 80%时降低并发"""
    scheduler = ResourceAwareScheduler(
        initial_agent_concurrency=100,
        initial_node_concurrency=50,
        initial_task_concurrency=20
    )

    # Mock psutil返回较高资源使用
    with patch('psutil.virtual_memory') as mock_mem:
        mock_mem.return_value.percent = 85
        with patch('psutil.cpu_percent') as mock_cpu:
            mock_cpu.return_value = 75

            await scheduler._adjust_concurrency_by_resources()

            # 验证降低（× 0.7）
            limits = scheduler.get_current_limits()
            assert limits["agent_concurrency"] == 70  # 100 * 0.7
            assert limits["node_concurrency"] == 35   # 50 * 0.7
            assert limits["task_concurrency"] == 14   # 20 * 0.7
```

#### Test 3: 提升并发场景
```python
async def test_concurrency_increase():
    """测试Memory < 50%时提升并发"""
    scheduler = ResourceAwareScheduler(
        initial_agent_concurrency=30,
        initial_node_concurrency=20,
        initial_task_concurrency=10
    )

    # Mock psutil返回低资源使用
    with patch('psutil.virtual_memory') as mock_mem:
        mock_mem.return_value.percent = 40
        with patch('psutil.cpu_percent') as mock_cpu:
            mock_cpu.return_value = 50

            await scheduler._adjust_concurrency_by_resources()

            # 验证提升（× 1.3/1.2）
            limits = scheduler.get_current_limits()
            assert limits["agent_concurrency"] == 39  # 30 * 1.3
            assert limits["node_concurrency"] == 26   # 20 * 1.3
            assert limits["task_concurrency"] == 12   # 10 * 1.2
```

#### Test 4: 集成测试
```python
async def test_integration_with_review_board():
    """测试与ReviewBoardAgentSelector集成"""
    scheduler = ResourceAwareScheduler()
    await scheduler.start_monitoring()

    selector = ReviewBoardAgentSelector(resource_scheduler=scheduler)

    # 执行多Agent处理
    result = await selector.process_multiple_agents(
        node_id="yellow-node-123",
        agent_recommendations=["clarification-path", "oral-explanation"]
    )

    # 验证使用了动态并发限制
    assert result["concurrency_used"] == scheduler.agent_concurrency

    await scheduler.stop_monitoring()
```

## Related Documents

- **Architecture**: `docs/architecture/epic10-concurrency-definition.md` (已更新)
- **SCP**: SCP-005 - 移除API并发限制后的Epic 10调整
- **Related Stories**:
  - Story 10.1: ReviewBoardAgentSelector
  - Story 10.2: IntelligentParallelScheduler
  - Story 10.3: IntelligentParallelCommandHandler

## Implementation Checklist

### Code Implementation
- [ ] 创建`resource_aware_scheduler.py`
- [ ] 实现ResourceAwareScheduler类
- [ ] 添加psutil依赖到requirements.txt
- [ ] 更新ReviewBoardAgentSelector集成
- [ ] 更新IntelligentParallelScheduler集成
- [ ] 更新IntelligentParallelCommandHandler初始化

### Testing
- [ ] 单元测试: test_emergency_reduction
- [ ] 单元测试: test_concurrency_reduction
- [ ] 单元测试: test_concurrency_increase
- [ ] 集成测试: test_integration_with_review_board
- [ ] 集成测试: test_integration_with_parallel_scheduler
- [ ] 性能测试: 验证3-7倍性能提升
- [ ] 压力测试: 模拟高负载场景

### Documentation
- [ ] 更新PRD Section 3.4并发限制矩阵
- [ ] 更新Story 10.1/10.2/10.3文档（添加resource_scheduler参数）
- [ ] 生成SCP-005最终文档（一步到位版本）
- [ ] 更新CLAUDE.md项目概览

### Deployment
- [ ] Code Review
- [ ] QA验证
- [ ] 生产环境配置更新
- [ ] 性能监控配置

## Success Metrics

- ✅ ResourceAwareScheduler实现完成并通过所有测试
- ✅ 与现有系统集成无回归
- ✅ 轻量场景性能提升5倍（CPU < 30%）
- ✅ 标准场景性能提升3倍（CPU 50-70%）
- ✅ 100节点批处理性能提升7倍
- ✅ 资源过载场景（CPU > 90%）能够保护系统稳定性
- ✅ 测试覆盖率 > 90%
