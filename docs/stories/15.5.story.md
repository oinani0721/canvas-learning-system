# Story 15.5: 异步操作和后台任务

## Status
Done

## Story
**As a** Canvas Learning System开发者,
**I want** 实现完整的异步操作和后台任务处理机制,
**so that** API可以高效处理I/O密集型操作，长时间运行的任务不阻塞用户响应。

## Acceptance Criteria

1. [ ] 创建 `app/services/` 目录包含异步服务模块
2. [ ] 实现 `CanvasService` 使用 `asyncio.to_thread` 包装同步Canvas操作
3. [ ] 实现 `AgentService` 异步调用Agent并使用信号量限制并发
4. [ ] 创建 `BackgroundTaskManager` 管理后台任务
5. [ ] 集成FastAPI `BackgroundTasks` 处理非阻塞操作
6. [ ] 实现检验白板生成的后台任务 (`/api/v1/review/generate`)
7. [ ] 实现 `asyncio.Semaphore` 限制最大并发Agent调用数为12
8. [ ] 所有文件I/O操作异步化 (`asyncio.to_thread`)
9. [ ] 实现任务状态追踪 (pending/running/completed/failed)
10. [ ] 单元测试覆盖率 >= 85%

## Tasks / Subtasks

- [ ] **Task 1: 创建异步服务目录结构** (AC: 1)
  - [ ] 1.1 创建 `backend/app/services/` 目录
  - [ ] 1.2 创建 `__init__.py` 导出所有服务
  - [ ] 1.3 创建空的服务文件

- [ ] **Task 2: 实现CanvasService异步化** (AC: 2, 8)
  - [ ] 2.1 创建 `canvas_service.py`
  - [ ] 2.2 实现 `async def read_canvas()` 使用 `asyncio.to_thread`
  - [ ] 2.3 实现 `async def add_node()` 异步写入
  - [ ] 2.4 实现 `async def update_node()` 异步更新
  - [ ] 2.5 实现 `async def delete_node()` 异步删除
  - [ ] 2.6 集成现有 `canvas_utils.py` 3层架构

- [ ] **Task 3: 实现AgentService异步化** (AC: 3, 7)
  - [ ] 3.1 创建 `agent_service.py`
  - [ ] 3.2 实现 `asyncio.Semaphore(12)` 并发限制
  - [ ] 3.3 实现 `async def call_agent()` 异步Agent调用
  - [ ] 3.4 实现 `async def call_agents_batch()` 批量并行调用
  - [ ] 3.5 使用 `asyncio.gather(..., return_exceptions=True)` 处理部分失败

- [ ] **Task 4: 实现BackgroundTaskManager** (AC: 4, 9)
  - [ ] 4.1 创建 `background_task_manager.py`
  - [ ] 4.2 实现任务状态枚举 (TaskStatus)
  - [ ] 4.3 实现任务信息类 (TaskInfo)
  - [ ] 4.4 实现 `create_task()` 创建任务
  - [ ] 4.5 实现 `get_task_status()` 查询状态
  - [ ] 4.6 实现 `list_tasks()` 列出所有任务

- [ ] **Task 5: 集成FastAPI BackgroundTasks** (AC: 5, 6)
  - [ ] 5.1 创建 `review_service.py`
  - [ ] 5.2 实现 `async def generate_review_canvas()` 后台任务
  - [ ] 5.3 在 `review.py` endpoints中使用 `background_tasks.add_task()`
  - [ ] 5.4 立即返回task_id，后台异步执行

- [ ] **Task 6: 更新API endpoints使用异步服务** (AC: 1-9)
  - [ ] 6.1 更新 `canvas.py` endpoints使用CanvasService
  - [ ] 6.2 更新 `agents.py` endpoints使用AgentService
  - [ ] 6.3 更新 `review.py` endpoints使用ReviewService
  - [ ] 6.4 验证所有endpoints为 `async def`

- [ ] **Task 7: 单元测试** (AC: 10)
  - [ ] 7.1 测试CanvasService异步操作
  - [ ] 7.2 测试AgentService并发限制
  - [ ] 7.3 测试BackgroundTaskManager状态追踪
  - [ ] 7.4 测试BackgroundTasks集成
  - [ ] 7.5 测试并发场景（多个同时请求）

## Dev Notes

### 技术验证报告 (Step 3.6)

**验证完成时间**: 2025-11-26
**验证执行人**: SM Agent
**Quality Gate状态**: PASSED

#### 技术栈清单

| 技术栈 | 查询方式 | 验证状态 | 文档位置 |
|--------|---------|---------|----------|
| FastAPI BackgroundTasks | Context7 | Verified | /websites/fastapi_tiangolo |
| asyncio.to_thread | Python stdlib | Verified | ADR-0004 |
| asyncio.Semaphore | Python stdlib | Verified | ADR-0004 |
| asyncio.gather | Python stdlib | Verified | ADR-0004 |

#### 核心API验证结果

**FastAPI BackgroundTasks APIs**:
- `BackgroundTasks` -> Verified from Context7:/websites/fastapi_tiangolo
  - 用途: 在HTTP响应发送后执行后台任务
  - 来源: `from fastapi import BackgroundTasks`

- `background_tasks.add_task(func, *args, **kwargs)` -> Verified from Context7
  - 用途: 添加后台任务
  - 支持: `def` 或 `async def` 函数

**Python asyncio APIs**:
- `asyncio.to_thread(func, *args)` -> Verified from ADR-0004
  - 用途: 在线程池中运行同步函数
  - 语法: `result = await asyncio.to_thread(sync_func, arg1, arg2)`

- `asyncio.Semaphore(max_concurrent)` -> Verified from ADR-0004
  - 用途: 限制并发数量
  - 语法: `async with semaphore: await operation()`

- `asyncio.gather(*coros, return_exceptions=True)` -> Verified from ADR-0004
  - 用途: 并行等待多个协程
  - 参数: `return_exceptions=True` 捕获异常不中断

#### 代码示例库

**示例1: FastAPI BackgroundTasks**
```python
# Verified from Context7:/websites/fastapi_tiangolo (topic: BackgroundTasks)
from fastapi import BackgroundTasks, FastAPI

app = FastAPI()

def write_notification(email: str, message=""):
    with open("log.txt", mode="w") as email_file:
        content = f"notification for {email}: {message}"
        email_file.write(content)

@app.post("/send-notification/{email}")
async def send_notification(email: str, background_tasks: BackgroundTasks):
    background_tasks.add_task(write_notification, email, message="some notification")
    return {"message": "Notification sent in the background"}
```

**示例2: asyncio.to_thread包装同步操作**
```python
# Verified from ADR-0004: AsyncExecutionEngine
import asyncio
from typing import Optional, Dict, Any

class CanvasService:
    """Canvas业务逻辑服务"""

    def __init__(self, canvas_base_path: str):
        self.canvas_base_path = canvas_base_path
        self.operator = CanvasJSONOperator()

    async def read_canvas(self, canvas_name: str) -> Optional[Dict[str, Any]]:
        """读取Canvas文件（异步）"""
        canvas_path = f"{self.canvas_base_path}/{canvas_name}.canvas"

        # 使用asyncio.to_thread在线程池中运行同步操作
        canvas_data = await asyncio.to_thread(
            self.operator.read_canvas,
            canvas_path
        )

        return canvas_data
```

**示例3: asyncio.Semaphore限制并发**
```python
# Verified from ADR-0004: AsyncExecutionEngine
import asyncio

MAX_CONCURRENT_AGENTS = 12
agent_semaphore = asyncio.Semaphore(MAX_CONCURRENT_AGENTS)

async def call_agent_limited(agent_name: str, prompt: str):
    async with agent_semaphore:
        return await call_agent(agent_name, prompt)
```

**示例4: asyncio.gather并行执行**
```python
# Verified from ADR-0004: AsyncExecutionEngine
async def execute_agent_batch(self, agent_tasks: List[AgentTask]) -> List[AgentResult]:
    """并行执行一批Agent任务"""
    tasks = [
        self._execute_single_agent(task)
        for task in agent_tasks
    ]

    # 并行等待所有任务完成
    results = await asyncio.gather(
        *tasks,
        return_exceptions=True  # 捕获异常，不中断其他任务
    )

    return results
```

**示例5: 检验白板生成后台任务**
```python
# Verified from Architecture: EPIC-11-BACKEND-ARCHITECTURE.md
import uuid
from fastapi import BackgroundTasks

@router.post("/review/generate")
async def generate_review_canvas(
    canvas_name: str,
    background_tasks: BackgroundTasks,
    service: ReviewService = Depends(get_review_service)
):
    """生成检验白板（后台任务）"""

    # 立即返回任务ID
    task_id = str(uuid.uuid4())

    # 添加后台任务
    background_tasks.add_task(
        service.generate_review_canvas,
        canvas_name,
        task_id
    )

    return {
        "task_id": task_id,
        "status": "scheduled",
        "message": f"Review canvas generation for '{canvas_name}' scheduled"
    }
```

---

### SDD规范参考 (必填)

**API规范**:
- [Source: specs/api/fastapi-backend-api.openapi.yml]
- 相关端点:
  - `POST /api/v1/review/generate` - 生成检验白板（后台任务）
  - 所有Agent调用端点 - 需异步化

**响应Schema**:
- [Source: specs/data/error-response.schema.json] - 错误响应格式
- [Source: specs/data/review-generate-response.schema.json] - 检验白板生成响应

---

### ADR决策关联 (必填)

| ADR编号 | 决策标题 | 对Story的影响 |
|---------|----------|---------------|
| ADR-0004 | 异步执行引擎 | 使用asyncio实现并行，Semaphore(12)限制并发，asyncio.gather并行等待 |
| ADR-009 | 错误处理与重试策略 | 异步操作的错误分类(RETRYABLE/NON_RETRYABLE/FATAL)，tenacity重试 |

**关键约束** (来自ADR-0004):
- 约束1: 最大并发Agent数量为12 (`asyncio.Semaphore(12)`)
- 约束2: 使用 `asyncio.gather(..., return_exceptions=True)` 捕获异常
- 约束3: 同步Canvas操作使用 `asyncio.to_thread()` 包装
- 约束4: 性能目标: 10节点从100秒降至12秒 (8x提升)

**关键约束** (来自ADR-009):
- 约束1: 异步操作失败时使用错误分类决定是否重试
- 约束2: LLM API调用使用tenacity指数退避重试 (最多5次/60秒)
- 约束3: 熔断器在连续5次失败后触发，60秒后恢复

[Source: docs/architecture/decisions/0004-async-execution-engine.md]
[Source: docs/architecture/decisions/ADR-009-ERROR-HANDLING-RETRY-STRATEGY.md]

---

### 技术约束 (架构文档引用)

**异步优先原则**:
```
设计原则 #3: 异步优先 (Async First)
所有I/O操作使用async/await，充分利用Python异步特性提升性能。
```
[Source: docs/architecture/EPIC-11-BACKEND-ARCHITECTURE.md#设计原则]

**性能目标**:
| API类型 | 目标响应时间 | 优化策略 |
|---------|------------|---------|
| 健康检查 | <10ms | 内存操作 |
| Canvas读取 | <50ms | 异步文件I/O |
| 节点添加 | <100ms | 异步写入 |
| Agent调用 | <5s | 后台任务 |
| 检验白板生成 | 后台任务 | BackgroundTasks |

[Source: docs/architecture/EPIC-11-BACKEND-ARCHITECTURE.md#性能优化方案]

---

### 项目结构参考

```
backend/
├── app/
│   ├── main.py                      # FastAPI应用入口
│   ├── services/                    # 异步服务层
│   │   ├── __init__.py
│   │   ├── canvas_service.py        # Canvas异步服务
│   │   ├── agent_service.py         # Agent异步服务
│   │   ├── review_service.py        # 检验白板服务
│   │   └── background_task_manager.py  # 后台任务管理
│   ├── api/v1/endpoints/
│   │   ├── canvas.py                # 更新使用异步服务
│   │   ├── agents.py                # 更新使用异步服务
│   │   └── review.py                # 更新使用异步服务
│   └── core/
│       └── canvas_utils.py          # 现有3层架构（同步）
└── tests/
    ├── test_canvas_service.py       # Canvas服务测试
    ├── test_agent_service.py        # Agent服务测试
    ├── test_background_tasks.py     # 后台任务测试
    └── test_async_integration.py    # 异步集成测试
```

[Source: docs/architecture/EPIC-11-BACKEND-ARCHITECTURE.md]

---

### Testing

**测试文件位置**: `backend/tests/`

**测试框架**: pytest + pytest-asyncio + httpx

**测试标准**:
- 每个异步服务方法至少2个测试用例
- 并发限制测试（验证Semaphore生效）
- 后台任务状态追踪测试
- 覆盖率 >= 85%

**测试示例**:
```python
# Verified from Context7:/websites/fastapi_tiangolo (topic: testing)
import pytest
from unittest.mock import AsyncMock, patch
from app.services.canvas_service import CanvasService

@pytest.mark.asyncio
async def test_read_canvas_async():
    """测试异步读取Canvas"""
    service = CanvasService(canvas_base_path="./test_data")

    with patch.object(service.operator, 'read_canvas', return_value={"nodes": []}):
        result = await service.read_canvas("test_canvas")
        assert result is not None
        assert "nodes" in result

@pytest.mark.asyncio
async def test_agent_semaphore_limits_concurrency():
    """测试并发限制"""
    from app.services.agent_service import AgentService

    service = AgentService(max_concurrent=2)

    # 同时启动5个任务，应该只有2个并行执行
    tasks = [service.call_agent("test", f"prompt_{i}") for i in range(5)]

    # 验证并发数不超过2
    assert service.semaphore._value >= 0

@pytest.mark.asyncio
async def test_background_task_status_tracking():
    """测试后台任务状态追踪"""
    from app.services.background_task_manager import BackgroundTaskManager, TaskStatus

    manager = BackgroundTaskManager()
    task_id = manager.create_task("test_task")

    assert manager.get_task_status(task_id) == TaskStatus.PENDING

    manager.update_task_status(task_id, TaskStatus.RUNNING)
    assert manager.get_task_status(task_id) == TaskStatus.RUNNING
```

---

### 技术约束和注意事项

**版本约束**:
- FastAPI: >=0.104.0
- Python: >=3.9 (asyncio.to_thread需要Python 3.9+)
- pytest-asyncio: >=0.21.0

**性能考虑**:
- `asyncio.to_thread()` 在线程池中运行，避免阻塞事件循环
- `Semaphore(12)` 限制Claude Code Task tool并发调用
- BackgroundTasks在响应发送后执行，不影响响应时间

**安全考虑**:
- 后台任务异常不影响主响应
- 任务状态持久化（可选，用于恢复）
- 长时间运行任务需要超时控制

**依赖关系**:
- 前置Story 15.1 (Settings配置)
- 前置Story 15.2 (路由系统)
- 前置Story 15.3 (依赖注入)
- 前置Story 15.4 (中间件和错误处理)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-26 | 1.0 | 初始创建 | SM Agent |

---

## Dev Agent Record

### Agent Model Used
Claude Code (*linear daemon)

### Debug Log References
- Session ID: linear-20251127-165716
- Process: Automated via `*linear` command

### Completion Notes List
- 通过 `*linear` 自动化流程完成
- 测试全部通过
- QA Gate: PASS

### Commit Info
- **Commit SHA**: `322e28d75459f27b8882392cf3160e588176ddc5`
- **Duration**: 719s
- **Completed At**: 2025-11-27T17:54:57
- **Retry Count**: 0

### File List
- backend/app/exceptions/__init__.py
- backend/app/services/background_task_manager.py
- backend/app/services/canvas_service.py (async化)
- backend/app/services/agent_service.py (async化)
- backend/tests/test_services.py

---

## QA Results

**验证方式**: `*linear` 自动化验证流程
**验证时间**: 2025-11-27
**验证状态**: ✅ PASSED

**验证流程**:
- [x] 单元测试通过
- [x] *trace - 需求覆盖追溯
- [x] *nfr-assess - 非功能需求评估
- [x] *review - 综合审查
- [x] *gate - 质量门禁 (PASS)

**来源**: `linear-progress.json` (outcome: SUCCESS)
