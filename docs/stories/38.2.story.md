# Story 38.2: Learning History Persistence & Restart Recovery

## Story
As a learner,
I want my learning history to survive application restarts,
So that my progress is never lost and AI context always has my full history.

## Status
done

## Acceptance Criteria

**AC-1 (D1: Persistence — Storage Location)**
Given a learning event is recorded via `record_episode_to_neo4j()`
When the event is appended to `self._episodes`
Then the event is also persisted to Neo4j (already done) AND the `_episodes` cache is recoverable from Neo4j on restart
And storage location: Neo4j (primary), `self._episodes` (runtime cache only)

**AC-2 (D1: Persistence — Restart Recovery)**
Given the application restarts
When `MemoryService` initializes
Then `self._episodes` is populated from Neo4j (query recent episodes, limit 1000)
And `get_learning_history()` returns non-empty results if previous sessions exist
And a startup log shows: `"MemoryService: recovered {N} episodes from Neo4j"`

**AC-3 (D5: Degradation — Neo4j Unavailable at Startup)**
Given Neo4j is unavailable when the application starts
When `MemoryService` attempts to recover episodes
Then `self._episodes` remains empty (graceful degradation)
And a WARNING log is emitted: `"MemoryService: Neo4j unavailable, starting with empty history"`
And new episodes recorded during this session are still appended to `self._episodes`
And recovery is re-attempted when Neo4j becomes available (lazy recovery on first query)

## Tasks/Subtasks

- [x] Task 1: Add `get_all_recent_episodes()` to Neo4jClient
  - [x] 1.1: Implement Neo4j Cypher query (all users, ORDER BY timestamp DESC, LIMIT)
  - [x] 1.2: Implement JSON fallback mode
  - [x] 1.3: Write unit tests for both modes
- [x] Task 2: Add episode recovery to MemoryService
  - [x] 2.1: Add `_episodes_recovered` flag to `__init__`
  - [x] 2.2: Implement `_recover_episodes_from_neo4j()` method
  - [x] 2.3: Call recovery in `initialize()` with AC-3 degradation handling
  - [x] 2.4: Write unit tests for recovery success/failure
- [x] Task 3: Implement lazy recovery in `get_learning_history()`
  - [x] 3.1: Add lazy recovery check before fallback path
  - [x] 3.2: Write unit test for lazy recovery scenario
- [x] Task 4: Integration tests
  - [x] 4.1: Test full restart recovery flow
  - [x] 4.2: Test degraded startup → lazy recovery

## Dev Notes

### Code References
| File | Line | Current Behavior |
|------|------|-----------------|
| `backend/app/services/memory_service.py` | L141 | `self._episodes: List[Dict] = []` — always starts empty |
| `backend/app/services/memory_service.py` | L146-154 | `initialize()` — only init Neo4j, no episode recovery |
| `backend/app/services/memory_service.py` | L397-506 | `get_learning_history()` — Neo4j first, fallback to `self._episodes` |
| `backend/app/clients/neo4j_client.py` | L847-919 | `get_learning_history()` — needs user_id |

### Architecture
- `self._episodes` is runtime cache, Neo4j is primary storage
- Recovery query: all recent LEARNED relationships, no user_id filter, limit 1000
- Lazy recovery: if startup recovery fails, retry on first `get_learning_history()` call

## Dev Agent Record

### Implementation Plan
1. Neo4jClient: Add `get_all_recent_episodes(limit=1000)` — Cypher + JSON fallback
2. MemoryService.__init__: Add `self._episodes_recovered = False`
3. MemoryService.initialize(): Call `_recover_episodes_from_neo4j()`, catch exceptions → WARNING
4. MemoryService._recover_episodes_from_neo4j(): Query Neo4j → convert to episode format → populate cache
5. MemoryService.get_learning_history(): Lazy recovery check before fallback path
6. Tests: 12 unit tests covering success, failure, lazy recovery, degradation

### Debug Log
- All 12 tests pass on first run
- 87 regression tests pass (no breakage)

### Completion Notes
- ✅ AC-1: Neo4j is primary storage, `self._episodes` is runtime cache recoverable via `get_all_recent_episodes()`
- ✅ AC-2: `initialize()` calls `_recover_episodes_from_neo4j()` which queries up to 1000 recent episodes. Startup log: "MemoryService: recovered {N} episodes from Neo4j"
- ✅ AC-3: Exception in recovery → WARNING log "Neo4j unavailable, starting with empty history", `_episodes_recovered=False`. Lazy recovery in `get_learning_history()` retries when Neo4j becomes available.
- Neo4jClient: Added `get_all_recent_episodes()` with Cypher query (no user_id filter) + JSON fallback
- MemoryService: Added `_episodes_recovered` flag, `_recover_episodes_from_neo4j()` method, lazy recovery in `get_learning_history()`

## File List
- `backend/app/clients/neo4j_client.py` (modified) — Added `get_all_recent_episodes()` + `_get_all_recent_episodes_json()`
- `backend/app/services/memory_service.py` (modified) — Added `_episodes_recovered`, `_recover_episodes_from_neo4j()`, lazy recovery in `get_learning_history()`, recovery call in `initialize()`
- `backend/tests/unit/test_story_38_2_episode_recovery.py` (new) — 12 unit tests for episode recovery
- `backend/tests/unit/test_story_38_2_qa_supplement.py` (new) — 15 QA + code review fix tests
- `docs/stories/38.2.story.md` (new) — Story file

## Change Log
- 2026-02-06: Implemented Story 38.2 — Learning History Persistence & Restart Recovery (all 3 ACs satisfied)
- 2026-02-07: Code Review fixes — H1: unique episode_id, H2: None-value `or` pattern, M1: dedup on lazy recovery, M2: cap episodes at 2000, L2: added limit=1000 boundary test
