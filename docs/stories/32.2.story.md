# Story 32.2: ReviewService FSRS Integration

## Status

**Done**

---

## Story

**As a** Canvas Learning System backend developer,
**I want** to replace `EbbinghausReviewScheduler` with `FSRSManager` in the ReviewService,
**so that** review scheduling uses the scientifically-optimized FSRS-4.5 algorithm for personalized, dynamic review intervals based on actual memory decay patterns.

---

## Acceptance Criteria

1. **AC-32.2.1**: `review_service.py` imports and uses `FSRSManager` instead of `EbbinghausReviewScheduler`
2. **AC-32.2.2**: Review records use FSRS ratings (1=Again, 2=Hard, 3=Good, 4=Easy)
3. **AC-32.2.3**: Next review date is calculated by FSRS algorithm (dynamic, not fixed intervals)
4. **AC-32.2.4**: Backward compatible: existing review records remain loadable
5. **AC-32.2.5**: Documentation explains existing SQLite data migration path

---

## Tasks / Subtasks

> **Prerequisites**: Story 32.1 must be completed first (py-fsrs dependency in requirements.txt)

- [ ] **Task 1: FSRSManager Integration** (AC: 1)
  - [ ] Add `FSRSManager` import to `review_service.py`
  - [ ] Inject `FSRSManager` dependency via `__init__()` (alongside existing services)
  - [ ] Create internal `_fsrs_manager` instance with configurable `desired_retention`

- [ ] **Task 2: Update `schedule_review()` method** (AC: 1, 3)
  - [ ] Replace `EbbinghausReviewScheduler.calculate_next_review()` with `FSRSManager.review_card()`
  - [ ] Store FSRS card state (stability, difficulty, due, state) per concept
  - [ ] Return dynamically calculated `next_review_date` from FSRS algorithm

- [ ] **Task 3: Update `record_review_result()` method** (AC: 2)
  - [ ] Accept FSRS rating (1-4) instead of percentage score
  - [ ] Call `FSRSManager.review_card(card, rating)` to update card state
  - [ ] Use `get_rating_from_score()` utility for backward compatibility with score-based inputs
  - [ ] Update card's `due`, `stability`, `difficulty`, `state`, `reps`, `lapses` fields

- [ ] **Task 4: Implement card state persistence** (AC: 4)
  - [ ] Use `CardState` dataclass for serialization
  - [ ] Store serialized card in review records (JSON field or separate table)
  - [ ] Load existing records: if no FSRS state, create fresh card

- [ ] **Task 5: Update API endpoint** (AC: 2, 4)
  - [ ] Update `POST /review/complete` in `review.py` to accept FSRS rating
  - [ ] Support both `rating` (1-4) and `score` (0-100) inputs for backward compatibility
  - [ ] Convert score to rating using `get_rating_from_score()` if score provided

- [ ] **Task 6: Add data migration documentation** (AC: 5)
  - [ ] Document migration strategy in docstrings
  - [ ] Describe how existing Ebbinghaus records are handled
  - [ ] Include code comments for fallback behavior

- [ ] **Task 7: Write unit tests** (AC: All)
  - [ ] Test FSRSManager integration (10+ test cases)
  - [ ] Test rating conversion (boundary conditions: 0, 39, 40, 59, 60, 84, 85, 100)
  - [ ] Test card state persistence (save/load cycle)
  - [ ] Test backward compatibility with existing records
  - [ ] Test endpoint with both rating and score inputs

---

## Dev Notes

### SDD规范参考 (必填)

**API Endpoints** (from OpenAPI specs):

| Endpoint | Method | Schema Reference |
|----------|--------|------------------|
| `/review/complete` | POST | `[Source: specs/api/review-api.openapi.yml#L149-L180]` |
| `/review/add-concept` | POST | `[Source: specs/api/review-api.openapi.yml#L76-L112]` |
| `/review/today-summary` | GET | `[Source: specs/api/review-api.openapi.yml#L114-L147]` |

**Request Schema** (`CompleteReviewRequest`):
```yaml
CompleteReviewRequest:
  type: object
  required: [concept_id]  # rating OR score required (backward compat)
  properties:
    concept_id:
      type: string
    rating:
      type: integer
      minimum: 1
      maximum: 4
      description: "FSRS rating (1=Again, 2=Hard, 3=Good, 4=Easy)"
    score:
      type: number
      minimum: 0
      maximum: 100
      description: "Legacy score (0-100), converted to rating via get_rating_from_score()"
    review_duration:
      type: integer
      description: "Review time in seconds"
```
`[Source: specs/api/review-api.openapi.yml#L542-L563]`

> **⚠️ Backward Compatibility Note**: OpenAPI spec needs update to include optional `score` field for AC-32.2.4. Implementation should accept either `rating` OR `score`.

**Response Schema** (`CompleteReviewResponse`):
```yaml
CompleteReviewResponse:
  properties:
    next_review:
      type: string
      format: date-time
    interval_days:
      type: integer
    fsrs_state:
      type: object
      properties:
        stability: {type: number}
        difficulty: {type: number}
        state: {type: integer, enum: [1, 2, 3], description: "1=Learning, 2=Review, 3=Relearning"}
```
`[Source: specs/api/review-api.openapi.yml#L565-L594]`

**Data Schema** (`fsrs-card.schema.json`):
```json
{
  "required": ["card_id", "concept_id", "due", "stability", "difficulty", "state"],
  "properties": {
    "stability": {"type": "number", "minimum": 0},
    "difficulty": {"type": "number", "minimum": 1, "maximum": 10},
    "state": {"type": "integer", "enum": [1, 2, 3], "description": "1=Learning, 2=Review, 3=Relearning"},
    "reps": {"type": "integer"},
    "lapses": {"type": "integer"}
  }
}
```
`[Source: specs/data/fsrs-card.schema.json]`

---

### ADR决策关联 (必填)

| ADR编号 | 决策标题 | 对Story的影响 |
|---------|----------|---------------|
| ADR-008 | 测试框架选型 - pytest生态系统 | 使用pytest编写FSRSManager集成测试，pytest-asyncio用于async方法 |

**关键约束** (from ADR-008):
- 测试文件位置: `backend/tests/unit/` (单元测试), `backend/tests/integration/` (集成测试)
- 覆盖率要求: > 80%
- 异步测试: 使用 `@pytest.mark.asyncio` 装饰器
- Mock LLM: 使用 `pytest-mock` 的 `mocker.patch()`

`[Source: docs/architecture/decisions/ADR-008-TESTING-FRAMEWORK-PYTEST-ECOSYSTEM.md]`

**补充约束**:
- 无需新ADR: FSRS集成使用现有py-fsrs库，不涉及新架构决策
- 数据存储: 复用现有SQLite表结构，FSRS状态存储在`card_data` JSON字段

---

### 核心代码变更指南

**当前实现** (`review_service.py`):
```python
# 当前：使用Ebbinghaus固定间隔 [1, 3, 7, 15, 30]天
async def schedule_review(self, canvas_name: str, trigger_point: int = 1):
    # ... 固定间隔计算
    return {"scheduled_date": datetime.now().isoformat()}
```

**目标实现**:
```python
from src.memory.temporal.fsrs_manager import FSRSManager, get_rating_from_score

class ReviewService:
    def __init__(self, ..., fsrs_manager: Optional[FSRSManager] = None):
        self._fsrs_manager = fsrs_manager or FSRSManager(desired_retention=0.9)
        # ...

    async def record_review_result(
        self,
        canvas_name: str,
        score: float = None,
        rating: int = None,  # 新增：直接接受FSRS rating
        card_state: Optional[str] = None
    ):
        # 兼容性：如果提供score，转换为rating
        if rating is None and score is not None:
            rating = get_rating_from_score(score)

        # 加载或创建FSRS card
        card = (self._fsrs_manager.deserialize_card(card_state)
                if card_state else self._fsrs_manager.create_card())

        # 使用FSRS算法更新card
        updated_card, review_log = self._fsrs_manager.review_card(card, rating)

        return {
            "next_review": self._fsrs_manager.get_due_date(updated_card).isoformat(),
            "interval_days": updated_card.scheduled_days,
            "fsrs_state": {
                "stability": updated_card.stability,
                "difficulty": updated_card.difficulty,
                "state": updated_card.state.name
            },
            "card_data": self._fsrs_manager.serialize_card(updated_card)
        }
```

**Rating Conversion** (`fsrs_manager.py:374-396`):
```python
def get_rating_from_score(score: float) -> int:
    """
    Score → Rating mapping:
    - 0-39: Again (1) - forgot
    - 40-59: Hard (2) - serious difficulty
    - 60-84: Good (3) - hesitation
    - 85-100: Easy (4) - easily recalled
    """
    if score < 40: return 1
    elif score < 60: return 2
    elif score < 85: return 3
    else: return 4
```

---

### 关键文件路径

| 文件 | 作用 | 预计修改行数 |
|------|------|-------------|
| `backend/app/services/review_service.py` | 主要重构目标 | ~150行 |
| `backend/app/api/v1/endpoints/review.py` | API端点更新 | ~30行 |
| `src/memory/temporal/fsrs_manager.py` | FSRS实现 (只读参考) | 0行 |
| `backend/tests/unit/test_review_service_fsrs.py` | 新建测试文件 | ~200行 |

---

### Testing

**测试框架**: pytest + pytest-asyncio + pytest-mock

**测试文件位置**: `backend/tests/unit/test_review_service_fsrs.py`

**必需测试用例**:

```python
# test_review_service_fsrs.py

@pytest.mark.asyncio
async def test_fsrs_manager_integration():
    """AC-32.2.1: FSRSManager properly integrated"""
    service = ReviewService(..., fsrs_manager=FSRSManager())
    assert service._fsrs_manager is not None

@pytest.mark.asyncio
async def test_record_review_with_rating():
    """AC-32.2.2: Direct FSRS rating input"""
    result = await service.record_review_result(
        canvas_name="test.canvas",
        rating=3  # Good
    )
    assert result["fsrs_state"]["state"] in ["Learning", "Review"]

@pytest.mark.asyncio
async def test_dynamic_interval_calculation():
    """AC-32.2.3: FSRS calculates dynamic interval"""
    # First review (rating=Good) should give ~1 day
    result1 = await service.record_review_result(rating=3)

    # Load card and review again with Easy should increase interval
    result2 = await service.record_review_result(
        rating=4, card_state=result1["card_data"]
    )
    assert result2["interval_days"] > result1["interval_days"]

@pytest.mark.asyncio
async def test_backward_compatibility_score():
    """AC-32.2.4: Score-based input still works"""
    result = await service.record_review_result(score=75)  # Should map to Good (3)
    assert "fsrs_state" in result

@pytest.mark.parametrize("score,expected_rating", [
    (0, 1), (39, 1),    # Again
    (40, 2), (59, 2),   # Hard
    (60, 3), (84, 3),   # Good
    (85, 4), (100, 4),  # Easy
])
def test_rating_conversion(score, expected_rating):
    """Rating boundary conditions"""
    from src.memory.temporal.fsrs_manager import get_rating_from_score
    assert get_rating_from_score(score) == expected_rating
```

**运行命令**:
```bash
# 运行所有FSRS相关测试
pytest backend/tests/unit/test_review_service_fsrs.py -v

# 运行覆盖率报告
pytest backend/tests/unit/test_review_service_fsrs.py --cov=backend/app/services/review_service --cov-report=term-missing
```

---

### Phase-Aware SoT Context

```yaml
sot_context:
  detected_phase: "Phase 4 (Implementation)"
  priority_source: "OpenAPI Spec + JSON Schema"
  conflicts_found: [1]
  resolutions: [1]
  note: "Backend has 70+ Python files - specs are authoritative"
```

---

### Conflict Resolutions (Step 8d)

| # | Conflict | Decision | Action | Resolved By | Timestamp |
|---|----------|----------|--------|-------------|-----------|
| 1 | OpenAPI vs JSON Schema: `fsrs_state.state` field type (string enum vs integer enum) | A (Accept SoT) | Update `review-api.openapi.yml` to use `integer enum [1, 2, 3]` matching `fsrs-card.schema.json` | User | 2026-01-20 |

**Resolution Details**:
- **Document A** (OpenAPI Level 4): `state: type: string, enum: [New, Learning, Review, Relearning]`
- **Document B** (JSON Schema Level 3): `state: type: integer, enum: [1, 2, 3]`
- **SoT Hierarchy**: JSON Schema (Level 3) > OpenAPI (Level 4)
- **Action Required**: Update `specs/api/review-api.openapi.yml` lines ~459, ~593 (tracked in Story 32.7)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-19 | 0.1 | Initial story creation with ultrathink deep analysis | SM Agent (Bob) |
| 2026-01-20 | 0.2 | PO validation fixes: (1) state enum integer type per JSON Schema, (2) Story 32.1 prerequisite note, (3) backward-compat score field documentation | PO Agent (Sarah) |
| 2026-01-20 | 0.3 | PO validation PASS: Step 8d conflict resolved (OpenAPI state enum → integer), added Conflict Resolutions section, readiness score 8/10, status GO | PO Agent (Sarah) |

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.6 (Story 32.8 documentation fix)

### Debug Log References
No debug issues. Implementation verified by QA (Quinn) on 2026-01-26 and re-verified on 2026-01-30.

### Completion Notes List
- FSRS integration into ReviewService completed: FSRSManager replaces EbbinghausReviewScheduler
- FSRS ratings (1-4) supported with backward-compatible score (0-100) conversion
- Dynamic interval calculation via FSRS-4.5 algorithm
- Card state persistence via in-memory cache + API response
- 20/20 unit tests pass in test_review_service_fsrs.py

### File List
- `backend/app/services/review_service.py` (modified - FSRS integration ~150 lines)
- `backend/app/api/v1/endpoints/review.py` (modified - FSRS rating endpoint)
- `backend/tests/unit/test_review_service_fsrs.py` (new - 20 test cases)
- `src/memory/temporal/fsrs_manager.py` (reference only, no changes)

---

## QA Results

### Gate Decision: **PASS** ✅

**Reviewer**: Quinn (Test Architect)
**Review Date**: 2026-01-26
**Gate File**: `docs/qa/gates/32.2-fsrs-integration.yml`

---

### AC Verification Summary

| AC | Description | Status | Evidence |
|----|-------------|--------|----------|
| AC-32.2.1 | FSRSManager import and dependency injection | ✅ PASS | `review_service.py:72-88`, `fsrs_manager.py` |
| AC-32.2.2 | FSRS rating parameter (1-4) support | ✅ PASS | `review.py:588-667`, 4 tests pass |
| AC-32.2.3 | Dynamic interval calculation | ✅ PASS | FSRS algorithm implementation, 3 tests pass |
| AC-32.2.4 | Backward compatibility (score→rating) | ✅ PASS | Conversion: <40→1, 40-59→2, 60-84→3, >=85→4 |
| AC-32.2.5 | Migration documentation | ✅ PASS | `review_service.py:12-59` docstring |

---

### Test Results

```
Tests: 20/20 passed
File: backend/tests/unit/test_review_service_fsrs.py
Runtime: 4.40s
```

**Test Classes Verified**:
- `TestFSRSImport` (3 tests) - AC-32.2.1
- `TestFSRSRatings` (4 tests) - AC-32.2.2
- `TestScoreToRatingConversion` (4 tests) - AC-32.2.4
- `TestDynamicIntervalCalculation` (3 tests) - AC-32.2.3
- `TestCardStatePersistence` (2 tests) - AC-32.2.4
- `TestFSRSStateResponse` (1 test) - AC-32.2.2
- `TestMigrationDocumentation` (2 tests) - AC-32.2.5
- `TestAlgorithmField` (1 test) - Integration

---

### NFR Validation

| NFR | Status | Notes |
|-----|--------|-------|
| Security | ✅ PASS | No new security surface exposed |
| Performance | ✅ PASS | FSRS calculation O(1) per card |
| Reliability | ✅ PASS | Fallback to Ebbinghaus when FSRS unavailable |
| Maintainability | ✅ PASS | Clean FSRSManager abstraction |

---

### Issues Identified

| ID | Severity | Finding | Suggested Action |
|----|----------|---------|------------------|
| DOC-001 | Low | Story status is 'Draft' but implementation complete | Update status to 'Done', fill File List |
| DOC-002 | Low | Dev Agent Record section empty | Document implementation decisions |

---

### Files Reviewed

- `backend/app/services/review_service.py` - FSRS integration
- `backend/app/api/v1/endpoints/review.py` - API endpoint
- `src/memory/temporal/fsrs_manager.py` - FSRSManager implementation
- `backend/tests/unit/test_review_service_fsrs.py` - 20 unit tests

---

### Review Date: 2026-01-30

### Reviewed By: Quinn (Test Architect)

### Re-Verification Review

本次审查是对 2026-01-26 审查的再次验证，确认实现状态。

### Test Execution Results

```
pytest backend/tests/unit/test_review_service_fsrs.py -v
Tests: 20/20 passed ✅
Runtime: ~4s
```

**测试类覆盖**:
- `TestFSRSImport` (3 tests) - AC-32.2.1 ✅
- `TestFSRSRatings` (4 tests) - AC-32.2.2 ✅
- `TestScoreToRatingConversion` (4 tests) - AC-32.2.4 ✅
- `TestDynamicIntervalCalculation` (3 tests) - AC-32.2.3 ✅
- `TestCardStatePersistence` (2 tests) - AC-32.2.4 ✅
- `TestFSRSStateResponse` (1 test) - AC-32.2.2 ✅
- `TestMigrationDocumentation` (2 tests) - AC-32.2.5 ✅
- `TestAlgorithmField` (1 test) - Integration ✅

### Compliance Check (Re-verified)

- Coding Standards: ✓ 符合 Python 代码规范
- Project Structure: ✓ 文件位置正确
- Testing Strategy: ✓ pytest + pytest-asyncio
- All ACs Met: ✓ 5/5 AC 全部通过

### Outstanding Documentation Issues

以下问题在初次审查时已记录，尚未解决：

- [ ] **DOC-001**: Story status 仍为 "Draft"，应更新为 "Done"
- [ ] **DOC-002**: Dev Agent Record 部分仍为空
- [ ] **DOC-003**: File List 部分仍为空

### Gate Status

Gate: **PASS** (confirmed) → `docs/qa/gates/32.2-fsrs-integration.yml`

### Recommended Status

✓ Ready for Done

建议 Story Owner 更新以下内容后将状态改为 Done:
1. 填写 Dev Agent Record 部分
2. 填写 File List 部分
3. 将 Status 从 "Draft" 改为 "Done"
