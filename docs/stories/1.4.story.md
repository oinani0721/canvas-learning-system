# Story 1.4: Canvasè¾¹ï¼ˆEdgeï¼‰æ“ä½œ

## Status
Done

## Story

**As a** ç³»ç»Ÿæ ¸å¿ƒæ¨¡å—,
**I want** èƒ½å¤Ÿåˆ›å»ºå’Œç®¡ç†è¿æ¥è¾¹ï¼ˆEdgeï¼‰ï¼Œ
**so that** æˆ‘å¯ä»¥è¡¨è¾¾èŠ‚ç‚¹ä¹‹é—´çš„å…³ç³»ï¼Œä¸ºCanvasçš„å¯è§†åŒ–ç»“æ„æä¾›è¿æ¥èƒ½åŠ›ã€‚

## Acceptance Criteria

1. create_edge()èƒ½åˆ›å»ºæœ‰æ•ˆçš„è¾¹å¯¹è±¡
2. æ”¯æŒè®¾ç½®fromSideå’ŒtoSideï¼ˆtop/right/bottom/leftï¼‰
3. æ”¯æŒè®¾ç½®è¾¹çš„labelå±æ€§
4. æ”¯æŒè®¾ç½®è¾¹çš„é¢œè‰²
5. Edge IDç”Ÿæˆè§„åˆ™ï¼š`edge-[fromNodeIdå‰8ä½]-[toNodeIdå‰8ä½]-[timestamp]`
6. update_edge()èƒ½ä¿®æ”¹è¾¹çš„å±æ€§ï¼ˆlabelã€é¢œè‰²ç­‰ï¼‰
7. delete_edge()èƒ½æ ¹æ®IDåˆ é™¤è¾¹
8. find_edges_by_node()èƒ½æŸ¥æ‰¾ä¸æŒ‡å®šèŠ‚ç‚¹ç›¸å…³çš„æ‰€æœ‰è¾¹

## Tasks / Subtasks

- [x] Task 1: å®ç°generate_edge_idé™æ€æ–¹æ³• (AC: 5)
  - [x] æå–fromNode IDçš„å‰8ä½
  - [x] æå–toNode IDçš„å‰8ä½
  - [x] ç”Ÿæˆ6ä½æ—¶é—´æˆ³ï¼ˆUnixæ—¶é—´æˆ³å6ä½ï¼‰
  - [x] è¿”å›æ ¼å¼ï¼š`edge-{from8}-{to8}-{timestamp6}`
  - [x] æ·»åŠ å®Œæ•´çš„ç±»å‹æ³¨è§£å’ŒGoogle Style Docstring

- [x] Task 2: å®ç°create_edgeé™æ€æ–¹æ³• (AC: 1, 2, 3, 4)
  - [x] å¿…éœ€å‚æ•°ï¼šcanvas_data, from_node, to_node
  - [x] å¯é€‰å‚æ•°ï¼šfrom_side, to_side, label, color
  - [x] éªŒè¯fromNodeå’ŒtoNodeå­˜åœ¨äºcanvas_dataä¸­
  - [x] éªŒè¯from_sideå’Œto_sideçš„å€¼ï¼ˆtop/right/bottom/leftï¼‰
  - [x] ä½¿ç”¨generate_edge_idç”Ÿæˆå”¯ä¸€è¾¹ID
  - [x] æ„å»ºè¾¹å¯¹è±¡ï¼ˆåŒ…å«id, fromNode, toNode, fromSide, toSideï¼‰
  - [x] æ·»åŠ å¯é€‰å­—æ®µï¼ˆlabel, colorï¼‰
  - [x] æ·»åŠ è¾¹åˆ°canvas_data["edges"]æ•°ç»„
  - [x] è¿”å›æ–°åˆ›å»ºçš„è¾¹ID

- [x] Task 3: å®ç°update_edgeé™æ€æ–¹æ³• (AC: 6)
  - [x] æ¥å—å‚æ•°ï¼šcanvas_data, edge_id, updatesï¼ˆå­—å…¸ï¼‰
  - [x] æŸ¥æ‰¾æŒ‡å®šIDçš„è¾¹
  - [x] éªŒè¯æ›´æ–°å­—æ®µçš„æœ‰æ•ˆæ€§
  - [x] æ›´æ–°è¾¹çš„å±æ€§
  - [x] å¦‚æœè¾¹ä¸å­˜åœ¨ï¼ŒæŠ›å‡ºKeyError

- [x] Task 4: å®ç°delete_edgeé™æ€æ–¹æ³• (AC: 7)
  - [x] æ¥å—å‚æ•°ï¼šcanvas_data, edge_id
  - [x] ä»edgesæ•°ç»„ä¸­åˆ é™¤æŒ‡å®šè¾¹
  - [x] å¦‚æœè¾¹ä¸å­˜åœ¨ï¼ŒæŠ›å‡ºKeyError
  - [x] è¿”å›åˆ é™¤æ˜¯å¦æˆåŠŸ

- [x] Task 5: å®ç°find_edges_by_nodeé™æ€æ–¹æ³• (AC: 8)
  - [x] æ¥å—å‚æ•°ï¼šcanvas_data, node_id, directionï¼ˆå¯é€‰ï¼š"from", "to", "both"ï¼‰
  - [x] direction="from": è¿”å›fromNodeåŒ¹é…çš„è¾¹
  - [x] direction="to": è¿”å›toNodeåŒ¹é…çš„è¾¹
  - [x] direction="both": è¿”å›fromNodeæˆ–toNodeåŒ¹é…çš„è¾¹ï¼ˆé»˜è®¤ï¼‰
  - [x] è¿”å›è¾¹åˆ—è¡¨ï¼ˆList[Dict]ï¼‰

- [x] Task 6: å®ç°è¾…åŠ©æŸ¥è¯¢æ–¹æ³•
  - [x] find_edge_by_id(canvas_data, edge_id) - æ ¹æ®IDæŸ¥æ‰¾å•ä¸ªè¾¹
  - [x] edge_exists(canvas_data, edge_id) - æ£€æŸ¥è¾¹æ˜¯å¦å­˜åœ¨
  - [x] get_all_edge_ids(canvas_data) - è·å–æ‰€æœ‰è¾¹IDåˆ—è¡¨
  - [x] find_edge_between_nodes(canvas_data, from_node, to_node) - æŸ¥æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„è¾¹

- [x] Task 7: æ·»åŠ è¾¹ç›¸å…³å¸¸é‡å®šä¹‰ (ALL AC)
  - [x] å®šä¹‰VALID_SIDES = ["top", "right", "bottom", "left"]
  - [x] å®šä¹‰DEFAULT_FROM_SIDE = "right"
  - [x] å®šä¹‰DEFAULT_TO_SIDE = "left"
  - [x] å®šä¹‰è¾¹æ ‡ç­¾å¸¸é‡ï¼ˆLABEL_DECOMPOSE, LABEL_UNDERSTANDINGç­‰ï¼‰

- [x] Task 8: å•å…ƒæµ‹è¯• (ALL AC)
  - [x] æµ‹è¯•generate_edge_idçš„IDæ ¼å¼å’Œå”¯ä¸€æ€§
  - [x] æµ‹è¯•create_edgeåˆ›å»ºæœ‰æ•ˆè¾¹
  - [x] æµ‹è¯•create_edgeè®¾ç½®fromSideå’ŒtoSide
  - [x] æµ‹è¯•create_edgeè®¾ç½®labelå’Œcolor
  - [x] æµ‹è¯•create_edgeéªŒè¯èŠ‚ç‚¹å­˜åœ¨æ€§
  - [x] æµ‹è¯•create_edgeéªŒè¯sideå€¼æœ‰æ•ˆæ€§
  - [x] æµ‹è¯•update_edgeæˆåŠŸæ›´æ–°å’Œé”™è¯¯å¤„ç†
  - [x] æµ‹è¯•delete_edgeæˆåŠŸåˆ é™¤å’Œé”™è¯¯å¤„ç†
  - [x] æµ‹è¯•find_edges_by_nodeçš„ä¸‰ç§directionæ¨¡å¼
  - [x] æµ‹è¯•è¾…åŠ©æŸ¥è¯¢æ–¹æ³•
  - [x] ç¡®ä¿æµ‹è¯•è¦†ç›–ç‡â‰¥90%

## Dev Notes

### Previous Story Insights

ä»Story 1.1ã€1.2ã€1.3ä¸­å­¦åˆ°çš„ç»éªŒï¼š

- âœ… **é™æ€æ–¹æ³•è®¾è®¡**ï¼šLayer 1çš„æ‰€æœ‰æ–¹æ³•éƒ½åº”è¯¥æ˜¯é™æ€æ–¹æ³•ï¼Œæ— çŠ¶æ€è®¾è®¡ï¼Œä¾¿äºè°ƒç”¨å’Œæµ‹è¯•
- âœ… **ä¼˜é›…é™çº§**ï¼šå¯¹äºè¾¹ç•Œæƒ…å†µï¼Œåº”æä¾›æ˜ç¡®çš„é”™è¯¯æ¶ˆæ¯è€Œä¸æ˜¯é™é»˜å¤±è´¥
- âœ… **ç±»å‹æ³¨è§£**ï¼šå®Œæ•´çš„ç±»å‹æ³¨è§£ï¼ˆåŒ…æ‹¬Dict, List, Optionalç­‰ï¼‰æå¤§æå‡ä»£ç å¯è¯»æ€§
- âœ… **Google Style Docstring**ï¼šè¯¦ç»†çš„æ–‡æ¡£å­—ç¬¦ä¸²åŒ…æ‹¬Argsã€Returnsã€Raisesã€Example
- âœ… **æ€§èƒ½ä¼˜å¼‚**ï¼šå‰ä¸‰ä¸ªStoryçš„å®é™…æ€§èƒ½è¿œè¶…è¦æ±‚ï¼Œä¿æŒè¿™ç§æ ‡å‡†
- âœ… **é”™è¯¯å¤„ç†**ï¼šæ˜ç¡®çš„é”™è¯¯ç±»å‹å’Œæœ‰æ„ä¹‰çš„é”™è¯¯æ¶ˆæ¯
- âœ… **å¸¸é‡åŒ–è®¾è®¡**ï¼šå°†æ‰€æœ‰é­”æ³•å€¼å®šä¹‰ä¸ºå¸¸é‡ï¼Œæé«˜å¯ç»´æŠ¤æ€§
- âœ… **èŠ‚ç‚¹IDéªŒè¯**ï¼šåœ¨åˆ›å»ºè¾¹ä¹‹å‰éªŒè¯èŠ‚ç‚¹å­˜åœ¨æ€§ï¼Œé¿å…åˆ›å»ºæ— æ•ˆè¾¹

### æ¶æ„ä¸Šä¸‹æ–‡

**3å±‚æ¶æ„è®¾è®¡** [Source: architecture/canvas-3-layer-architecture.md#æ¶æ„æ¦‚è¿°]

æœ¬Storyç»§ç»­å®ç°Layer 1ï¼ˆCanvasJSONOperatorï¼‰çš„è¾¹æ“ä½œåŠŸèƒ½ã€‚3å±‚æ¶æ„å¦‚ä¸‹ï¼š

```
Layer 3: CanvasOrchestrator (é«˜çº§æ¥å£) â† Sub-agentsè°ƒç”¨
Layer 2: CanvasBusinessLogic (ä¸šåŠ¡é€»è¾‘)
Layer 1: CanvasJSONOperator (åº•å±‚JSONæ“ä½œ) â† æœ¬Storyå®ç°æ­¤å±‚
```

**Layer 1èŒè´£ï¼š**
- Canvas JSONæ–‡ä»¶çš„è¯»å†™ï¼ˆStory 1.1å·²å®ç°ï¼‰
- èŠ‚ç‚¹å…³ç³»å›¾æ„å»ºï¼ˆStory 1.2å·²å®ç°ï¼‰
- èŠ‚ç‚¹çš„CRUDæ“ä½œï¼ˆStory 1.3å·²å®ç°ï¼‰
- **è¾¹çš„CRUDæ“ä½œï¼ˆæœ¬Storyå®ç°ï¼‰**
- ä¸åŒ…å«ä»»ä½•ä¸šåŠ¡é€»è¾‘
- çº¯å‡½æ•°å¼ï¼Œæ— çŠ¶æ€ï¼ˆæ‰€æœ‰æ–¹æ³•éƒ½æ˜¯é™æ€æ–¹æ³•ï¼‰

### æ•°æ®æ¨¡å‹

**Canvas JSONè¾¹ï¼ˆEdgeï¼‰ç»“æ„** [Source: architecture/tech-stack.md#æ–‡ä»¶æ ¼å¼è§„èŒƒ]

```json
{
  "id": "string",
  "fromNode": "string",
  "toNode": "string",
  "fromSide": "top" | "right" | "bottom" | "left",
  "toSide": "top" | "right" | "bottom" | "left",
  "label": "string (optional)",
  "color": "string (optional)"
}
```

**è¾¹å­—æ®µè¯´æ˜ï¼š**
- **id**ï¼šè¾¹çš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œæ ¼å¼ï¼š`edge-[fromNodeIdå‰8ä½]-[toNodeIdå‰8ä½]-[timestamp6]`
- **fromNode**ï¼šæºèŠ‚ç‚¹IDï¼ˆå¿…éœ€ï¼‰
- **toNode**ï¼šç›®æ ‡èŠ‚ç‚¹IDï¼ˆå¿…éœ€ï¼‰
- **fromSide**ï¼šæºèŠ‚ç‚¹çš„è¿æ¥ä¾§ï¼ˆtop/right/bottom/leftï¼Œé»˜è®¤rightï¼‰
- **toSide**ï¼šç›®æ ‡èŠ‚ç‚¹çš„è¿æ¥ä¾§ï¼ˆtop/right/bottom/leftï¼Œé»˜è®¤leftï¼‰
- **label**ï¼šè¾¹çš„æ ‡ç­¾æ–‡æœ¬ï¼ˆå¯é€‰ï¼Œå¦‚"æ‹†è§£è‡ª"ã€"ä¸ªäººç†è§£"ï¼‰
- **color**ï¼šè¾¹çš„é¢œè‰²ç¼–ç ï¼ˆå¯é€‰ï¼Œ"1"-"6"ï¼‰

**Edge IDç”Ÿæˆè§„åˆ™** [Source: docs/prd/FULL-PRD-REFERENCE.md#Story 1.4]

æ ¹æ®PRDè¦æ±‚ï¼Œè¾¹IDå¿…é¡»éµå¾ªä»¥ä¸‹æ ¼å¼ï¼š
```
edge-[fromNodeIdå‰8ä½]-[toNodeIdå‰8ä½]-[timestamp6]
```

ç¤ºä¾‹ï¼š
- fromNode: "text-a1b2c3d4e5f67890"
- toNode: "text-x9y8z7w6v5u4t3s2"
- æ—¶é—´æˆ³å6ä½: "123456"
- ç”Ÿæˆçš„è¾¹ID: "edge-a1b2c3d4-x9y8z7w6-123456"

**è¿æ¥ç‚¹ä½ç½®ï¼ˆSideï¼‰** [Source: architecture/canvas-3-layer-architecture.md#Layer 2]

è¾¹çš„è¿æ¥ç‚¹ä½ç½®å†³å®šäº†è¿æ¥çº¿ä»å“ªä¸ªæ–¹å‘è¿›å‡ºèŠ‚ç‚¹ï¼š
- `"top"`: èŠ‚ç‚¹é¡¶éƒ¨
- `"right"`: èŠ‚ç‚¹å³ä¾§
- `"bottom"`: èŠ‚ç‚¹åº•éƒ¨
- `"left"`: èŠ‚ç‚¹å·¦ä¾§

**å¸¸è§è¿æ¥æ¨¡å¼**ï¼š
- çºµå‘å…³ç³»ï¼š`fromSide="bottom"`, `toSide="top"` (çˆ¶â†’å­é—®é¢˜)
- æ¨ªå‘å…³ç³»ï¼š`fromSide="right"`, `toSide="left"` (é—®é¢˜â†’ç†è§£èŠ‚ç‚¹)

**è¾¹æ ‡ç­¾çº¦å®š** [Source: docs/prd/FULL-PRD-REFERENCE.md#UIè®¾è®¡]

ç³»ç»Ÿä½¿ç”¨ä»¥ä¸‹æ ‡ç­¾è¡¨è¾¾å…³ç³»ï¼š
- `"æ‹†è§£è‡ª"`: çˆ¶é—®é¢˜â†’å­é—®é¢˜
- `"ä¸ªäººç†è§£"`: é—®é¢˜â†’é»„è‰²èŠ‚ç‚¹
- `"è¡¥å……è§£é‡Š"`: é—®é¢˜â†’è“è‰²è¯´æ˜èŠ‚ç‚¹
- `"æ¥æº"`: æ£€éªŒç™½æ¿é—®é¢˜â†’åŸç™½æ¿èŠ‚ç‚¹

### API Specifications

**Edge IDç”Ÿæˆæ–¹æ³•ç­¾å**

```python
@staticmethod
def generate_edge_id(from_node_id: str, to_node_id: str) -> str:
    """ç”Ÿæˆå”¯ä¸€çš„è¾¹ID

    æ ¼å¼ï¼šedge-[fromNodeIdå‰8ä½]-[toNodeIdå‰8ä½]-[timestamp6]

    Args:
        from_node_id: æºèŠ‚ç‚¹ID
        to_node_id: ç›®æ ‡èŠ‚ç‚¹ID

    Returns:
        str: æ ¼å¼åŒ–çš„è¾¹ID

    Example:
        >>> CanvasJSONOperator.generate_edge_id(
        ...     "text-a1b2c3d4e5f67890",
        ...     "text-x9y8z7w6v5u4t3s2"
        ... )
        "edge-a1b2c3d4-x9y8z7w6-123456"
    """
    # æå–èŠ‚ç‚¹IDå‰ç¼€åçš„å‰8ä½
    from_prefix = from_node_id.split('-', 1)[1][:8]
    to_prefix = to_node_id.split('-', 1)[1][:8]

    # ç”Ÿæˆæ—¶é—´æˆ³å6ä½
    import time
    timestamp = str(int(time.time()))[-6:]

    return f"edge-{from_prefix}-{to_prefix}-{timestamp}"
```

**create_edgeæ–¹æ³•ç­¾å**

```python
@staticmethod
def create_edge(
    canvas_data: Dict[str, Any],
    from_node: str,
    to_node: str,
    from_side: str = "right",
    to_side: str = "left",
    label: Optional[str] = None,
    color: Optional[str] = None
) -> str:
    """åˆ›å»ºè¾¹å¹¶æ·»åŠ åˆ°canvas_data

    Args:
        canvas_data: Canvas JSONæ•°æ®
        from_node: æºèŠ‚ç‚¹ID
        to_node: ç›®æ ‡èŠ‚ç‚¹ID
        from_side: æºèŠ‚ç‚¹è¿æ¥ä¾§ï¼ˆtop/right/bottom/leftï¼Œé»˜è®¤rightï¼‰
        to_side: ç›®æ ‡èŠ‚ç‚¹è¿æ¥ä¾§ï¼ˆtop/right/bottom/leftï¼Œé»˜è®¤leftï¼‰
        label: è¾¹æ ‡ç­¾ï¼ˆå¯é€‰ï¼‰
        color: è¾¹é¢œè‰²ç¼–ç ï¼ˆå¯é€‰ï¼Œ"1"-"6"ï¼‰

    Returns:
        str: æ–°åˆ›å»ºçš„è¾¹ID

    Raises:
        ValueError: å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨æˆ–sideå€¼æ— æ•ˆ

    Example:
        >>> canvas_data = {"nodes": [...], "edges": []}
        >>> edge_id = CanvasJSONOperator.create_edge(
        ...     canvas_data,
        ...     from_node="text-abc123",
        ...     to_node="text-xyz789",
        ...     from_side="right",
        ...     to_side="left",
        ...     label="æ‹†è§£è‡ª"
        ... )
        >>> print(f"åˆ›å»ºäº†è¾¹: {edge_id}")
    """
    pass
```

**update_edgeæ–¹æ³•ç­¾å**

```python
@staticmethod
def update_edge(
    canvas_data: Dict[str, Any],
    edge_id: str,
    updates: Dict[str, Any]
) -> None:
    """æ›´æ–°è¾¹çš„å±æ€§

    Args:
        canvas_data: Canvas JSONæ•°æ®
        edge_id: è¾¹ID
        updates: è¦æ›´æ–°çš„å­—æ®µå­—å…¸ï¼ˆå¦‚{"label": "æ–°æ ‡ç­¾", "color": "2"}ï¼‰

    Raises:
        KeyError: å¦‚æœè¾¹IDä¸å­˜åœ¨
        ValueError: å¦‚æœæ›´æ–°å­—æ®µæ— æ•ˆ

    Example:
        >>> CanvasJSONOperator.update_edge(
        ...     canvas_data,
        ...     "edge-a1b2c3d4-x9y8z7w6-123456",
        ...     {"label": "ä¸ªäººç†è§£", "color": "6"}
        ... )
    """
    pass
```

**delete_edgeæ–¹æ³•ç­¾å**

```python
@staticmethod
def delete_edge(
    canvas_data: Dict[str, Any],
    edge_id: str
) -> bool:
    """åˆ é™¤è¾¹

    Args:
        canvas_data: Canvas JSONæ•°æ®
        edge_id: è¦åˆ é™¤çš„è¾¹ID

    Returns:
        bool: æ˜¯å¦æˆåŠŸåˆ é™¤

    Raises:
        KeyError: å¦‚æœè¾¹IDä¸å­˜åœ¨

    Example:
        >>> success = CanvasJSONOperator.delete_edge(
        ...     canvas_data,
        ...     "edge-a1b2c3d4-x9y8z7w6-123456"
        ... )
        >>> print(f"åˆ é™¤{'æˆåŠŸ' if success else 'å¤±è´¥'}")
    """
    pass
```

**find_edges_by_nodeæ–¹æ³•ç­¾å**

```python
@staticmethod
def find_edges_by_node(
    canvas_data: Dict[str, Any],
    node_id: str,
    direction: str = "both"
) -> List[Dict[str, Any]]:
    """æŸ¥æ‰¾ä¸æŒ‡å®šèŠ‚ç‚¹ç›¸å…³çš„è¾¹

    Args:
        canvas_data: Canvas JSONæ•°æ®
        node_id: èŠ‚ç‚¹ID
        direction: æŸ¥æ‰¾æ–¹å‘ï¼ˆ"from"=ä½œä¸ºæºèŠ‚ç‚¹, "to"=ä½œä¸ºç›®æ ‡èŠ‚ç‚¹, "both"=ä¸¤è€…çš†å¯ï¼Œé»˜è®¤bothï¼‰

    Returns:
        List[Dict[str, Any]]: åŒ¹é…çš„è¾¹åˆ—è¡¨

    Example:
        >>> # æŸ¥æ‰¾ä»æŸèŠ‚ç‚¹å‡ºå‘çš„æ‰€æœ‰è¾¹
        >>> outgoing_edges = CanvasJSONOperator.find_edges_by_node(
        ...     canvas_data,
        ...     "text-abc123",
        ...     direction="from"
        ... )
        >>> print(f"æ‰¾åˆ°{len(outgoing_edges)}æ¡å‡ºè¾¹")

        >>> # æŸ¥æ‰¾ä¸æŸèŠ‚ç‚¹ç›¸å…³çš„æ‰€æœ‰è¾¹
        >>> all_edges = CanvasJSONOperator.find_edges_by_node(
        ...     canvas_data,
        ...     "text-abc123",
        ...     direction="both"
        ... )
    """
    pass
```

### æ–‡ä»¶ä½ç½®

**ä»£ç æ–‡ä»¶** [Source: architecture/tech-stack.md#é¡¹ç›®ç»“æ„]
- ä¿®æ”¹æ–‡ä»¶ï¼š`C:/Users/ROG/æ‰˜ç¦/canvas_utils.py`ï¼ˆé¡¹ç›®æ ¹ç›®å½•ï¼‰
- åœ¨ç°æœ‰çš„CanvasJSONOperatorç±»ä¸­æ·»åŠ è¾¹æ“ä½œçš„é™æ€æ–¹æ³•
- Story 1.1å·²åˆ›å»ºæ­¤æ–‡ä»¶ï¼ŒStory 1.2å·²æ·»åŠ å…³ç³»å›¾æ–¹æ³•ï¼ŒStory 1.3å·²æ·»åŠ èŠ‚ç‚¹CRUD

**é¡¹ç›®ç»“æ„**
```
C:/Users/ROG/æ‰˜ç¦/
â”œâ”€â”€ canvas_utils.py        # â­ æœ¬Storyä¿®æ”¹æ­¤æ–‡ä»¶
â”‚                          #    åœ¨CanvasJSONOperatorç±»ä¸­æ·»åŠ è¾¹æ“ä½œæ–¹æ³•
â””â”€â”€ tests/
    â””â”€â”€ test_canvas_utils.py  # â­ æœ¬Storyæ·»åŠ æ–°æµ‹è¯•ç”¨ä¾‹
```

### ç¼–ç è§„èŒƒ

**PEP 8è§„èŒƒ** [Source: architecture/coding-standards.md#Pythonç¼–ç è§„èŒƒ]
- ä½¿ç”¨4ä¸ªç©ºæ ¼ç¼©è¿›
- æ¯è¡Œæœ€å¤š79å­—ç¬¦
- ä½¿ç”¨UTF-8ç¼–ç 
- ç±»åï¼šPascalCaseï¼ˆå¦‚ CanvasJSONOperatorï¼‰
- å‡½æ•°åï¼šsnake_caseï¼ˆå¦‚ create_edge, delete_edgeï¼‰
- å¸¸é‡ï¼šUPPER_SNAKE_CASEï¼ˆå¦‚ VALID_SIDES, DEFAULT_FROM_SIDEï¼‰

**ç±»å‹æ³¨è§£ï¼ˆå¼ºåˆ¶ï¼‰** [Source: architecture/coding-standards.md#ç±»å‹æ³¨è§£]
```python
from typing import Dict, List, Optional, Any

@staticmethod
def create_edge(
    canvas_data: Dict[str, Any],
    from_node: str,
    to_node: str,
    from_side: str = "right",
    to_side: str = "left",
    label: Optional[str] = None,
    color: Optional[str] = None
) -> str:
    """åˆ›å»ºè¾¹"""
    pass
```

**æ–‡æ¡£å­—ç¬¦ä¸²ï¼ˆGoogle Styleï¼‰** [Source: architecture/coding-standards.md#æ–‡æ¡£å­—ç¬¦ä¸²]
- å¿…é¡»åŒ…å«ï¼šç®€çŸ­æè¿°ã€Argsã€Returns
- å¯é€‰åŒ…å«ï¼šRaisesã€Example
- ç¤ºä¾‹åº”æ¸…æ™°å±•ç¤ºç”¨æ³•

**é”™è¯¯å¤„ç†åŸåˆ™** [Source: architecture/coding-standards.md#é”™è¯¯å¤„ç†]
- æ˜ç¡®çš„é”™è¯¯ç±»å‹ï¼ˆValueErrorã€KeyErrorç­‰ï¼‰
- æœ‰æ„ä¹‰çš„é”™è¯¯æ¶ˆæ¯
- åŒ…å«ä¸Šä¸‹æ–‡ä¿¡æ¯

ç¤ºä¾‹ï¼š
```python
# éªŒè¯èŠ‚ç‚¹å­˜åœ¨
if not node_exists(canvas_data, from_node):
    raise ValueError(
        f"æºèŠ‚ç‚¹ä¸å­˜åœ¨: {from_node}ã€‚"
        f"è¯·ç¡®ä¿èŠ‚ç‚¹IDæ­£ç¡®ã€‚"
    )

# éªŒè¯sideå€¼
if from_side not in VALID_SIDES:
    raise ValueError(
        f"æ— æ•ˆçš„fromSideå€¼: {from_side}ã€‚"
        f"æ”¯æŒçš„å€¼: {', '.join(VALID_SIDES)}"
    )

# è¾¹ä¸å­˜åœ¨
edge = find_edge_by_id(canvas_data, edge_id)
if edge is None:
    raise KeyError(
        f"è¾¹ä¸å­˜åœ¨: {edge_id}"
    )
```

**å¸¸é‡å®šä¹‰** [Source: architecture/coding-standards.md#å¸¸é‡å®šä¹‰]

åœ¨canvas_utils.pyä¸­æ·»åŠ è¾¹ç›¸å…³å¸¸é‡ï¼ˆåœ¨ç°æœ‰å¸¸é‡åé¢ï¼‰ï¼š
```python
# è¾¹è¿æ¥ä¾§
VALID_SIDES = ["top", "right", "bottom", "left"]
DEFAULT_FROM_SIDE = "right"
DEFAULT_TO_SIDE = "left"

# è¾¹æ ‡ç­¾å¸¸é‡
LABEL_DECOMPOSE = "æ‹†è§£è‡ª"      # çˆ¶é—®é¢˜â†’å­é—®é¢˜
LABEL_UNDERSTANDING = "ä¸ªäººç†è§£"  # é—®é¢˜â†’é»„è‰²èŠ‚ç‚¹
LABEL_EXPLANATION = "è¡¥å……è§£é‡Š"    # é—®é¢˜â†’è“è‰²è¯´æ˜èŠ‚ç‚¹
LABEL_SOURCE = "æ¥æº"            # æ£€éªŒç™½æ¿â†’åŸç™½æ¿
```

### å®ç°æŒ‡å¯¼

**generate_edge_idå®ç°æ€è·¯**

```python
import time

@staticmethod
def generate_edge_id(from_node_id: str, to_node_id: str) -> str:
    """ç”Ÿæˆå”¯ä¸€çš„è¾¹ID

    å®ç°æ€è·¯ï¼š
    1. ä»fromNode IDä¸­æå–å‰ç¼€åçš„å‰8ä½
    2. ä»toNode IDä¸­æå–å‰ç¼€åçš„å‰8ä½
    3. è·å–å½“å‰Unixæ—¶é—´æˆ³çš„å6ä½
    4. ç»„åˆæˆï¼šedge-{from8}-{to8}-{timestamp6}
    """
    # 1. æå–fromNodeçš„å‰8ä½ï¼ˆå»æ‰ç±»å‹å‰ç¼€ï¼‰
    # ç¤ºä¾‹ï¼štext-a1b2c3d4e5f67890 â†’ a1b2c3d4
    from_parts = from_node_id.split('-', 1)
    from_prefix = from_parts[1][:8] if len(from_parts) > 1 else from_node_id[:8]

    # 2. æå–toNodeçš„å‰8ä½
    to_parts = to_node_id.split('-', 1)
    to_prefix = to_parts[1][:8] if len(to_parts) > 1 else to_node_id[:8]

    # 3. è·å–æ—¶é—´æˆ³å6ä½
    timestamp = str(int(time.time()))[-6:]

    # 4. ç»„åˆè¾¹ID
    return f"edge-{from_prefix}-{to_prefix}-{timestamp}"
```

**create_edgeå®ç°æ€è·¯**

```python
@staticmethod
def create_edge(
    canvas_data: Dict[str, Any],
    from_node: str,
    to_node: str,
    from_side: str = "right",
    to_side: str = "left",
    label: Optional[str] = None,
    color: Optional[str] = None
) -> str:
    """åˆ›å»ºè¾¹å¹¶æ·»åŠ åˆ°canvas_data

    å®ç°æ€è·¯ï¼š
    1. éªŒè¯fromNodeå­˜åœ¨
    2. éªŒè¯toNodeå­˜åœ¨
    3. éªŒè¯from_sideå’Œto_sideæœ‰æ•ˆæ€§
    4. éªŒè¯coloræœ‰æ•ˆæ€§ï¼ˆå¦‚æœæä¾›ï¼‰
    5. ç”Ÿæˆè¾¹ID
    6. æ„å»ºè¾¹å¯¹è±¡
    7. æ·»åŠ åˆ°canvas_data["edges"]
    8. è¿”å›è¾¹ID
    """
    # 1. éªŒè¯æºèŠ‚ç‚¹å­˜åœ¨
    if not node_exists(canvas_data, from_node):
        raise ValueError(f"æºèŠ‚ç‚¹ä¸å­˜åœ¨: {from_node}")

    # 2. éªŒè¯ç›®æ ‡èŠ‚ç‚¹å­˜åœ¨
    if not node_exists(canvas_data, to_node):
        raise ValueError(f"ç›®æ ‡èŠ‚ç‚¹ä¸å­˜åœ¨: {to_node}")

    # 3. éªŒè¯sideå€¼
    if from_side not in VALID_SIDES:
        raise ValueError(
            f"æ— æ•ˆçš„fromSideå€¼: {from_side}ã€‚"
            f"æ”¯æŒçš„å€¼: {', '.join(VALID_SIDES)}"
        )
    if to_side not in VALID_SIDES:
        raise ValueError(
            f"æ— æ•ˆçš„toSideå€¼: {to_side}ã€‚"
            f"æ”¯æŒçš„å€¼: {', '.join(VALID_SIDES)}"
        )

    # 4. éªŒè¯é¢œè‰²ï¼ˆå¦‚æœæä¾›ï¼‰
    if color is not None and color not in VALID_COLORS:
        raise ValueError(f"æ— æ•ˆçš„é¢œè‰²ç¼–ç : {color}")

    # 5. ç”Ÿæˆè¾¹ID
    edge_id = generate_edge_id(from_node, to_node)

    # 6. æ„å»ºè¾¹å¯¹è±¡
    edge = {
        "id": edge_id,
        "fromNode": from_node,
        "toNode": to_node,
        "fromSide": from_side,
        "toSide": to_side
    }

    # æ·»åŠ å¯é€‰å­—æ®µ
    if label is not None:
        edge["label"] = label
    if color is not None:
        edge["color"] = color

    # 7. æ·»åŠ åˆ°Canvas
    canvas_data["edges"].append(edge)

    # 8. è¿”å›ID
    return edge_id
```

**find_edges_by_nodeå®ç°æ€è·¯**

```python
@staticmethod
def find_edges_by_node(
    canvas_data: Dict[str, Any],
    node_id: str,
    direction: str = "both"
) -> List[Dict[str, Any]]:
    """æŸ¥æ‰¾ä¸æŒ‡å®šèŠ‚ç‚¹ç›¸å…³çš„è¾¹

    å®ç°æ€è·¯ï¼š
    1. éªŒè¯directionå‚æ•°æœ‰æ•ˆæ€§
    2. æ ¹æ®directionè¿‡æ»¤edgesæ•°ç»„
    3. è¿”å›åŒ¹é…çš„è¾¹åˆ—è¡¨
    """
    # 1. éªŒè¯direction
    valid_directions = ["from", "to", "both"]
    if direction not in valid_directions:
        raise ValueError(
            f"æ— æ•ˆçš„directionå€¼: {direction}ã€‚"
            f"æ”¯æŒçš„å€¼: {', '.join(valid_directions)}"
        )

    # 2. è¿‡æ»¤è¾¹
    edges = canvas_data.get("edges", [])
    result = []

    for edge in edges:
        if direction == "from" and edge.get("fromNode") == node_id:
            result.append(edge)
        elif direction == "to" and edge.get("toNode") == node_id:
            result.append(edge)
        elif direction == "both" and (
            edge.get("fromNode") == node_id or edge.get("toNode") == node_id
        ):
            result.append(edge)

    # 3. è¿”å›ç»“æœ
    return result
```

**è¾…åŠ©æ–¹æ³•å®ç°**

```python
@staticmethod
def find_edge_by_id(
    canvas_data: Dict[str, Any],
    edge_id: str
) -> Optional[Dict[str, Any]]:
    """æ ¹æ®IDæŸ¥æ‰¾è¾¹

    Returns:
        Optional[Dict]: æ‰¾åˆ°çš„è¾¹ï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›None
    """
    for edge in canvas_data.get("edges", []):
        if edge.get("id") == edge_id:
            return edge
    return None

@staticmethod
def edge_exists(
    canvas_data: Dict[str, Any],
    edge_id: str
) -> bool:
    """æ£€æŸ¥è¾¹æ˜¯å¦å­˜åœ¨"""
    return find_edge_by_id(canvas_data, edge_id) is not None

@staticmethod
def get_all_edge_ids(
    canvas_data: Dict[str, Any]
) -> List[str]:
    """è·å–æ‰€æœ‰è¾¹IDåˆ—è¡¨"""
    return [edge.get("id") for edge in canvas_data.get("edges", [])]

@staticmethod
def find_edge_between_nodes(
    canvas_data: Dict[str, Any],
    from_node: str,
    to_node: str
) -> Optional[Dict[str, Any]]:
    """æŸ¥æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„è¾¹

    Returns:
        Optional[Dict]: æ‰¾åˆ°çš„ç¬¬ä¸€æ¡è¾¹ï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›None
    """
    for edge in canvas_data.get("edges", []):
        if (edge.get("fromNode") == from_node and
            edge.get("toNode") == to_node):
            return edge
    return None
```

### Testing

**æµ‹è¯•æ–‡ä»¶ä½ç½®** [Source: architecture/coding-standards.md#æµ‹è¯•è§„èŒƒ]
- æµ‹è¯•æ–‡ä»¶è·¯å¾„ï¼š`tests/test_canvas_utils.py`
- åœ¨ç°æœ‰æµ‹è¯•ç±»TestCanvasJSONOperatorä¸­æ·»åŠ æ–°æµ‹è¯•æ–¹æ³•

**æµ‹è¯•æ¡†æ¶å’Œå·¥å…·**
- ä¸»æµ‹è¯•æ¡†æ¶ï¼špytestï¼ˆStory 1.1å·²å®‰è£…ï¼‰
- è¦†ç›–ç‡å·¥å…·ï¼špytest-cov
- å®‰è£…å‘½ä»¤ï¼š`pip install pytest pytest-cov`ï¼ˆå·²å®‰è£…ï¼‰

**æµ‹è¯•æ ‡å‡†**
- Layer 1 (CanvasJSONOperator) è¦†ç›–ç‡ç›®æ ‡ï¼šâ‰¥ 90%
- æ‰€æœ‰å…¬å…±æ–¹æ³•å¿…é¡»æœ‰æµ‹è¯•ç”¨ä¾‹
- æ‰€æœ‰é”™è¯¯å¤„ç†è·¯å¾„å¿…é¡»æœ‰æµ‹è¯•è¦†ç›–

**è¿è¡Œå‘½ä»¤**
```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
pytest tests/test_canvas_utils.py

# è¿è¡Œæµ‹è¯•å¹¶ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
pytest --cov=canvas_utils tests/test_canvas_utils.py

# ç”ŸæˆHTMLæ ¼å¼çš„è¯¦ç»†è¦†ç›–ç‡æŠ¥å‘Š
pytest --cov=canvas_utils --cov-report=html tests/test_canvas_utils.py
```

**æœ¬Storyçš„æµ‹è¯•è¦æ±‚**

å¿…é¡»æµ‹è¯•çš„åœºæ™¯ï¼š

1. **Edge IDç”Ÿæˆæµ‹è¯•**
   - æµ‹è¯•IDæ ¼å¼æ­£ç¡®ï¼ˆ"edge-{from8}-{to8}-{timestamp6}"ï¼‰
   - æµ‹è¯•æå–èŠ‚ç‚¹IDå‰8ä½çš„é€»è¾‘
   - æµ‹è¯•æ—¶é—´æˆ³å6ä½çš„æå–

2. **create_edgeæµ‹è¯•**
   - æµ‹è¯•åˆ›å»ºæœ‰æ•ˆè¾¹
   - æµ‹è¯•è®¾ç½®fromSideå’ŒtoSide
   - æµ‹è¯•è®¾ç½®labelå’Œcolor
   - æµ‹è¯•fromNodeä¸å­˜åœ¨æŠ›å‡ºValueError
   - æµ‹è¯•toNodeä¸å­˜åœ¨æŠ›å‡ºValueError
   - æµ‹è¯•æ— æ•ˆfromSideæŠ›å‡ºValueError
   - æµ‹è¯•æ— æ•ˆtoSideæŠ›å‡ºValueError
   - æµ‹è¯•æ— æ•ˆé¢œè‰²ç¼–ç æŠ›å‡ºValueError

3. **update_edgeæµ‹è¯•**
   - æµ‹è¯•æˆåŠŸæ›´æ–°è¾¹çš„label
   - æµ‹è¯•æˆåŠŸæ›´æ–°è¾¹çš„color
   - æµ‹è¯•æ›´æ–°å¤šä¸ªå­—æ®µ
   - æµ‹è¯•è¾¹ä¸å­˜åœ¨æŠ›å‡ºKeyError

4. **delete_edgeæµ‹è¯•**
   - æµ‹è¯•æˆåŠŸåˆ é™¤è¾¹
   - æµ‹è¯•åˆ é™¤åè¾¹ä¸å†å­˜åœ¨
   - æµ‹è¯•è¾¹ä¸å­˜åœ¨æŠ›å‡ºKeyError

5. **find_edges_by_nodeæµ‹è¯•**
   - æµ‹è¯•direction="from"åªè¿”å›å‡ºè¾¹
   - æµ‹è¯•direction="to"åªè¿”å›å…¥è¾¹
   - æµ‹è¯•direction="both"è¿”å›æ‰€æœ‰ç›¸å…³è¾¹
   - æµ‹è¯•èŠ‚ç‚¹æ²¡æœ‰ç›¸å…³è¾¹æ—¶è¿”å›ç©ºåˆ—è¡¨
   - æµ‹è¯•æ— æ•ˆdirectionæŠ›å‡ºValueError

6. **è¾…åŠ©æ–¹æ³•æµ‹è¯•**
   - æµ‹è¯•find_edge_by_idæ‰¾åˆ°è¾¹
   - æµ‹è¯•find_edge_by_idæœªæ‰¾åˆ°è¿”å›None
   - æµ‹è¯•edge_existsæ£€æŸ¥
   - æµ‹è¯•get_all_edge_idsè¿”å›æ‰€æœ‰ID
   - æµ‹è¯•find_edge_between_nodesæ‰¾åˆ°è¾¹
   - æµ‹è¯•find_edge_between_nodesæœªæ‰¾åˆ°è¿”å›None

**æµ‹è¯•ç”¨ä¾‹ç¤ºä¾‹ï¼š**

```python
import pytest
from canvas_utils import CanvasJSONOperator

class TestCanvasJSONOperator:
    """æµ‹è¯•CanvasJSONOperatorç±»"""

    # ... å‰é¢çš„æµ‹è¯•ï¼ˆStory 1.1, 1.2, 1.3ï¼‰

    def test_generate_edge_id_format(self):
        """æµ‹è¯•è¾¹IDæ ¼å¼æ­£ç¡®"""
        from_node = "text-a1b2c3d4e5f67890"
        to_node = "text-x9y8z7w6v5u4t3s2"

        edge_id = CanvasJSONOperator.generate_edge_id(from_node, to_node)

        # éªŒè¯æ ¼å¼
        assert edge_id.startswith("edge-")
        parts = edge_id.split('-')
        assert len(parts) == 4  # edge, from8, to8, timestamp6
        assert parts[1] == "a1b2c3d4"  # fromå‰8ä½
        assert parts[2] == "x9y8z7w6"  # toå‰8ä½
        assert len(parts[3]) == 6  # æ—¶é—´æˆ³6ä½

    def test_create_edge_success(self):
        """æµ‹è¯•æˆåŠŸåˆ›å»ºè¾¹"""
        canvas_data = {
            "nodes": [
                {"id": "text-abc123", "type": "text", "x": 0, "y": 0},
                {"id": "text-xyz789", "type": "text", "x": 100, "y": 100}
            ],
            "edges": []
        }

        edge_id = CanvasJSONOperator.create_edge(
            canvas_data,
            from_node="text-abc123",
            to_node="text-xyz789",
            from_side="right",
            to_side="left",
            label="æ‹†è§£è‡ª"
        )

        assert edge_id.startswith("edge-")
        assert len(canvas_data["edges"]) == 1

        edge = canvas_data["edges"][0]
        assert edge["id"] == edge_id
        assert edge["fromNode"] == "text-abc123"
        assert edge["toNode"] == "text-xyz789"
        assert edge["fromSide"] == "right"
        assert edge["toSide"] == "left"
        assert edge["label"] == "æ‹†è§£è‡ª"

    def test_create_edge_from_node_not_found(self):
        """æµ‹è¯•æºèŠ‚ç‚¹ä¸å­˜åœ¨æŠ›å‡ºå¼‚å¸¸"""
        canvas_data = {
            "nodes": [
                {"id": "text-xyz789", "type": "text", "x": 100, "y": 100}
            ],
            "edges": []
        }

        with pytest.raises(ValueError) as exc_info:
            CanvasJSONOperator.create_edge(
                canvas_data,
                from_node="nonexistent",
                to_node="text-xyz789"
            )

        assert "æºèŠ‚ç‚¹ä¸å­˜åœ¨" in str(exc_info.value)

    def test_create_edge_invalid_from_side(self):
        """æµ‹è¯•æ— æ•ˆfromSideæŠ›å‡ºå¼‚å¸¸"""
        canvas_data = {
            "nodes": [
                {"id": "text-abc123", "type": "text", "x": 0, "y": 0},
                {"id": "text-xyz789", "type": "text", "x": 100, "y": 100}
            ],
            "edges": []
        }

        with pytest.raises(ValueError) as exc_info:
            CanvasJSONOperator.create_edge(
                canvas_data,
                from_node="text-abc123",
                to_node="text-xyz789",
                from_side="invalid"
            )

        assert "æ— æ•ˆçš„fromSideå€¼" in str(exc_info.value)

    def test_update_edge_success(self):
        """æµ‹è¯•æˆåŠŸæ›´æ–°è¾¹"""
        canvas_data = {
            "nodes": [],
            "edges": [
                {
                    "id": "edge-abc123-xyz789-123456",
                    "fromNode": "text-abc123",
                    "toNode": "text-xyz789",
                    "fromSide": "right",
                    "toSide": "left"
                }
            ]
        }

        CanvasJSONOperator.update_edge(
            canvas_data,
            "edge-abc123-xyz789-123456",
            {"label": "ä¸ªäººç†è§£", "color": "6"}
        )

        edge = canvas_data["edges"][0]
        assert edge["label"] == "ä¸ªäººç†è§£"
        assert edge["color"] == "6"

    def test_update_edge_not_found(self):
        """æµ‹è¯•æ›´æ–°ä¸å­˜åœ¨çš„è¾¹æŠ›å‡ºå¼‚å¸¸"""
        canvas_data = {"nodes": [], "edges": []}

        with pytest.raises(KeyError):
            CanvasJSONOperator.update_edge(
                canvas_data,
                "nonexistent",
                {"label": "test"}
            )

    def test_delete_edge_success(self):
        """æµ‹è¯•æˆåŠŸåˆ é™¤è¾¹"""
        canvas_data = {
            "nodes": [],
            "edges": [
                {
                    "id": "edge-abc123-xyz789-123456",
                    "fromNode": "text-abc123",
                    "toNode": "text-xyz789"
                }
            ]
        }

        success = CanvasJSONOperator.delete_edge(
            canvas_data,
            "edge-abc123-xyz789-123456"
        )

        assert success is True
        assert len(canvas_data["edges"]) == 0

    def test_delete_edge_not_found(self):
        """æµ‹è¯•åˆ é™¤ä¸å­˜åœ¨çš„è¾¹æŠ›å‡ºå¼‚å¸¸"""
        canvas_data = {"nodes": [], "edges": []}

        with pytest.raises(KeyError):
            CanvasJSONOperator.delete_edge(canvas_data, "nonexistent")

    def test_find_edges_by_node_from(self):
        """æµ‹è¯•æŸ¥æ‰¾å‡ºè¾¹ï¼ˆdirection=fromï¼‰"""
        canvas_data = {
            "nodes": [],
            "edges": [
                {"id": "edge1", "fromNode": "text-abc", "toNode": "text-def"},
                {"id": "edge2", "fromNode": "text-abc", "toNode": "text-ghi"},
                {"id": "edge3", "fromNode": "text-xyz", "toNode": "text-abc"}
            ]
        }

        edges = CanvasJSONOperator.find_edges_by_node(
            canvas_data,
            "text-abc",
            direction="from"
        )

        assert len(edges) == 2
        assert edges[0]["id"] == "edge1"
        assert edges[1]["id"] == "edge2"

    def test_find_edges_by_node_to(self):
        """æµ‹è¯•æŸ¥æ‰¾å…¥è¾¹ï¼ˆdirection=toï¼‰"""
        canvas_data = {
            "nodes": [],
            "edges": [
                {"id": "edge1", "fromNode": "text-abc", "toNode": "text-def"},
                {"id": "edge2", "fromNode": "text-abc", "toNode": "text-ghi"},
                {"id": "edge3", "fromNode": "text-xyz", "toNode": "text-abc"}
            ]
        }

        edges = CanvasJSONOperator.find_edges_by_node(
            canvas_data,
            "text-abc",
            direction="to"
        )

        assert len(edges) == 1
        assert edges[0]["id"] == "edge3"

    def test_find_edges_by_node_both(self):
        """æµ‹è¯•æŸ¥æ‰¾æ‰€æœ‰ç›¸å…³è¾¹ï¼ˆdirection=bothï¼‰"""
        canvas_data = {
            "nodes": [],
            "edges": [
                {"id": "edge1", "fromNode": "text-abc", "toNode": "text-def"},
                {"id": "edge2", "fromNode": "text-abc", "toNode": "text-ghi"},
                {"id": "edge3", "fromNode": "text-xyz", "toNode": "text-abc"}
            ]
        }

        edges = CanvasJSONOperator.find_edges_by_node(
            canvas_data,
            "text-abc",
            direction="both"
        )

        assert len(edges) == 3

    def test_find_edge_by_id_found(self):
        """æµ‹è¯•æ ¹æ®IDæŸ¥æ‰¾è¾¹æˆåŠŸ"""
        canvas_data = {
            "nodes": [],
            "edges": [
                {"id": "edge1", "fromNode": "text-abc", "toNode": "text-def"}
            ]
        }

        edge = CanvasJSONOperator.find_edge_by_id(canvas_data, "edge1")

        assert edge is not None
        assert edge["id"] == "edge1"

    def test_find_edge_by_id_not_found(self):
        """æµ‹è¯•æ ¹æ®IDæŸ¥æ‰¾è¾¹å¤±è´¥è¿”å›None"""
        canvas_data = {"nodes": [], "edges": []}

        edge = CanvasJSONOperator.find_edge_by_id(canvas_data, "nonexistent")

        assert edge is None

    def test_edge_exists(self):
        """æµ‹è¯•è¾¹å­˜åœ¨æ€§æ£€æŸ¥"""
        canvas_data = {
            "nodes": [],
            "edges": [
                {"id": "edge1", "fromNode": "text-abc", "toNode": "text-def"}
            ]
        }

        assert CanvasJSONOperator.edge_exists(canvas_data, "edge1") is True
        assert CanvasJSONOperator.edge_exists(canvas_data, "nonexistent") is False

    def test_get_all_edge_ids(self):
        """æµ‹è¯•è·å–æ‰€æœ‰è¾¹ID"""
        canvas_data = {
            "nodes": [],
            "edges": [
                {"id": "edge1", "fromNode": "text-abc", "toNode": "text-def"},
                {"id": "edge2", "fromNode": "text-ghi", "toNode": "text-jkl"}
            ]
        }

        edge_ids = CanvasJSONOperator.get_all_edge_ids(canvas_data)

        assert len(edge_ids) == 2
        assert "edge1" in edge_ids
        assert "edge2" in edge_ids

    def test_find_edge_between_nodes_found(self):
        """æµ‹è¯•æŸ¥æ‰¾ä¸¤èŠ‚ç‚¹é—´çš„è¾¹æˆåŠŸ"""
        canvas_data = {
            "nodes": [],
            "edges": [
                {"id": "edge1", "fromNode": "text-abc", "toNode": "text-def"},
                {"id": "edge2", "fromNode": "text-ghi", "toNode": "text-jkl"}
            ]
        }

        edge = CanvasJSONOperator.find_edge_between_nodes(
            canvas_data,
            "text-abc",
            "text-def"
        )

        assert edge is not None
        assert edge["id"] == "edge1"

    def test_find_edge_between_nodes_not_found(self):
        """æµ‹è¯•æŸ¥æ‰¾ä¸¤èŠ‚ç‚¹é—´çš„è¾¹å¤±è´¥è¿”å›None"""
        canvas_data = {
            "nodes": [],
            "edges": [
                {"id": "edge1", "fromNode": "text-abc", "toNode": "text-def"}
            ]
        }

        edge = CanvasJSONOperator.find_edge_between_nodes(
            canvas_data,
            "text-xyz",
            "text-uvw"
        )

        assert edge is None
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | åˆå§‹Storyåˆ›å»º | SM Agent (Bob) |
| 2025-10-14 | 1.1 | å®ç°å®Œæˆï¼šæ·»åŠ è¾¹æ“ä½œæ–¹æ³•å’Œè¾…åŠ©æŸ¥è¯¢ï¼Œæ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼ˆè¦†ç›–ç‡99%ï¼‰ï¼ŒçŠ¶æ€æ›´æ–°ä¸ºReady for Review | Dev Agent (James) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
æ— è°ƒè¯•é—®é¢˜ã€‚æ‰€æœ‰æµ‹è¯•ä¸€æ¬¡æ€§é€šè¿‡ã€‚

### Completion Notes
- âœ… æˆåŠŸæ·»åŠ è¾¹ç›¸å…³å¸¸é‡å®šä¹‰ï¼ˆVALID_SIDES, DEFAULT_FROM_SIDE, DEFAULT_TO_SIDE, æ ‡ç­¾å¸¸é‡ï¼‰
- âœ… å®ç° generate_edge_id æ–¹æ³•ï¼ˆæ ¼å¼ï¼šedge-{from8}-{to8}-{timestamp6}ï¼‰
- âœ… å®ç° create_edge æ–¹æ³•ï¼ˆæ”¯æŒè®¾ç½®fromSide/toSide/label/colorï¼Œå®Œæ•´å‚æ•°éªŒè¯ï¼‰
- âœ… å®ç° update_edge æ–¹æ³•ï¼ˆæ”¯æŒæ›´æ–°å¤šä¸ªå­—æ®µï¼ŒéªŒè¯æ›´æ–°å†…å®¹æœ‰æ•ˆæ€§ï¼‰
- âœ… å®ç° delete_edge æ–¹æ³•ï¼ˆæˆåŠŸåˆ é™¤å¹¶è¿”å›å¸ƒå°”å€¼ï¼‰
- âœ… å®ç° find_edges_by_node æ–¹æ³•ï¼ˆæ”¯æŒä¸‰ç§directionæ¨¡å¼ï¼šfrom/to/bothï¼‰
- âœ… å®ç°å››ä¸ªè¾…åŠ©æŸ¥è¯¢æ–¹æ³•ï¼šfind_edge_by_idã€edge_existsã€get_all_edge_idsã€find_edge_between_nodes
- âœ… å®Œæ•´çš„ç±»å‹æ³¨è§£ï¼ˆDict, List, Optional, boolï¼‰å’ŒGoogle Style Docstring
- âœ… æ‰€æœ‰æ–¹æ³•éƒ½æœ‰æ¸…æ™°çš„é”™è¯¯å¤„ç†ï¼ˆValueErrorã€KeyErrorï¼‰
- âœ… æµ‹è¯•è¦†ç›–ç‡ï¼š99%ï¼ˆè¿œè¶…90%ç›®æ ‡ï¼‰
- âœ… æ–°å¢32ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå…¨éƒ¨é€šè¿‡ï¼ˆæ€»è®¡87ä¸ªæµ‹è¯•ï¼‰
- âœ… æ‰€æœ‰8ä¸ªéªŒæ”¶æ ‡å‡† (AC1-AC8) å‡å·²æ»¡è¶³
- âœ… å®Œå…¨éµå¾ªPEP 8è§„èŒƒå’Œé¡¹ç›®ç¼–ç æ ‡å‡†

### File List
**ä¿®æ”¹çš„æ–‡ä»¶ï¼š**
- `canvas_utils.py` - åœ¨CanvasJSONOperatorç±»ä¸­æ·»åŠ 9ä¸ªæ–°æ–¹æ³•ï¼š
  - generate_edge_id (ç”Ÿæˆè¾¹ID)
  - create_edge (åˆ›å»ºè¾¹)
  - update_edge (æ›´æ–°è¾¹)
  - delete_edge (åˆ é™¤è¾¹)
  - find_edges_by_node (æŒ‰èŠ‚ç‚¹æŸ¥æ‰¾è¾¹)
  - find_edge_by_id (æŒ‰IDæŸ¥æ‰¾è¾¹)
  - edge_exists (æ£€æŸ¥è¾¹å­˜åœ¨)
  - get_all_edge_ids (è·å–æ‰€æœ‰è¾¹ID)
  - find_edge_between_nodes (æŸ¥æ‰¾ä¸¤èŠ‚ç‚¹é—´çš„è¾¹)
- `canvas_utils.py` - æ·»åŠ è¾¹ç›¸å…³å¸¸é‡å®šä¹‰ï¼ˆSIDE_*, VALID_SIDES, DEFAULT_*, LABEL_*ï¼‰
- `tests/test_canvas_utils.py` - æ·»åŠ 32ä¸ªæ–°æµ‹è¯•ç”¨ä¾‹ï¼ˆStory 1.4ç›¸å…³ï¼‰

**æ–°åˆ›å»ºçš„æ–‡ä»¶ï¼š**
- æ— 

## QA Results

### Review Date: 2025-10-14

### Reviewed By: Quinn (Senior Developer QA)

### Code Quality Assessment

**Overall: EXCELLENT** - The edge operations implementation demonstrates professional-grade code quality with exceptional attention to detail. The developer followed all architectural patterns from previous stories and delivered production-ready code on the first attempt.

**Strengths:**
- **Architecture**: Perfect adherence to Layer 1 design - pure functions, stateless static methods, no business logic
- **Type Safety**: Complete type annotations with proper use of `Optional`, `Dict[str, Any]`, `List`, and `bool`
- **Documentation**: Exemplary Google Style docstrings with clear Args, Returns, Raises, and practical Examples
- **Error Handling**: Thoughtful validation with meaningful error messages that include context for debugging
- **Code Consistency**: Maintains patterns established in Stories 1.1-1.3, making the codebase highly maintainable
- **Test Quality**: Comprehensive test coverage including edge cases, error paths, and boundary conditions

**Edge ID Generation**: Clever implementation using node ID extraction and timestamp - ensures uniqueness while maintaining readability.

### Refactoring Performed

- **File**: `tests/test_canvas_utils.py`
  - **Change**: Added `test_update_edge_invalid_to_side()` test method (lines 1301-1323)
  - **Why**: Line 885 in `canvas_utils.py` (toSide validation in update_edge) was untested, representing a gap in coverage
  - **How**: Added comprehensive test case matching the pattern of `test_update_edge_invalid_from_side`, ensuring the toSide validation logic is properly exercised. This brings test coverage from 99% to 100%.

### Compliance Check

- **Coding Standards**: âœ“ PASS
  - PEP 8 compliant (4-space indent, 79-char lines, UTF-8 encoding)
  - Naming: PascalCase classes, snake_case functions, UPPER_SNAKE_CASE constants
  - Complete type annotations on all methods
  - Google Style docstrings with Args/Returns/Raises/Examples

- **Project Structure**: âœ“ PASS
  - Implementation in correct location (`canvas_utils.py`)
  - Tests in correct location (`tests/test_canvas_utils.py`)
  - No unnecessary file creation
  - Proper integration with existing CanvasJSONOperator class

- **Testing Strategy**: âœ“ PASS
  - Initial coverage: 99% (87 tests)
  - **After QA refactoring: 100% (88 tests)** ğŸ¯
  - All public methods tested
  - All error handling paths covered
  - pytest + pytest-cov framework used correctly

- **All ACs Met**: âœ“ PASS
  - AC1 (create_edge creates valid edges): âœ“
  - AC2 (fromSide/toSide support): âœ“
  - AC3 (label support): âœ“
  - AC4 (color support): âœ“
  - AC5 (Edge ID format): âœ“ `edge-{from8}-{to8}-{timestamp6}`
  - AC6 (update_edge): âœ“
  - AC7 (delete_edge): âœ“
  - AC8 (find_edges_by_node): âœ“

### Improvements Checklist

- [x] Added missing test case for toSide validation in update_edge (`tests/test_canvas_utils.py`)
- [x] Achieved 100% test coverage (upgraded from 99%)
- [x] Verified all 88 tests passing
- [x] Validated Edge ID format against specification
- [x] Confirmed proper error handling for all validation paths
- [x] Verified constants usage (sets for O(1) lookups)
- [x] Confirmed PEP 8 compliance (line length, naming, indentation)

**No outstanding improvement items** - all quality checks passed.

### Security Review

**âœ“ No security concerns identified**

- Input validation: All user inputs (node IDs, side values, colors) are validated before use
- No SQL injection risk: Pure JSON operations, no database queries
- No path traversal risk: No file system operations in edge methods
- Error messages: Informative without exposing sensitive system details
- Type safety: Strong typing prevents type confusion attacks

### Performance Considerations

**âœ“ Performance is excellent**

- Edge ID generation: O(1) - simple string operations and timestamp
- create_edge: O(n) where n = number of nodes (for validation), O(1) for edge creation
- update_edge: O(e) where e = number of edges (linear search for edge ID)
- delete_edge: O(e) for finding edge, O(1) for removal
- find_edges_by_node: O(e) - single pass through edges array
- Constants: Using sets (VALID_SIDES, VALID_COLORS) for O(1) membership testing

**Optimization opportunities**: None required at current scale. For very large canvases (10K+ edges), could add edge indexing, but current implementation is appropriate for the use case.

### Final Status

**âœ“ Approved - Ready for Done**

This implementation exemplifies senior-level code craftsmanship:
- Zero defects found in functional logic
- Only missing element was a single test case (now added)
- 100% test coverage achieved
- All acceptance criteria fully satisfied
- Exceeds quality standards for Layer 1 implementation

**Recommendation**: Mark story as DONE. This work sets an excellent standard for upcoming Layer 2 and Layer 3 implementations.
