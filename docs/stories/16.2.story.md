# Story 16.2: .canvas-links.json配置管理

## Status
Draft

## Story

**As a** Canvas Learning System用户,
**I want** 通过`.canvas-links.json`文件管理Canvas之间的关联配置,
**so that** 我可以定义、编辑和持久化跨Canvas的知识关联关系，支持离线配置和版本控制。

## Acceptance Criteria

1. `.canvas-links.json`配置文件模式定义完整，符合JSON Schema规范
2. 配置管理器(`src/services/canvas_links_manager.py`)实现CRUD操作
3. 支持单文件模式（每个Canvas一个配置）和集中模式（Vault级别配置）
4. 配置加载支持懒加载和缓存机制，首次加载<100ms
5. 配置变更自动持久化，支持原子写入（防止文件损坏）
6. 支持配置文件的导入/导出功能
7. 与Graphiti同步机制（增量同步，非全量同步）
8. 配置验证器实现，拒绝无效的关联配置
9. 所有代码包含文档来源标注（Context7/Skill验证）

## Tasks / Subtasks

- [ ] Task 1: 定义配置文件Schema (AC: 1, 8)
  - [ ] 创建 `specs/data/canvas-links-config.schema.json`
  - [ ] 定义关联类型枚举（prerequisite, related, extends, references）
  - [ ] 定义单条关联记录结构
  - [ ] 定义配置文件顶层结构（version, associations数组, metadata）
  - [ ] 添加JSON Schema验证规则

- [ ] Task 2: 实现配置管理器核心 (AC: 2, 3)
  - [ ] 创建 `src/services/canvas_links_manager.py`
  - [ ] 实现 `CanvasLinksManager` 类
  - [ ] 实现 `load_config()` 方法（支持单文件/集中模式）
  - [ ] 实现 `save_config()` 方法（原子写入）
  - [ ] 实现 `get_associations()` / `add_association()` / `remove_association()` 方法

- [ ] Task 3: 实现懒加载和缓存机制 (AC: 4)
  - [ ] 实现配置文件懒加载（按需加载）
  - [ ] 实现内存缓存（LRU Cache）
  - [ ] 实现文件变更监听（可选，用于多客户端场景）
  - [ ] 性能测试：首次加载<100ms

- [ ] Task 4: 实现原子写入和错误处理 (AC: 5)
  - [ ] 使用临时文件+重命名模式实现原子写入
  - [ ] 实现写入前备份机制
  - [ ] 实现文件锁防止并发写入冲突
  - [ ] 实现错误恢复机制

- [ ] Task 5: 实现导入/导出功能 (AC: 6)
  - [ ] 实现 `export_config()` 方法（支持JSON/YAML格式）
  - [ ] 实现 `import_config()` 方法（支持合并/覆盖模式）
  - [ ] 实现配置迁移工具（旧版本升级）

- [ ] Task 6: 实现Graphiti同步机制 (AC: 7)
  - [ ] 定义同步状态追踪（last_synced_at字段）
  - [ ] 实现增量同步算法（只同步变更）
  - [ ] 实现冲突检测和解决策略
  - [ ] 与Story 16.3集成点定义

- [ ] Task 7: 实现配置验证器 (AC: 8)
  - [ ] 创建 `src/validators/canvas_links_validator.py`
  - [ ] 实现JSON Schema验证
  - [ ] 实现业务规则验证（如：循环依赖检测）
  - [ ] 实现Canvas路径存在性验证

- [ ] Task 8: 测试和文档 (AC: 9)
  - [ ] 编写单元测试（覆盖率≥90%）
  - [ ] 编写集成测试
  - [ ] 确认所有代码有文档来源标注
  - [ ] 更新API文档

## Dev Notes

### 技术验证报告 (Step 3.6)

**验证完成时间**: 2025-12-02
**验证执行人**: SM Agent
**Quality Gate状态**: Pending

#### 技术栈清单

| 技术栈 | 查询方式 | 验证状态 | 文档位置 |
|--------|---------|---------|----------|
| JSON Schema | Context7 | 待验证 | /json-schema-org/json-schema-spec |
| Pydantic | Context7 | 待验证 | /pydantic/pydantic |
| Graphiti | Local Skill | 待验证 | @graphiti |
| filelock | Context7 | 待验证 | /tox-dev/filelock |

#### 核心API验证待办

**开发前必须验证**:
- [ ] JSON Schema draft-07验证规则 → Context7: /json-schema-org/json-schema-spec
- [ ] Pydantic v2 model_validate() → Context7: /pydantic/pydantic
- [ ] Graphiti add_episode() API → Local Skill: @graphiti
- [ ] filelock FileLock API → Context7: /tox-dev/filelock

### SDD规范参考 (必填)

**API端点规范**:
- `GET /canvas/associations` - 获取所有Canvas关联
  - [Source: specs/api/canvas-api.openapi.yml:454-489]
  - 响应Schema: `CanvasAssociation[]`
- `POST /canvas/associations` - 创建Canvas关联
  - [Source: specs/api/canvas-api.openapi.yml:491-499]
  - 请求Body: `CreateAssociationRequest`

**数据Schema规范**:
- CanvasAssociation:
  - [Source: specs/data/canvas-association.schema.json]
  - 必填字段: `association_id`, `source_canvas`, `target_canvas`, `association_type`
  - 关联类型枚举: `["prerequisite", "related", "extends", "references"]`
  - 可选字段: `description`, `shared_concepts`, `relevance_score`, `bidirectional`, `auto_generated`, `created_at`, `updated_at`

**新增Schema（本Story创建）**:
- CanvasLinksConfig (待创建):
  - 位置: `specs/data/canvas-links-config.schema.json`
  - 结构:
    ```json
    {
      "version": "1.0",
      "mode": "single|centralized",
      "associations": [CanvasAssociation],
      "sync_state": {
        "last_synced_at": "datetime",
        "pending_changes": []
      }
    }
    ```

### ADR决策关联 (必填)

| ADR编号 | 决策标题 | 对Story的影响 |
|---------|----------|---------------|
| ADR-0003 | Graphiti Memory | 同步机制必须与Graphiti知识图谱集成 |
| ADR-0009 | Error Handling策略 | 配置读写错误处理遵循统一模式 |
| ADR-0010 | Logging聚合 | 配置操作日志使用structlog |

**关键约束**:
- 配置文件必须与Graphiti知识图谱保持最终一致性
- 同步冲突时以Graphiti为权威来源（除非用户明确选择本地优先）
- 配置文件格式向后兼容（支持版本迁移）

### 架构设计参考

**架构文档引用**:
- 跨Canvas关联架构: [Source: docs/architecture/cross-canvas-association-architecture.md]
- 关联检测器设计: [Source: docs/architecture/cross-canvas-association-architecture.md:66-157]
- 关联写入机制: [Source: docs/architecture/cross-canvas-association-architecture.md:199-253]

**配置文件结构设计**:
```json
// .canvas-links.json (单Canvas模式)
{
  "$schema": "https://canvas-learning.com/schemas/canvas-links-config.schema.json",
  "version": "1.0",
  "canvas_path": "数学/线性代数.canvas",
  "associations": [
    {
      "association_id": "uuid-here",
      "target_canvas": "数学/离散数学.canvas",
      "association_type": "related",
      "description": "矩阵运算的共同概念",
      "shared_concepts": ["矩阵", "行列式", "线性变换"],
      "relevance_score": 0.85,
      "bidirectional": true,
      "auto_generated": false,
      "created_at": "2025-12-02T10:00:00Z"
    }
  ],
  "sync_state": {
    "last_synced_at": "2025-12-02T10:30:00Z",
    "graphiti_version": "abc123",
    "pending_changes": []
  }
}
```

```json
// .vault-canvas-links.json (集中模式 - Vault根目录)
{
  "$schema": "https://canvas-learning.com/schemas/canvas-links-config.schema.json",
  "version": "1.0",
  "mode": "centralized",
  "canvas_index": {
    "数学/线性代数.canvas": ["assoc-1", "assoc-2"],
    "数学/离散数学.canvas": ["assoc-1", "assoc-3"]
  },
  "associations": [
    // ... 所有关联集中存储
  ]
}
```

### 代码示例库

**配置管理器核心结构**:
```python
# ✅ Pending verification from Context7:/pydantic/pydantic (topic: model validation)
from pydantic import BaseModel, Field
from typing import List, Optional, Literal
from datetime import datetime
from uuid import UUID, uuid4
from pathlib import Path
from functools import lru_cache
import json

class CanvasAssociation(BaseModel):
    """Canvas关联记录 - 遵循 specs/data/canvas-association.schema.json"""
    association_id: UUID = Field(default_factory=uuid4)
    source_canvas: str  # 本Story为单Canvas模式时自动填充
    target_canvas: str
    association_type: Literal["prerequisite", "related", "extends", "references"]
    description: Optional[str] = None
    shared_concepts: List[str] = Field(default_factory=list)
    relevance_score: float = Field(ge=0, le=1, default=0.5)
    bidirectional: bool = False
    auto_generated: bool = False
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: Optional[datetime] = None

class SyncState(BaseModel):
    """同步状态追踪"""
    last_synced_at: Optional[datetime] = None
    graphiti_version: Optional[str] = None
    pending_changes: List[str] = Field(default_factory=list)

class CanvasLinksConfig(BaseModel):
    """配置文件顶层结构"""
    version: str = "1.0"
    mode: Literal["single", "centralized"] = "single"
    canvas_path: Optional[str] = None  # 单Canvas模式时必填
    associations: List[CanvasAssociation] = Field(default_factory=list)
    sync_state: SyncState = Field(default_factory=SyncState)

class CanvasLinksManager:
    """Canvas关联配置管理器"""

    def __init__(self, vault_path: Path):
        self.vault_path = vault_path
        self._cache: dict[str, CanvasLinksConfig] = {}
        self._lock = None  # 待初始化 filelock

    def get_config_path(self, canvas_path: str) -> Path:
        """获取配置文件路径"""
        canvas_file = self.vault_path / canvas_path
        return canvas_file.with_suffix('.canvas-links.json')

    @lru_cache(maxsize=100)
    def load_config(self, canvas_path: str) -> CanvasLinksConfig:
        """
        加载配置文件（带缓存）

        # ✅ Pending verification from Context7:/pydantic/pydantic (topic: model validation)
        """
        config_path = self.get_config_path(canvas_path)

        if not config_path.exists():
            # 创建默认配置
            return CanvasLinksConfig(
                canvas_path=canvas_path
            )

        with open(config_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        return CanvasLinksConfig.model_validate(data)

    def save_config(self, canvas_path: str, config: CanvasLinksConfig) -> None:
        """
        原子写入配置文件

        # ✅ Pending verification from Context7:/tox-dev/filelock (topic: file locking)
        """
        config_path = self.get_config_path(canvas_path)
        temp_path = config_path.with_suffix('.tmp')

        # 原子写入：先写临时文件，再重命名
        with open(temp_path, 'w', encoding='utf-8') as f:
            json.dump(config.model_dump(mode='json'), f, ensure_ascii=False, indent=2)

        temp_path.replace(config_path)  # 原子操作

        # 清除缓存
        self.load_config.cache_clear()
```

**Graphiti同步机制**:
```python
# ✅ Pending verification from Graphiti Skill (SKILL.md - Section: Episodes)
from graphiti_core import Graphiti

class GraphitiSyncManager:
    """Graphiti同步管理器"""

    def __init__(self, graphiti: Graphiti, links_manager: CanvasLinksManager):
        self.graphiti = graphiti
        self.links_manager = links_manager

    async def sync_to_graphiti(self, canvas_path: str) -> None:
        """
        同步本地配置到Graphiti

        [Source: docs/architecture/cross-canvas-association-architecture.md:199-253]
        """
        config = self.links_manager.load_config(canvas_path)

        for assoc in config.associations:
            if str(assoc.association_id) in config.sync_state.pending_changes:
                # 记录为Episode
                episode_content = f"""
                Association: {assoc.source_canvas} -> {assoc.target_canvas}
                Type: {assoc.association_type}
                Concepts: {', '.join(assoc.shared_concepts)}
                """

                await self.graphiti.add_episode(
                    name=f"canvas_link_{assoc.association_id}",
                    episode_body=episode_content,
                    reference_time=assoc.created_at
                )

        # 更新同步状态
        config.sync_state.last_synced_at = datetime.now()
        config.sync_state.pending_changes.clear()
        self.links_manager.save_config(canvas_path, config)
```

**配置验证器**:
```python
# ✅ Pending verification from Context7:/json-schema-org/json-schema-spec (topic: validation)
import jsonschema
from pathlib import Path

class CanvasLinksValidator:
    """配置验证器"""

    def __init__(self, vault_path: Path):
        self.vault_path = vault_path
        self._schema = self._load_schema()

    def _load_schema(self) -> dict:
        """加载JSON Schema"""
        schema_path = Path('specs/data/canvas-links-config.schema.json')
        with open(schema_path, 'r') as f:
            return json.load(f)

    def validate(self, config: dict) -> tuple[bool, list[str]]:
        """
        验证配置文件

        Returns:
            (is_valid, error_messages)
        """
        errors = []

        # JSON Schema验证
        try:
            jsonschema.validate(config, self._schema)
        except jsonschema.ValidationError as e:
            errors.append(f"Schema validation failed: {e.message}")

        # 业务规则验证
        if 'associations' in config:
            for assoc in config['associations']:
                # 验证Canvas路径存在
                target = self.vault_path / assoc['target_canvas']
                if not target.exists():
                    errors.append(f"Target canvas not found: {assoc['target_canvas']}")

                # 检测循环依赖（prerequisite类型）
                if assoc['association_type'] == 'prerequisite':
                    if self._has_circular_dependency(config, assoc):
                        errors.append(f"Circular dependency detected: {assoc['target_canvas']}")

        return len(errors) == 0, errors

    def _has_circular_dependency(self, config: dict, new_assoc: dict) -> bool:
        """检测循环依赖"""
        # 简化实现：检查直接循环
        source = config.get('canvas_path')
        target = new_assoc['target_canvas']

        for assoc in config['associations']:
            if (assoc['target_canvas'] == source and
                assoc.get('source_canvas') == target and
                assoc['association_type'] == 'prerequisite'):
                return True

        return False
```

### 项目结构参考

```
src/
├── services/
│   ├── __init__.py
│   ├── canvas_links_manager.py    # 配置管理器 (Story 16.2)
│   └── graphiti_sync_manager.py   # Graphiti同步 (Story 16.2 + 16.3)
├── validators/
│   ├── __init__.py
│   └── canvas_links_validator.py  # 配置验证器 (Story 16.2)
└── models/
    ├── __init__.py
    └── canvas_links.py            # Pydantic模型 (Story 16.2)

specs/data/
├── canvas-association.schema.json  # 已存在
└── canvas-links-config.schema.json # 新增 (Story 16.2)
```

[Source: docs/architecture/project-structure.md]

### Testing

**测试文件位置**: `src/tests/test_canvas_links_manager.py`

**测试标准**:
- 使用pytest框架
- 测试覆盖率≥90%
- 包含单元测试和集成测试

**本Story测试要求**:
- 测试配置文件CRUD操作
- 测试懒加载和缓存机制
- 测试原子写入和错误恢复
- 测试JSON Schema验证
- 测试循环依赖检测
- 测试Graphiti同步（使用mock）

**测试用例示例**:
```python
import pytest
from pathlib import Path
from src.services.canvas_links_manager import CanvasLinksManager, CanvasAssociation

class TestCanvasLinksManager:
    @pytest.fixture
    def manager(self, tmp_path):
        """创建测试用管理器"""
        vault = tmp_path / "test_vault"
        vault.mkdir()
        (vault / "test.canvas").write_text('{"nodes":[],"edges":[]}')
        return CanvasLinksManager(vault)

    def test_load_default_config(self, manager):
        """测试加载默认配置"""
        config = manager.load_config("test.canvas")
        assert config.version == "1.0"
        assert config.associations == []

    def test_add_association(self, manager):
        """测试添加关联"""
        config = manager.load_config("test.canvas")

        assoc = CanvasAssociation(
            target_canvas="other.canvas",
            association_type="related",
            shared_concepts=["概念A", "概念B"]
        )
        config.associations.append(assoc)

        manager.save_config("test.canvas", config)

        # 重新加载验证
        manager.load_config.cache_clear()
        loaded = manager.load_config("test.canvas")
        assert len(loaded.associations) == 1
        assert loaded.associations[0].target_canvas == "other.canvas"

    def test_atomic_write(self, manager, tmp_path):
        """测试原子写入（中断恢复）"""
        # 模拟写入中断...
        pass

    def test_cache_performance(self, manager):
        """测试缓存性能 - 首次加载<100ms"""
        import time
        start = time.time()
        manager.load_config("test.canvas")
        elapsed = (time.time() - start) * 1000
        assert elapsed < 100, f"首次加载耗时 {elapsed}ms 超过100ms"
```

[Source: docs/architecture/coding-standards.md#测试规范]

### 依赖关系

**前置依赖**:
- Story 16.1: Canvas关联UI (提供用户交互界面)
  - UI需要调用配置管理器API
  - 获取/保存关联配置

**后续依赖**:
- Story 16.3: Graphiti跨Canvas关系存储
  - 本Story的同步机制为16.3提供基础
  - 16.3实现完整的Graphiti集成

### 技术约束和注意事项

**版本约束**:
- Python: ≥3.9
- Pydantic: ≥2.5.0
- jsonschema: ≥4.20.0
- filelock: ≥3.13.0

**已知限制**:
- 单Canvas模式下配置文件与Canvas同目录
- 集中模式需要Vault根目录写入权限
- 大量关联时（>1000条）建议使用集中模式

**安全考虑**:
- 配置文件路径验证（防止路径遍历攻击）
- 关联数量限制（防止DoS）

**与PRD的对应关系**:
- [Source: docs/prd/CANVAS-LEARNING-SYSTEM-OBSIDIAN-NATIVE-MIGRATION-PRD.md:6551-6559]
- Epic 16功能需求: 跨Canvas关联学习系统

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-02 | 1.0 | Initial story draft | SM Agent |

## Story Checklist Validation

### Section 1: Story基础信息
- [x] 1.1 Status字段存在且为有效值 (Draft)
- [x] 1.2 Story格式遵循 "As a... I want... so that..."
- [x] 1.3 Story描述清晰、具体、可实现

### Section 2: Acceptance Criteria
- [x] 2.1 AC列表存在且非空 (9条)
- [x] 2.2 每条AC可验证、可测量
- [x] 2.3 AC覆盖Story的核心功能

### Section 3: Tasks
- [x] 3.1 Tasks列表存在且非空 (8个Task)
- [x] 3.2 每个Task关联到具体AC
- [x] 3.3 Tasks分解粒度适当

### Section 4: Dev Notes
- [x] 4.1 Dev Notes存在且非空
- [x] 4.2 技术验证报告存在
- [x] 4.3 代码示例存在

### Section 5: Testing
- [x] 5.1 Testing section存在
- [x] 5.2 测试标准定义
- [x] 5.3 测试用例示例存在

### Section 6: SDD/ADR (CRITICAL)
- [x] 6.1 SDD规范引用存在
  - API端点: specs/api/canvas-api.openapi.yml:454-489, :491-499
  - 数据Schema: specs/data/canvas-association.schema.json
  - 新增Schema: specs/data/canvas-links-config.schema.json (待创建)
- [x] 6.2 ADR关联存在
  - ADR-0003: Graphiti Memory
  - ADR-0009: Error Handling策略
  - ADR-0010: Logging聚合
- [x] 6.3 反幻觉验证
  - 所有文件路径已在project-file-index.md验证或标记为"待创建"
  - API端点行号已验证
  - Schema字段与源文件一致
