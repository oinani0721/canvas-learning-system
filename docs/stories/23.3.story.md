# Story 23.3: StateGraph智能推理链配置

## Status: Draft

## Epic Context & Background

**所属Epic**: EPIC-23 - RAG智能推理系统
**Epic文档**: [EPIC-23-RAG-INTELLIGENT-INFERENCE.md](../prd/EPIC-23-RAG-INTELLIGENT-INFERENCE.md)
**优先级**: P1 (High)
**估计**: 3 Story Points

**本Story在Epic中的定位**:
- Epic 23的**第三个Story**，验证并修复StateGraph完整配置
- 确保LangGraph图能正确编译和执行
- **依赖**: Story 23.1 (导入修复), Story 23.2 (Embedding Pipeline)
- **被依赖**: Story 23.4 (多源融合依赖StateGraph正常运行)

**Epic核心问题回顾**:

### Bug 7相关: StateGraph配置问题

**现象**:
- `state_graph.py` 已存在基本结构，但节点函数可能存在运行时错误
- 边配置可能不完整或存在逻辑错误
- 质量控制循环可能无法正确触发

**当前状态** (src/agentic_rag/state_graph.py):
```
✅ build_canvas_agentic_rag_graph() 已实现
✅ fan_out_retrieval() Send模式已定义
✅ route_after_quality_check() 条件路由已定义
✅ rewrite_query() 节点已定义
⚠️ 需验证: 所有节点函数签名与State兼容
⚠️ 需验证: 并行检索收敛逻辑正确
⚠️ 需验证: 质量控制循环能正常触发
❌ 需补充: 端到端集成测试
```

**修复目标**: 验证StateGraph编译成功，并行检索和质量控制循环正常工作

---

## Story

**As a** Canvas学习系统,
**I want** 修复并验证LangGraph StateGraph的完整配置,
**so that** RAG系统的图能正确编译和执行，支持并行检索和质量控制循环

---

## Acceptance Criteria

### AC 1: StateGraph编译成功
- **Given**: 已修复所有依赖导入问题 (Story 23.1)
- **When**: 执行 `canvas_agentic_rag.compile()` 或访问 `canvas_agentic_rag`
- **Then**:
  - 编译成功，无异常抛出
  - 返回的图对象具有 `invoke()` 和 `ainvoke()` 方法
  - 图结构包含所有预期节点

### AC 2: 并行检索 (Send模式) 正常工作
- **Given**: 用户查询 "什么是逆否命题？"
- **When**: 执行 `canvas_agentic_rag.ainvoke({"messages": [...]})`
- **Then**:
  - 三路并行检索同时触发 (Graphiti, LanceDB, Multimodal)
  - 检索结果正确收敛到 `fuse_results` 节点
  - State中包含 `graphiti_results`, `lancedb_results`, `multimodal_results`

### AC 3: 融合算法可切换 (RRF/Weighted/Cascade)
- **Given**: StateGraph配置完成
- **When**: 通过 `runtime.context["fusion_strategy"]` 设置不同策略
- **Then**:
  - `fusion_strategy="rrf"` → 使用RRF融合算法
  - `fusion_strategy="weighted"` → 使用加权融合算法
  - `fusion_strategy="cascade"` → 使用级联融合算法
  - 策略切换无需重新编译图

### AC 4: 质量控制循环正常工作
- **Given**: 检索结果质量评级为 "low"
- **When**: `check_quality` 节点返回 `quality_grade="low"` 且 `rewrite_count < 2`
- **Then**:
  - 路由到 `rewrite_query` 节点
  - Query被重写后重新触发并行检索
  - `rewrite_count` 递增
  - 达到最大重写次数(2)后终止循环

### AC 5: 端到端测试通过
- **Given**: 完整的StateGraph配置
- **When**: 执行端到端RAG查询测试
- **Then**:
  - 从START到END完整流程执行成功
  - 返回结果包含 `reranked_results`
  - 性能符合要求: 端到端 < 2秒 (无重写), < 5秒 (含重写)

---

## Tasks / Subtasks

### 任务1: 验证节点函数签名与State兼容 (AC: 1, 2)
- [ ] 1.1: 检查 `retrieve_graphiti` 签名: `(state: CanvasRAGState, runtime: Runtime) -> Dict`
- [ ] 1.2: 检查 `retrieve_lancedb` 签名
- [ ] 1.3: 检查 `multimodal_retrieval_node` 签名
- [ ] 1.4: 检查 `fuse_results`, `rerank_results`, `check_quality` 签名
- [ ] 1.5: 验证所有节点返回的dict键名与State字段匹配

### 任务2: 修复fan_out_retrieval Send配置 (AC: 2)
- [ ] 2.1: 验证 `Send("retrieve_graphiti", state)` 正确传递状态
- [ ] 2.2: 验证 `Send("retrieve_lancedb", state)` 正确传递状态
- [ ] 2.3: 验证 `Send("retrieve_multimodal", state)` 正确传递状态
- [ ] 2.4: 测试三路并行执行的收敛逻辑
- [ ] 2.5: 添加并行执行超时处理

### 任务3: 验证条件边配置 (AC: 4)
- [ ] 3.1: 验证 `route_after_quality_check` 路由逻辑
- [ ] 3.2: 测试 `quality_grade="low"` 触发 `rewrite_query`
- [ ] 3.3: 测试 `quality_grade="medium/high"` 触发 END
- [ ] 3.4: 测试 `rewrite_count >= 2` 强制终止循环
- [ ] 3.5: 验证 `rewrite_loop_routing` 正确回到并行检索

### 任务4: 增强融合策略切换 (AC: 3)
- [ ] 4.1: 验证 `runtime.context.get("fusion_strategy")` 读取配置
- [ ] 4.2: 测试RRF策略执行路径
- [ ] 4.3: 测试Weighted策略执行路径 (验证alpha/beta参数)
- [ ] 4.4: 测试Cascade策略执行路径 (验证tier阈值)
- [ ] 4.5: 添加策略切换的日志记录

### 任务5: 添加节点执行日志 (AC: 1-5)
- [ ] 5.1: 在每个节点函数入口添加DEBUG日志
- [ ] 5.2: 在每个节点函数出口添加结果摘要日志
- [ ] 5.3: 添加节点执行时间监控
- [ ] 5.4: 添加状态变更追踪日志

### 任务6: 编写StateGraph单元测试 (AC: 1-4)
- [ ] 6.1: 测试图编译成功
- [ ] 6.2: 测试节点是否存在
- [ ] 6.3: 测试边连接是否正确
- [ ] 6.4: 测试条件路由逻辑
- [ ] 6.5: 测试并行执行收敛

### 任务7: 编写端到端集成测试 (AC: 5)
- [ ] 7.1: 创建 `tests/test_stategraph_e2e.py`
- [ ] 7.2: 测试完整查询流程 (无重写)
- [ ] 7.3: 测试带重写的查询流程
- [ ] 7.4: 测试性能基准 (< 2秒/5秒)
- [ ] 7.5: 测试错误处理和降级

---

## Dev Notes

### Technical Context

**现有代码分析** (src/agentic_rag/state_graph.py:157-295):

**StateGraph构建结构**:
```python
# ✅ Verified from state_graph.py:157-193
def build_canvas_agentic_rag_graph() -> StateGraph:
    builder = StateGraph(
        state_schema=CanvasRAGState,
        context_schema=CanvasRAGConfig
    )

    # 检索节点 (with retry policy)
    builder.add_node("retrieve_graphiti", retrieve_graphiti, retry_policy=...)
    builder.add_node("retrieve_lancedb", retrieve_lancedb, retry_policy=...)
    builder.add_node("retrieve_multimodal", multimodal_retrieval_node, retry_policy=...)

    # 处理节点
    builder.add_node("fuse_results", fuse_results)
    builder.add_node("rerank_results", rerank_results)
    builder.add_node("check_quality", check_quality)
    builder.add_node("rewrite_query", rewrite_query)

    # 边配置
    builder.add_conditional_edges(START, fan_out_retrieval)  # 并行分发
    builder.add_edge("retrieve_graphiti", "fuse_results")
    builder.add_edge("retrieve_lancedb", "fuse_results")
    builder.add_edge("retrieve_multimodal", "fuse_results")
    builder.add_edge("fuse_results", "rerank_results")
    builder.add_edge("rerank_results", "check_quality")
    builder.add_conditional_edges("check_quality", route_after_quality_check, {...})
    builder.add_conditional_edges("rewrite_query", rewrite_loop_routing)

    return builder
```

**CanvasRAGState结构** (src/agentic_rag/state.py:57-128):
```python
# ✅ Verified from state.py
class CanvasRAGState(MessagesState):
    # 检索结果字段
    graphiti_results: Annotated[List[SearchResult], "Graphiti知识图谱检索结果"]
    lancedb_results: Annotated[List[SearchResult], "LanceDB向量检索结果"]
    multimodal_results: Annotated[List[SearchResult], "多模态检索结果"]
    fused_results: Annotated[List[SearchResult], "融合算法输出结果"]
    reranked_results: Annotated[List[SearchResult], "Reranking后的最终结果"]

    # 策略配置字段
    fusion_strategy: Annotated[Literal["rrf", "weighted", "cascade"], "融合算法选择"]
    reranking_strategy: Annotated[Literal["local", "cohere", "hybrid_auto"], "Reranking策略选择"]

    # 质量控制字段
    quality_grade: Annotated[Optional[Literal["high", "medium", "low"]], "结果质量评级"]
    query_rewritten: Annotated[bool, "Query是否已重写"]
    rewrite_count: Annotated[int, "当前重写次数 (最大2次)"]

    # 上下文字段
    canvas_file: Annotated[Optional[str], "Canvas文件路径"]
    is_review_canvas: Annotated[bool, "是否为检验白板场景"]
```

**节点函数签名验证** (src/agentic_rag/nodes.py):
```python
# ✅ Verified from nodes.py:90-147
async def retrieve_graphiti(
    state: CanvasRAGState,
    runtime: Runtime[CanvasRAGConfig]
) -> Dict[str, Any]:
    """返回: graphiti_results, graphiti_latency_ms"""

# ✅ Verified from nodes.py:154-216
async def retrieve_lancedb(
    state: CanvasRAGState,
    runtime: Runtime[CanvasRAGConfig]
) -> Dict[str, Any]:
    """返回: lancedb_results, lancedb_latency_ms"""

# ✅ Verified from nodes.py:223-272
async def fuse_results(
    state: CanvasRAGState,
    runtime: Runtime[CanvasRAGConfig]
) -> Dict[str, Any]:
    """返回: fused_results, fusion_latency_ms"""

# ✅ Verified from nodes.py:336-385
async def rerank_results(
    state: CanvasRAGState,
    runtime: Runtime[CanvasRAGConfig]
) -> Dict[str, Any]:
    """返回: reranked_results, reranking_latency_ms"""

# ✅ Verified from nodes.py:418-460
async def check_quality(
    state: CanvasRAGState,
    runtime: Runtime[CanvasRAGConfig]
) -> Dict[str, Any]:
    """返回: quality_grade"""
```

### SDD References

**OpenAPI参考**:
- specs/api/canvas-api.openapi.yml - Canvas节点API (无直接RAG端点)

**JSON Schema参考**:
- specs/data/canvas-node.schema.json#L17-L74 - Canvas节点结构定义 (用于multimodal检索)
- specs/data/agent-response.schema.json - Agent响应格式

**ADR参考**:
- docs/architecture/decisions/0002-langgraph-agents.md#L46-L78 - LangGraph StateGraph选型决策
  - StateGraph是Canvas Learning System的Agent架构基石
  - 支持条件分支、循环迭代、人机交互
- docs/architecture/decisions/0004-async-execution-engine.md - 异步并行执行决策
  - RetryPolicy配置
  - 并行Agent调用模式

### Implementation Guidelines

**Step 1: 验证图编译和结构**
```python
# ✅ Verified from LangGraph Skill (SKILL.md - Pattern: StateGraph compilation)
def test_graph_compilation():
    """验证StateGraph编译成功"""
    from agentic_rag import canvas_agentic_rag

    # 检查已编译
    assert canvas_agentic_rag is not None
    assert hasattr(canvas_agentic_rag, 'invoke')
    assert hasattr(canvas_agentic_rag, 'ainvoke')

    # 检查节点存在
    # ✅ Verified from LangGraph Skill: compiled graph has .nodes attribute
    nodes = canvas_agentic_rag.nodes
    expected_nodes = [
        "retrieve_graphiti",
        "retrieve_lancedb",
        "retrieve_multimodal",
        "fuse_results",
        "rerank_results",
        "check_quality",
        "rewrite_query"
    ]
    for node in expected_nodes:
        assert node in nodes, f"Missing node: {node}"
```

**Step 2: 验证并行检索Send模式**
```python
# ✅ Verified from LangGraph Skill (SKILL.md - Pattern: Send for parallel execution)
# ✅ Verified from state_graph.py:47-67

@pytest.mark.asyncio
async def test_parallel_retrieval():
    """验证三路并行检索"""
    from agentic_rag import canvas_agentic_rag

    # 构造初始状态
    initial_state = {
        "messages": [{"role": "user", "content": "什么是逆否命题？"}],
        "canvas_file": "test.canvas",
        "fusion_strategy": "rrf",
        "reranking_strategy": "local",
        "is_review_canvas": False,
    }

    # 配置
    config = {
        "retrieval_batch_size": 10,
        "quality_threshold": 0.7,
    }

    # 执行
    result = await canvas_agentic_rag.ainvoke(initial_state, config=config)

    # 验证三路结果
    assert "graphiti_results" in result
    assert "lancedb_results" in result
    assert "multimodal_results" in result
    assert isinstance(result["graphiti_results"], list)
```

**Step 3: 验证质量控制循环**
```python
# ✅ Verified from LangGraph Skill (SKILL.md - Pattern: Conditional edges)
# ✅ Verified from state_graph.py:74-101

@pytest.mark.asyncio
async def test_quality_control_loop():
    """验证质量控制循环"""
    from agentic_rag import canvas_agentic_rag

    # 设置初始状态 - 模拟低质量结果
    initial_state = {
        "messages": [{"role": "user", "content": "模糊查询"}],
        "rewrite_count": 0,
        "fusion_strategy": "rrf",
        "reranking_strategy": "local",
    }

    # 使用trace模式观察执行路径
    # ✅ Verified from LangGraph Skill: stream_mode="values" to observe state changes
    events = []
    async for event in canvas_agentic_rag.astream(
        initial_state,
        stream_mode="values"
    ):
        events.append(event)

    # 检查是否触发了重写 (如果质量低)
    final_state = events[-1]
    if final_state.get("quality_grade") == "low":
        assert final_state.get("rewrite_count", 0) > 0
```

**Step 4: 添加节点执行日志**
```python
# 在nodes.py中添加日志

import logging
logger = logging.getLogger(__name__)

async def retrieve_graphiti(state, runtime):
    logger.debug(f"[retrieve_graphiti] START - query={state.get('messages', [])[-1]}")
    start_time = time.perf_counter()

    # ... 现有逻辑 ...

    elapsed = (time.perf_counter() - start_time) * 1000
    logger.debug(f"[retrieve_graphiti] END - results={len(results)}, latency={elapsed:.2f}ms")

    return {
        "graphiti_results": results,
        "graphiti_latency_ms": elapsed
    }
```

**Step 5: 增强融合策略验证**
```python
# ✅ Verified from nodes.py:223-272

@pytest.mark.asyncio
async def test_fusion_strategy_switching():
    """验证融合策略切换"""
    from agentic_rag import canvas_agentic_rag

    strategies = ["rrf", "weighted", "cascade"]

    for strategy in strategies:
        config = {"fusion_strategy": strategy}
        result = await canvas_agentic_rag.ainvoke(
            {"messages": [{"role": "user", "content": "测试"}]},
            config=config
        )
        assert "fused_results" in result
        # 验证使用了正确的策略 (通过日志或状态字段)
```

### Testing Requirements

**测试文件**: `src/tests/test_stategraph_e2e.py`

```python
"""
StateGraph端到端测试

✅ Story 23.3: 验证StateGraph完整配置
"""
import pytest
import time
from agentic_rag import canvas_agentic_rag, CanvasRAGState, CanvasRAGConfig


class TestStateGraphCompilation:
    """AC 1: StateGraph编译测试"""

    def test_graph_is_compiled(self):
        """测试图已编译"""
        assert canvas_agentic_rag is not None

    def test_graph_has_invoke_methods(self):
        """测试图具有invoke方法"""
        assert hasattr(canvas_agentic_rag, 'invoke')
        assert hasattr(canvas_agentic_rag, 'ainvoke')
        assert hasattr(canvas_agentic_rag, 'stream')
        assert hasattr(canvas_agentic_rag, 'astream')

    def test_graph_has_expected_nodes(self):
        """测试图包含所有预期节点"""
        expected_nodes = [
            "retrieve_graphiti",
            "retrieve_lancedb",
            "retrieve_multimodal",
            "fuse_results",
            "rerank_results",
            "check_quality",
            "rewrite_query"
        ]
        for node in expected_nodes:
            assert node in canvas_agentic_rag.nodes


class TestParallelRetrieval:
    """AC 2: 并行检索测试"""

    @pytest.mark.asyncio
    async def test_parallel_send_execution(self):
        """测试Send模式并行执行"""
        initial_state = {
            "messages": [{"role": "user", "content": "什么是逆否命题？"}],
            "fusion_strategy": "rrf",
            "reranking_strategy": "local",
            "is_review_canvas": False,
        }

        result = await canvas_agentic_rag.ainvoke(initial_state)

        # 验证三路检索结果存在
        assert "graphiti_results" in result
        assert "lancedb_results" in result
        assert "multimodal_results" in result

    @pytest.mark.asyncio
    async def test_results_converge_to_fuse(self):
        """测试结果收敛到融合节点"""
        initial_state = {
            "messages": [{"role": "user", "content": "测试收敛"}],
            "fusion_strategy": "rrf",
        }

        result = await canvas_agentic_rag.ainvoke(initial_state)

        # 验证融合结果存在
        assert "fused_results" in result
        assert isinstance(result["fused_results"], list)


class TestFusionStrategies:
    """AC 3: 融合策略测试"""

    @pytest.mark.asyncio
    @pytest.mark.parametrize("strategy", ["rrf", "weighted", "cascade"])
    async def test_fusion_strategy_execution(self, strategy):
        """测试各融合策略可切换"""
        initial_state = {
            "messages": [{"role": "user", "content": "测试融合"}],
            "fusion_strategy": strategy,
        }

        config = {"fusion_strategy": strategy}
        result = await canvas_agentic_rag.ainvoke(initial_state, config=config)

        assert "fused_results" in result


class TestQualityControlLoop:
    """AC 4: 质量控制循环测试"""

    @pytest.mark.asyncio
    async def test_quality_grade_routing(self):
        """测试质量评级路由"""
        initial_state = {
            "messages": [{"role": "user", "content": "测试质量"}],
            "rewrite_count": 0,
        }

        result = await canvas_agentic_rag.ainvoke(initial_state)

        # 验证质量评级存在
        assert "quality_grade" in result
        assert result["quality_grade"] in ["high", "medium", "low", None]

    @pytest.mark.asyncio
    async def test_rewrite_count_increment(self):
        """测试重写计数递增"""
        # 模拟低质量场景 (需要mock check_quality返回low)
        initial_state = {
            "messages": [{"role": "user", "content": "x"}],  # 短查询可能触发低质量
            "rewrite_count": 0,
        }

        result = await canvas_agentic_rag.ainvoke(initial_state)

        # 如果质量低，应该有重写
        if result.get("quality_grade") == "low":
            assert result.get("rewrite_count", 0) >= 1

    @pytest.mark.asyncio
    async def test_max_rewrite_limit(self):
        """测试最大重写次数限制"""
        initial_state = {
            "messages": [{"role": "user", "content": "测试"}],
            "rewrite_count": 2,  # 已达上限
        }

        result = await canvas_agentic_rag.ainvoke(initial_state)

        # 不应超过2次
        assert result.get("rewrite_count", 0) <= 2


class TestEndToEndPerformance:
    """AC 5: 端到端性能测试"""

    @pytest.mark.asyncio
    async def test_e2e_no_rewrite_performance(self):
        """测试端到端性能 (无重写) < 2秒"""
        initial_state = {
            "messages": [{"role": "user", "content": "什么是逆否命题的定义？"}],
            "fusion_strategy": "rrf",
            "reranking_strategy": "local",
        }

        start = time.perf_counter()
        result = await canvas_agentic_rag.ainvoke(initial_state)
        elapsed = time.perf_counter() - start

        assert "reranked_results" in result
        assert elapsed < 2.0, f"E2E took {elapsed:.2f}s, expected < 2s"

    @pytest.mark.asyncio
    async def test_e2e_with_rewrite_performance(self):
        """测试端到端性能 (含重写) < 5秒"""
        initial_state = {
            "messages": [{"role": "user", "content": "?"}],  # 可能触发重写
            "fusion_strategy": "rrf",
            "reranking_strategy": "local",
            "rewrite_count": 0,
        }

        start = time.perf_counter()
        result = await canvas_agentic_rag.ainvoke(initial_state)
        elapsed = time.perf_counter() - start

        assert "reranked_results" in result
        assert elapsed < 5.0, f"E2E with rewrite took {elapsed:.2f}s, expected < 5s"

    @pytest.mark.asyncio
    async def test_e2e_result_structure(self):
        """测试端到端结果结构完整"""
        initial_state = {
            "messages": [{"role": "user", "content": "完整测试"}],
        }

        result = await canvas_agentic_rag.ainvoke(initial_state)

        # 验证所有预期字段
        expected_fields = [
            "graphiti_results",
            "lancedb_results",
            "multimodal_results",
            "fused_results",
            "reranked_results",
            "quality_grade",
        ]
        for field in expected_fields:
            assert field in result, f"Missing field: {field}"
```

### Dependencies

**Story依赖**:
- ✅ Story 23.1 (LangGraph导入问题修复) - 必须完成
- ✅ Story 23.2 (LanceDB Embedding Pipeline) - 必须完成

**技术依赖**:
- Python 3.9+
- langgraph>=0.2.0
- langchain-core>=0.3.0
- pytest>=7.0.0
- pytest-asyncio>=0.21.0

### Key Files to Modify

| 文件路径 | 修改类型 | 说明 |
|---------|---------|------|
| `src/agentic_rag/state_graph.py` | 验证/小修改 | 验证图结构，可能添加日志 |
| `src/agentic_rag/nodes.py` | 修改 | 添加节点执行日志 |
| `src/agentic_rag/state.py` | 验证 | 确认State字段与节点返回匹配 |
| `src/tests/test_stategraph_e2e.py` | 新建 | 端到端测试用例 |
| `src/tests/test_stategraph_unit.py` | 新建 | 单元测试用例 |

### Anti-Hallucination Verification

**验证的文件路径**:
- ✅ `src/agentic_rag/state_graph.py` - 已验证存在并读取 (295行)
- ✅ `src/agentic_rag/state.py` - 已验证存在并读取 (128行)
- ✅ `src/agentic_rag/nodes.py` - 已验证存在并读取 (562行)
- ✅ `src/agentic_rag/config.py` - 已验证存在 (Glob结果)
- ✅ `src/agentic_rag/retrievers/multimodal_retriever.py` - 已验证存在 (Glob结果)

**验证的API签名**:
- ✅ `StateGraph(state_schema, context_schema)` - 已验证 (state_graph.py:190-193)
- ✅ `builder.add_node(name, fn, retry_policy)` - 已验证 (state_graph.py:200-229)
- ✅ `builder.add_conditional_edges(source, fn, path_map)` - 已验证 (state_graph.py:244-280)
- ✅ `Send(node_name, state)` - 已验证 (state_graph.py:63-67)
- ✅ `RetryPolicy(retry_on, max_attempts, backoff_factor)` - 已验证 (state_graph.py:203-207)

**验证的LangGraph模式** (from LangGraph Skill):
- ✅ Pattern: StateGraph construction with context_schema
- ✅ Pattern: Send for parallel execution
- ✅ Pattern: Conditional edges with path_map
- ✅ Pattern: Node signature `async def node(state, runtime) -> dict`

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-12 | 1.0 | 初始创建 - SM Agent自动化batch模式 | Bob (SM Agent) |

---

## Dev Agent Record

### Agent Model Used
*待填写*

### Debug Log References
*待填写*

### Completion Notes List
*待填写*

### File List
*待填写*

---

## QA Results

*待QA Agent审查*

---

## Related Documentation

**Epic文档**:
- [EPIC-23-RAG-INTELLIGENT-INFERENCE.md](../prd/EPIC-23-RAG-INTELLIGENT-INFERENCE.md) - Epic 23完整PRD

**架构文档**:
- [coding-standards.md](../architecture/coding-standards.md) - 编码规范 (零幻觉开发规范)
- [tech-stack.md](../architecture/tech-stack.md) - 技术栈说明

**ADR参考**:
- [0002-langgraph-agents.md](../architecture/decisions/0002-langgraph-agents.md) - LangGraph StateGraph选型决策
- [0004-async-execution-engine.md](../architecture/decisions/0004-async-execution-engine.md) - 异步并行执行决策

**技能参考**:
- LangGraph Skill: `.claude/skills/langgraph/SKILL.md` - StateGraph模式、Send模式、条件边

**前置Story**:
- Story 23.1: LangGraph导入问题修复
- Story 23.2: LanceDB Embedding Pipeline

**后续Story**:
- Story 23.4: 多源融合 (教材+历史+跨Canvas)
