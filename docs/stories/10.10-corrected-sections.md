# Story 10.10 修正后的章节内容

**修正日期**: 2025-10-30
**修正依据**: `docs/stories/10.10-10.12-technical-supplement.md`
**修正范围**: Dev Notes -> Technical Context (集成点1, 2, 3) + Implementation Guidance

---

## 📝 使用说明

请将以下内容替换到 `docs/stories/10.10.story.md` 中对应的章节。

**替换位置**:
1. 找到 `#### 集成点1: MCP Graphiti工具` - 替换整个小节
2. 找到 `#### 集成点2: TemporalMemoryManager` - 替换整个小节
3. 找到 `#### 集成点3: SemanticMemoryManager` - 替换整个小节
4. 找到 `#### 核心实现结构` - 替换整个小节

---

## ✅ 修正后的内容

### 替换1: 集成点1 - MCP Graphiti工具

```markdown
#### 集成点1: MCP Graphiti工具

**位置**: MCP服务器提供的工具（通过Claude Code调用）

**可用工具**:
```python
# MCP Graphiti工具函数签名
mcp__graphiti_memory__add_episode(content: str) -> Dict
mcp__graphiti_memory__add_memory(key: str, content: str, metadata: Dict) -> Dict
mcp__graphiti_memory__search_memories(query: str) -> Dict
mcp__graphiti_memory__list_memories() -> List[Dict]
```

**调用方式** [Source: canvas_utils/session_monitor.py:132-133]:
```python
# ⚠️ 重要：MCP工具在Claude Code环境中需要特殊导入
try:
    from claude_tools import mcp__graphiti_memory__add_episode

    # 异步调用（必须使用await）
    result = await mcp__graphiti_memory__add_episode(
        content=f"开始学习会话: {canvas_path}, session_id: {session_id}"
    )

    # 验证返回结果
    if 'memory_id' in result:
        memory_id = result['memory_id']
        logger.info(f"Graphiti记忆创建成功: {memory_id}")
    else:
        raise ValueError(f"MCP工具返回结果异常: {result}")

except ImportError as e:
    logger.error(f"MCP工具不可用（未导入）: {e}")
    raise
except NameError as e:
    logger.error(f"MCP工具未加载: {e}")
    raise
except Exception as e:
    logger.error(f"MCP工具调用失败: {e}")
    raise
```

**返回格式**:
```python
{
    'memory_id': 'mem_20251030_185905_3321',
    'status': 'success'
}
```

**关键要点** [Source: docs/stories/8.17.story.md, canvas_utils/session_monitor.py]:
- **导入检查**: 必须捕获 `ImportError` 和 `NameError`，MCP工具可能不可用
- **异步调用**: 必须使用 `await`
- **返回值验证**: 必须验证 `memory_id` 字段存在
- **连接到Neo4j**: 连接到"ultrathink"数据库
- **错误处理**: 如果Neo4j不可用或MCP服务器不可用，工具调用会失败
- **现有模式**: 已在Story 8.17的Canvas记忆系统中使用，参见 `canvas_utils/session_monitor.py` 和 `memory_recorder.py`
- **白名单配置**: 工具已在 `.claude/settings.local.json` 中配置为可用

**MCP工具可用性检测** (用于Story 10.11):
```python
def check_mcp_graphiti_available() -> bool:
    """检测MCP Graphiti工具是否可用"""
    try:
        from claude_tools import mcp__graphiti_memory__list_memories
        return True
    except (ImportError, NameError):
        return False
```
```

---

### 替换2: 集成点2 - TemporalMemoryManager

```markdown
#### 集成点2: TemporalMemoryManager

**位置**: `memory_system/temporal_memory_manager.py`

**公共接口** [Source: memory_system/temporal_memory_manager.py:40-132]:
```python
class TemporalMemoryManager:
    """时序记忆管理器，封装Graphiti用于学习历程记录"""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        初始化时序记忆管理器

        Args:
            config: 配置字典，包含：
                - neo4j_uri: str (默认: 'bolt://localhost:7687')
                - neo4j_username: str (默认: 'neo4j')
                - neo4j_password: str (默认: 'password')
                - session_timeout: int (默认: 1800秒)
                - max_nodes_per_session: int (默认: 1000)
        """
        pass

    @property
    def is_initialized(self) -> bool:
        """检查是否已初始化（可能是Graphiti模式或本地降级模式）"""
        pass

    def create_learning_session(self, canvas_id: str, user_id: str) -> LearningSession:
        """
        创建学习会话

        Args:
            canvas_id: Canvas文件路径或ID
            user_id: 用户ID

        Returns:
            LearningSession: 学习会话对象，包含以下属性：
                - session_id: str - 会话ID
                - canvas_id: str - Canvas ID
                - user_id: str - 用户ID
                - start_time: datetime - 开始时间
                - end_time: Optional[datetime] - 结束时间
                - duration_seconds: int - 持续时间（秒）
                - nodes_interacted: List[str] - 交互过的节点列表
                - learning_progress: Dict[str, float] - 学习进度（节点ID -> 置信度）
                - memories_created: List[str] - 创建的记忆ID列表

        Raises:
            TemporalMemoryError: 如果创建失败
        """
        pass

    def end_learning_session(self, session_id: Optional[str] = None) -> Optional[LearningSession]:
        """
        结束学习会话

        Args:
            session_id: 会话ID（可选，默认为当前会话）

        Returns:
            LearningSession: 结束的会话对象，如果没有活动会话则返回None
        """
        pass
```

**集成方式** [Source: memory_system/temporal_memory_manager.py:103-131]:
```python
# 初始化
temporal_manager = TemporalMemoryManager(config={
    'neo4j_uri': os.getenv('NEO4J_URI', 'bolt://localhost:7687'),
    'neo4j_username': os.getenv('NEO4J_USERNAME', 'neo4j'),
    'neo4j_password': os.getenv('NEO4J_PASSWORD', 'password')
})

# 检查初始化状态
if not temporal_manager.is_initialized:
    raise TemporalMemoryError(
        operation="initialize",
        details="TemporalMemoryManager初始化失败"
    )

# 创建学习会话
session = temporal_manager.create_learning_session(
    canvas_id="笔记库/Math53/Lecture5.canvas",
    user_id="default"  # ⚠️ 必需参数
)

# 访问会话信息
logger.info(f"会话ID: {session.session_id}")
logger.info(f"开始时间: {session.start_time}")
```

**关键要点**:
- ⚠️ **方法名**: `create_learning_session()` 而非 `start_session()`
- ⚠️ **参数名**: `canvas_id` 而非 `canvas_path`
- ⚠️ **必需参数**: `user_id` 是必需的
- ⚠️ **返回值**: 返回 `LearningSession` 对象，而非字符串
- 初始化可能失败（Graphiti库不可用、Neo4j连接失败）
- 使用 `is_initialized` 属性检查是否成功初始化
- 如果初始化失败，会自动切换到"本地存储模式"（优雅降级）
- 不会抛出异常导致程序崩溃，而是设置 `is_initialized = True` 并记录警告
- **现有模式**: 已实现，有完整docstring和类型注解（Story 8.17）
```

---

### 替换3: 集成点3 - SemanticMemoryManager

```markdown
#### 集成点3: SemanticMemoryManager

**位置**: `memory_system/semantic_memory_manager.py`

**公共接口** [Source: memory_system/semantic_memory_manager.py:43-122]:
```python
class SemanticMemoryManager:
    """语义记忆管理器，封装MCP语义记忆服务"""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        初始化语义记忆管理器

        Args:
            config: 配置字典，包含：
                - endpoint: str (默认: 'local')
                - timeout: int (默认: 30秒)
                - retry_attempts: int (默认: 3)
                - max_text_length: int (默认: 512)
                - similarity_threshold: float (默认: 0.7)
        """
        pass

    @property
    def is_initialized(self) -> bool:
        """
        检查是否已初始化

        ⚠️ 重要：此属性总是返回True，即使MCP不可用
        必须检查 mcp_client 是否为 None 来判断MCP是否真正可用
        """
        pass

    @property
    def mcp_client(self) -> Optional[Any]:
        """
        MCP客户端对象

        Returns:
            MCPSemanticMemory实例或None（如果MCP不可用）
        """
        pass

    def store_semantic_memory(
        self,
        content: str,
        metadata: Optional[Dict] = None
    ) -> str:
        """
        存储语义记忆

        Args:
            content: 记忆内容
            metadata: 元数据（可选）

        Returns:
            str: 记忆ID（UUID格式）

        Raises:
            SemanticMemoryError: 如果存储失败
        """
        pass
```

**集成方式** [Source: memory_system/semantic_memory_manager.py:70-88, 91-122]:
```python
# 初始化
semantic_manager = SemanticMemoryManager(config={
    'endpoint': 'local',
    'timeout': 30
})

# ⚠️ 关键：正确的可用性检测方式
# 方式1：检查is_initialized（总是True，不够准确）
if semantic_manager.is_initialized:
    logger.info("SemanticMemoryManager已初始化")

# 方式2：检查mcp_client（推荐）
if semantic_manager.mcp_client is not None:
    # MCP真正可用
    memory_id = semantic_manager.store_semantic_memory(
        content="开始学习Lecture5",
        metadata={'canvas': 'Lecture5.canvas'}
    )
    logger.info(f"语义记忆存储成功: {memory_id}")
else:
    # MCP不可用，降级模式
    logger.warning("MCP语义服务不可用，使用降级模式")
    raise SemanticMemoryError(
        operation="initialize",
        details="MCP语义服务未连接"
    )
```

**关键要点**:
- ⚠️ **is_initialized总是为True**: 即使MCP不可用，`is_initialized` 也返回 `True`
- ⚠️ **必须检查mcp_client**: 使用 `semantic_manager.mcp_client is not None` 判断MCP是否可用
- 依赖 `mcp_memory_client` 模块（可能不可用）
- 如果MCP语义服务不可用，会自动切换到"降级模式"（使用本地模拟）
- 降级模式仍然可以工作，但功能受限（使用简单的关键词提取而非真实的语义分析）
- **现有模式**: 已实现，支持降级运行（Story 8.17）
```

---

### 替换4: 核心实现结构

**找到此位置**: `#### 核心实现结构`

```markdown
#### 核心实现结构

```python
# command_handlers/learning_commands.py

import os
import json
from datetime import datetime
from typing import Dict, Optional, Any
from pathlib import Path
from loguru import logger

# 导入记忆管理器
from memory_system.temporal_memory_manager import TemporalMemoryManager
from memory_system.semantic_memory_manager import SemanticMemoryManager
from memory_system.memory_exceptions import (
    TemporalMemoryError,
    SemanticMemoryError
)


class LearningSessionManager:
    """学习会话管理器 - 负责启动和管理学习会话"""

    def __init__(self, session_dir: str = ".learning_sessions"):
        """
        初始化学习会话管理器

        Args:
            session_dir: 会话JSON存储目录
        """
        self.session_dir = Path(session_dir)
        self.session_dir.mkdir(exist_ok=True)
        self.current_session: Optional[Dict] = None

    async def start_session(
        self,
        canvas_path: str,
        user_id: str = "default",
        session_name: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        启动学习会话，真实初始化所有记忆系统

        Args:
            canvas_path: Canvas文件路径
            user_id: 用户ID
            session_name: 会话名称（可选）

        Returns:
            Dict: 启动结果，包含各系统状态
        """
        # 1. 生成会话ID和名称
        session_id = self._generate_session_id()
        session_name = session_name or f"session_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        logger.info(f"开始启动学习会话: {session_id}")

        # 2. 初始化会话数据结构
        session_data = {
            "session_id": session_id,
            "session_name": session_name,
            "user_id": user_id,
            "start_time": datetime.now().isoformat(),
            "canvas_path": str(Path(canvas_path).resolve()),  # Windows兼容
            "memory_systems": {}
        }

        # 3. 真实启动三个记忆系统（独立执行，不互相影响）
        results = {}

        # 3.1 启动Graphiti知识图谱
        try:
            graphiti_result = await self._start_graphiti(canvas_path, session_id)
            results['graphiti'] = graphiti_result
        except Exception as e:
            logger.error(f"Graphiti启动失败: {e}")
            results['graphiti'] = {
                'status': 'unavailable',
                'error': str(e),
                'attempted_at': datetime.now().isoformat()
            }

        # 3.2 启动时序记忆管理器
        try:
            temporal_result = await self._start_temporal(canvas_path, session_id, user_id)
            results['temporal'] = temporal_result
        except Exception as e:
            logger.error(f"时序记忆管理器启动失败: {e}")
            results['temporal'] = {
                'status': 'unavailable',
                'error': str(e),
                'attempted_at': datetime.now().isoformat()
            }

        # 3.3 启动语义记忆管理器
        try:
            semantic_result = await self._start_semantic(canvas_path, session_id)
            results['semantic'] = semantic_result
        except Exception as e:
            logger.error(f"语义记忆管理器启动失败: {e}")
            results['semantic'] = {
                'status': 'unavailable',
                'error': str(e),
                'attempted_at': datetime.now().isoformat()
            }

        # 4. 更新会话数据
        session_data['memory_systems'] = results

        # 5. 保存会话JSON
        session_file = self.session_dir / f"{session_id}.json"
        with open(session_file, 'w', encoding='utf-8') as f:
            json.dump(session_data, f, indent=2, ensure_ascii=False)

        logger.info(f"会话已保存: {session_file}")
        self.current_session = session_data

        return {
            'success': True,
            'session_id': session_id,
            'session_file': str(session_file),
            'memory_systems': results
        }

    async def _start_graphiti(
        self,
        canvas_path: str,
        session_id: str
    ) -> Dict[str, Any]:
        """
        真实启动Graphiti知识图谱记录

        Returns:
            Dict: 启动结果 {'status': 'running'/'unavailable', ...}
        """
        try:
            # ⚠️ 修正：使用正确的MCP工具导入方式
            from claude_tools import mcp__graphiti_memory__add_episode

            # 调用MCP Graphiti工具
            result = await mcp__graphiti_memory__add_episode(
                content=f"开始学习会话: {canvas_path}, session_id: {session_id}"
            )

            # 验证返回结果
            if 'memory_id' in result:
                logger.info(f"Graphiti启动成功，memory_id: {result['memory_id']}")
                return {
                    'status': 'running',
                    'memory_id': result['memory_id'],
                    'storage': 'Neo4j图数据库',
                    'initialized_at': datetime.now().isoformat()
                }
            else:
                raise ValueError(f"Graphiti返回结果缺少memory_id: {result}")

        except (ImportError, NameError) as e:
            logger.warning(f"MCP工具不可用: {e}")
            raise
        except Exception as e:
            logger.warning(f"Graphiti启动失败: {e}")
            raise

    async def _start_temporal(
        self,
        canvas_path: str,
        session_id: str,
        user_id: str
    ) -> Dict[str, Any]:
        """
        真实初始化并启动时序记忆管理器

        Returns:
            Dict: 启动结果 {'status': 'running'/'unavailable', ...}
        """
        try:
            # ⚠️ 修正：使用正确的API
            # 1. 初始化TemporalMemoryManager
            temporal_manager = TemporalMemoryManager(config={
                'neo4j_uri': os.getenv('NEO4J_URI', 'bolt://localhost:7687'),
                'neo4j_username': os.getenv('NEO4J_USERNAME', 'neo4j'),
                'neo4j_password': os.getenv('NEO4J_PASSWORD', 'password')
            })

            # 2. 检查初始化状态
            if not temporal_manager.is_initialized:
                raise TemporalMemoryError(
                    operation="initialize",
                    details="TemporalMemoryManager初始化失败"
                )

            # 3. 创建学习会话（⚠️ 注意：方法名和参数）
            session = temporal_manager.create_learning_session(
                canvas_id=canvas_path,  # canvas_id，不是canvas_path
                user_id=user_id  # 必需参数
            )

            logger.info(f"时序记忆管理器启动成功，session_id: {session.session_id}")
            return {
                'status': 'running',
                'session_id': session.session_id,  # ⚠️ 从LearningSession对象获取
                'storage': '本地SQLite数据库或Graphiti知识图谱',
                'initialized_at': datetime.now().isoformat()
            }

        except Exception as e:
            logger.warning(f"时序记忆管理器启动失败: {e}")
            raise

    async def _start_semantic(
        self,
        canvas_path: str,
        session_id: str
    ) -> Dict[str, Any]:
        """
        真实初始化并启动语义记忆管理器

        Returns:
            Dict: 启动结果 {'status': 'running'/'unavailable', ...}
        """
        try:
            # 1. 初始化SemanticMemoryManager
            semantic_manager = SemanticMemoryManager(config={
                'endpoint': 'local',
                'timeout': 30
            })

            # 2. ⚠️ 关键：正确检查MCP可用性
            # is_initialized总是True，必须检查mcp_client
            if not semantic_manager.is_initialized:
                # 这个条件实际上永远不会触发
                raise SemanticMemoryError(
                    operation="initialize",
                    details="SemanticMemoryManager初始化失败"
                )

            if semantic_manager.mcp_client is None:
                # ⚠️ 真正的可用性检测
                raise SemanticMemoryError(
                    operation="initialize",
                    details="MCP语义服务未连接"
                )

            # 3. 存储初始记忆（验证MCP真正工作）
            memory_id = semantic_manager.store_semantic_memory(
                content=f"开始学习会话: {canvas_path}",
                metadata={
                    'canvas': os.path.basename(canvas_path),
                    'session_id': session_id,
                    'timestamp': datetime.now().isoformat()
                }
            )

            logger.info(f"语义记忆管理器启动成功，memory_id: {memory_id}")
            return {
                'status': 'running',
                'memory_id': memory_id,
                'storage': '向量数据库',
                'initialized_at': datetime.now().isoformat()
            }

        except Exception as e:
            logger.warning(f"语义记忆管理器启动失败: {e}")
            raise

    def _generate_session_id(self) -> str:
        """生成唯一的会话ID"""
        return f"session_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
```
```

---

## ✅ 修正完成

**修正的关键点**:
1. ✅ TemporalMemoryManager API - 方法名、参数、返回值全部修正
2. ✅ MCP工具调用方式 - 添加导入和错误处理说明
3. ✅ SemanticMemoryManager可用性检测 - 明确mcp_client检测方式
4. ✅ 核心实现结构 - 完整的修正代码

**下一步**:
请审阅以上内容，确认后我可以帮你：
1. 直接修改Story 10.10文件
2. 生成Story 10.11和10.12的修正内容
