# Story 12.11: graphiti-memory-agent调用接口

## Status: Approved

## Epic Context & Background

**所属Epic**: EPIC-12 - 三层记忆系统 + Agentic RAG
**Epic文档**: [EPIC-12-STORY-MAP.md](../epics/EPIC-12-STORY-MAP.md)

**本Story在Epic中的定位**:
- Phase 3 (Canvas集成层) 的工具封装Story
- 封装Graphiti MCP工具为统一的Agent调用接口
- **依赖**: Story 12.1 (Graphiti时序知识图谱集成完成)
- **被依赖**: Story 12.10, 12.12 (检验白板集成和LangSmith监控依赖此接口)

**Epic核心问题回顾**:

### Problem 11: MCP工具调用分散
- **现象**: 多处代码直接调用`mcp__graphiti_memory__*`工具，缺乏统一封装
- **根因**: 没有Wrapper层隔离MCP调用细节
- **修复**: 创建GraphitiMemoryWrapper封装所有Graphiti MCP调用
- **本Story验证**: 验证`add_episode()` / `search_memories()`接口工作正常

### Problem 12: 错误处理不一致
- **现象**: 各调用点的错误处理逻辑不统一
- **根因**: 没有统一的异常处理和重试机制
- **修复**: Wrapper层统一实现重试策略和错误转换
- **本Story验证**: 验证异常正确传播，重试机制生效

---

## Story

**As a** Canvas学习系统开发者,
**I want** 统一的Graphiti记忆系统调用接口,
**so that** 简化Agent开发，保证MCP调用的一致性和可靠性

---

## Acceptance Criteria

### AC 1: add_episode()封装正确工作 (验证Problem 11)
- **方法签名**:
  ```python
  async def add_episode(
      self,
      content: str,
      source_description: str = "Canvas Learning System",
      metadata: Optional[Dict] = None
  ) -> Dict[str, Any]
  ```
- **内部调用**: `mcp__graphiti_memory__add_episode(content=...)`
- **返回值**: `{"memory_id": "mem_xxx", "status": "success", "timestamp": "..."}`
- **验证方式**: 单元测试验证MCP调用正确
- **Source**: Graphiti Skill - "Adding Episodes (Core Operation)"

### AC 2: search_memories()封装正确工作 (验证Problem 11)
- **方法签名**:
  ```python
  async def search_memories(
      self,
      query: str,
      limit: int = 10,
      filters: Optional[Dict] = None
  ) -> List[Dict[str, Any]]
  ```
- **内部调用**: `mcp__graphiti_memory__search_memories(query=...)`
- **返回值**: `List[{"content": "...", "memory_id": "...", "score": 0.95, ...}]`
- **验证方式**: 单元测试验证搜索结果格式正确
- **Source**: Graphiti Skill - "Searching the Graph"

### AC 3: 错误处理和重试机制 (验证Problem 12)
- **重试策略**: 最多3次，指数退避(1s, 2s, 4s)
- **异常转换**: MCP错误 → `GraphitiConnectionError`
- **降级处理**: 连续失败后设置`available=False`标志
- **验证方式**: Mock MCP失败，验证重试行为

### AC 4: 与现有系统兼容
- **不破坏现有调用**: 现有`mcp__graphiti_memory__*`直接调用仍然有效
- **可选使用**: Wrapper是增强层，不是强制替换
- **集成测试**: 与Story 12.10检验白板集成测试通过

### AC扩展说明

> **注**: Epic Story Map (EPIC-12-STORY-MAP.md) 定义了2个基础AC:
> - AC1: add_episode() wrapper正确工作
> - AC2: search_memories() wrapper正确工作
>
> **AC3 (错误处理和重试机制)** 和 **AC4 (与现有系统兼容)** 是SM Agent在draft过程中的**细化增强**，
> 以确保Wrapper层的健壮性和生产可用性。这是Story对Epic AC的合理扩展，不是冲突。

---

## Tasks / Subtasks

### 任务1: 创建GraphitiMemoryWrapper类 (AC: 1, 2, 3)
- [ ] 1.0: 创建目录结构
  ```bash
  # 创建memory模块目录
  mkdir -p src/memory
  touch src/memory/__init__.py

  # 创建测试目录
  mkdir -p src/tests/memory
  touch src/tests/memory/__init__.py
  ```
- [ ] 1.1: 创建 `src/memory/graphiti_wrapper.py`
  ```python
  # ✅ Verified from Graphiti Skill - Adding Episodes (Core Operation)
  from typing import Dict, List, Optional, Any
  import asyncio
  import logging

  logger = logging.getLogger(__name__)

  class GraphitiConnectionError(Exception):
      """Graphiti连接错误"""
      pass

  class GraphitiMemoryWrapper:
      """
      Graphiti MCP工具的统一封装层

      提供:
      - add_episode(): 添加学习片段到知识图谱
      - search_memories(): 搜索记忆
      - 统一错误处理和重试机制
      """

      def __init__(self, max_retries: int = 3, retry_delay: float = 1.0):
          self.max_retries = max_retries
          self.retry_delay = retry_delay
          self._available = True
          self._consecutive_failures = 0
          self._failure_threshold = 5

      @property
      def available(self) -> bool:
          """检查Graphiti服务是否可用"""
          return self._available

      async def add_episode(
          self,
          content: str,
          source_description: str = "Canvas Learning System",
          metadata: Optional[Dict] = None
      ) -> Dict[str, Any]:
          """
          添加学习片段到Graphiti知识图谱

          Args:
              content: 学习内容文本
              source_description: 来源描述
              metadata: 可选的元数据字典

          Returns:
              包含memory_id和status的字典

          Raises:
              GraphitiConnectionError: 连接失败
          """
          return await self._execute_with_retry(
              "add_episode",
              content=content
          )

      async def search_memories(
          self,
          query: str,
          limit: int = 10,
          filters: Optional[Dict] = None
      ) -> List[Dict[str, Any]]:
          """
          搜索Graphiti知识图谱中的记忆

          Args:
              query: 搜索查询文本
              limit: 返回结果数量限制
              filters: 可选的过滤条件

          Returns:
              记忆结果列表

          Raises:
              GraphitiConnectionError: 连接失败
          """
          result = await self._execute_with_retry(
              "search_memories",
              query=query
          )
          # 确保返回列表格式
          if isinstance(result, list):
              return result[:limit]
          return []

      async def _execute_with_retry(
          self,
          operation: str,
          **kwargs
      ) -> Any:
          """
          带重试的MCP调用执行
          """
          last_error = None

          for attempt in range(self.max_retries):
              try:
                  result = await self._call_mcp(operation, **kwargs)
                  # 成功，重置失败计数
                  self._consecutive_failures = 0
                  self._available = True
                  return result
              except Exception as e:
                  last_error = e
                  logger.warning(
                      f"Graphiti {operation} 失败 (尝试 {attempt + 1}/{self.max_retries}): {e}"
                  )
                  if attempt < self.max_retries - 1:
                      # 指数退避
                      delay = self.retry_delay * (2 ** attempt)
                      await asyncio.sleep(delay)

          # 所有重试失败
          self._consecutive_failures += 1
          if self._consecutive_failures >= self._failure_threshold:
              self._available = False
              logger.error(f"Graphiti服务连续失败{self._failure_threshold}次，标记为不可用")

          raise GraphitiConnectionError(
              f"Graphiti {operation} 在{self.max_retries}次尝试后失败: {last_error}"
          )

      async def _call_mcp(self, operation: str, **kwargs) -> Any:
          """
          实际调用MCP工具
          """
          # ✅ Verified from existing codebase - MCP tool naming convention
          if operation == "add_episode":
              # 调用: mcp__graphiti_memory__add_episode
              from mcp_tools import mcp__graphiti_memory__add_episode
              return await mcp__graphiti_memory__add_episode(**kwargs)
          elif operation == "search_memories":
              # 调用: mcp__graphiti_memory__search_memories
              from mcp_tools import mcp__graphiti_memory__search_memories
              return await mcp__graphiti_memory__search_memories(**kwargs)
          else:
              raise ValueError(f"Unknown operation: {operation}")
  ```
- [ ] 1.2: 添加`__init__.py`导出
- [ ] 1.3: 测试: 验证类实例化成功

### 任务2: 实现list_memories和get_memory方法 (AC: 2扩展)
- [ ] 2.1: 添加`list_memories()`方法
  ```python
  async def list_memories(self) -> List[Dict[str, Any]]:
      """列出所有记忆"""
      return await self._execute_with_retry("list_memories")
  ```
- [ ] 2.2: 添加`get_memory(memory_id)`方法
  ```python
  async def get_memory(self, memory_id: str) -> Optional[Dict[str, Any]]:
      """获取特定记忆"""
      return await self._execute_with_retry("get_memory", memory_id=memory_id)
  ```
- [ ] 2.3: 更新`_call_mcp()`支持新操作

### 任务3: 创建便捷工厂函数 (AC: 4)
- [ ] 3.1: 创建全局实例获取函数
  ```python
  # 全局单例
  _wrapper_instance: Optional[GraphitiMemoryWrapper] = None

  def get_graphiti_wrapper() -> GraphitiMemoryWrapper:
      """获取Graphiti Wrapper全局实例"""
      global _wrapper_instance
      if _wrapper_instance is None:
          _wrapper_instance = GraphitiMemoryWrapper()
      return _wrapper_instance
  ```
- [ ] 3.2: 测试: 验证单例模式正确

### 任务4: 创建测试套件 (AC: 1-4)
- [ ] 4.1: 创建 `src/tests/memory/test_graphiti_wrapper.py`
- [ ] 4.2: 测试add_episode()正确调用MCP
  ```python
  @pytest.mark.asyncio
  async def test_add_episode_success():
      with patch('mcp_tools.mcp__graphiti_memory__add_episode') as mock_add:
          mock_add.return_value = {'memory_id': 'mem_123', 'status': 'success'}

          wrapper = GraphitiMemoryWrapper()
          result = await wrapper.add_episode(
              content="用户学习了离散数学的逻辑运算"
          )

          assert result['memory_id'] == 'mem_123'
          mock_add.assert_called_once_with(content="用户学习了离散数学的逻辑运算")
  ```
- [ ] 4.3: 测试search_memories()正确调用MCP
- [ ] 4.4: 测试重试机制
  ```python
  @pytest.mark.asyncio
  async def test_retry_on_failure():
      with patch('mcp_tools.mcp__graphiti_memory__add_episode') as mock_add:
          # 前两次失败，第三次成功
          mock_add.side_effect = [
              Exception("Connection error"),
              Exception("Timeout"),
              {'memory_id': 'mem_123', 'status': 'success'}
          ]

          wrapper = GraphitiMemoryWrapper(retry_delay=0.01)  # 快速测试
          result = await wrapper.add_episode(content="test")

          assert result['memory_id'] == 'mem_123'
          assert mock_add.call_count == 3
  ```
- [ ] 4.5: 测试连续失败后available标志
- [ ] 4.6: 测试与现有系统兼容

---

## Dev Notes

### Dependencies Verification

**前置依赖验证** (必须先完成):
- [ ] **Story 12.1已完成**: Graphiti时序知识图谱集成完成
- [ ] MCP Graphiti工具可用: `mcp__graphiti_memory__*`系列工具
- [ ] Neo4j服务运行正常

**技术栈依赖**:
- [ ] Python 3.9+ (asyncio支持)
- [ ] pytest-asyncio (异步测试)
- [ ] pytest-mock (Mock支持)

### SDD规范参考

**Graphiti API** [Source: Graphiti Skill - Adding Episodes]:

```python
# ✅ Verified from Graphiti Skill - add_episode
await graphiti.add_episode(
    name="user_conversation",
    episode_body="Kendra mentioned she loves Adidas shoes and runs marathons.",
    source_description="Chat conversation",
    reference_time=datetime.now()
)
```

**MCP工具命名规范** [Source: existing codebase]:

```python
# ✅ Verified from docs/epic-10-story-manager-handoff.md
mcp__graphiti_memory__add_episode(content="...")
mcp__graphiti_memory__add_memory(key="...", content="...", metadata={})
mcp__graphiti_memory__search_memories(query="...")
mcp__graphiti_memory__list_memories()
mcp__graphiti_memory__get_memory(memory_id="...")
```

**错误处理模式** [Source: docs/architecture/LANGGRAPH-MEMORY-INTEGRATION-DESIGN.md]:

```python
# ✅ Verified from Architecture doc - 重试队列模式
async def process_with_retry(task, max_retries=3):
    for attempt in range(max_retries):
        try:
            result = await execute_task(task)
            return result
        except Exception as e:
            if attempt < max_retries - 1:
                await asyncio.sleep(retry_delay * (2 ** attempt))
    raise RetryExhaustedError(...)
```

**JSON Schema** [Source: specs/data/graphiti-entity.schema.json]:

```json
// ✅ Verified from specs/data/graphiti-entity.schema.json
{
  "required": ["uuid", "name", "entity_type", "created_at"],
  "properties": {
    "uuid": { "type": "string", "format": "uuid" },
    "name": { "type": "string" },
    "entity_type": { "enum": ["concept", "canvas", "node", "document", "user"] },
    "summary": { "type": "string" },
    "attributes": {
      "canvas_path": { "type": "string" },
      "node_id": { "type": "string" },
      "color": { "enum": ["1", "2", "3", "5", "6"] },
      "score": { "type": "number", "minimum": 0, "maximum": 100 }
    }
  }
}
```

### ADR决策关联

**ADR-0003: Graphiti Memory System** [Source: docs/architecture/decisions/0003-graphiti-memory.md]:

| ADR编号 | 决策标题 | 对Story的影响 |
|---------|----------|---------------|
| ADR-0003 | 使用Graphiti作为时序知识图谱 | MCP调用必须异步执行 |

- **决策**: 使用Graphiti作为时序知识图谱
- **MCP集成**: 通过MCP工具调用Graphiti服务
- **本Story关系**: 封装MCP调用为统一接口

**关键约束** (从ADR-0003 Consequences提取):
- ⚠️ Graphiti查询必须**异步执行**（使用`await`），避免阻塞学习流程
- ⚠️ 所有写入操作必须使用**事务**保证数据一致性
- ⚠️ 实现**三级缓存**策略降低API成本（内存→磁盘→Neo4j）
- ⚠️ 重试策略使用**指数退避**（exponential backoff）

### 安全注意事项

⚠️ **凭据安全** (开发时注意):
- Neo4j连接凭据**不要硬编码**，使用环境变量 `NEO4J_PASSWORD`
- MCP工具调用日志中**脱敏敏感信息**（如memory内容的前50字符）
- 测试中使用**Mock**而非真实凭据

### Testing Standards

**测试文件位置**: `src/tests/memory/`

**测试类型**:
- 单元测试 (Mock MCP调用)
- 集成测试 (与真实Graphiti服务)

**Mock策略**:
- 使用`pytest-mock`的`patch`装饰器
- Mock `mcp_tools.mcp__graphiti_memory__*`函数
- 测试重试时使用快速延迟(0.01s)

**覆盖率目标**: ≥80%

### Related Documentation

**Epic和Story文档**:
- [EPIC-12-STORY-MAP.md](../epics/EPIC-12-STORY-MAP.md) - Epic 12完整Story Map
- [12.1.story.md](./12.1.story.md) - Graphiti时序知识图谱集成 (前置依赖)
- [12.10.story.md](./12.10.story.md) - Canvas检验白板生成集成 (后续Story)

**架构文档** [Source: docs/architecture/]:
- [GRAPHITI-KNOWLEDGE-GRAPH-INTEGRATION-ARCHITECTURE.md](../architecture/GRAPHITI-KNOWLEDGE-GRAPH-INTEGRATION-ARCHITECTURE.md) - Graphiti集成架构
- [0003-graphiti-memory.md](../architecture/decisions/0003-graphiti-memory.md) - Graphiti ADR

**外部文档**:
- Graphiti Skill: `.claude/skills/graphiti/SKILL.md`
- MCP Graphiti: 项目内MCP工具定义

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-28 | 1.0 | 初始创建 - SM Agent *draft | Bob (SM Agent) |
| 2025-11-28 | 1.1 | PO验证修复: 添加目录创建任务(C1), JSON Schema引用(S1), ADR约束(S2), AC扩展说明(S3), 安全注意事项(S4) | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*待填写*

### Debug Log References
*待填写*

### Completion Notes List
*待填写*

### File List
*待填写*

---

## QA Results

### Review Date: 2025-11-29

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: PASS** - Story 12.11 GraphitiMemoryWrapper设计完整，符合架构标准。

**优点**:
- ✅ AC 1-4 定义清晰，包含方法签名和验证方式
- ✅ 错误处理机制完善（指数退避、降级标志）
- ✅ 与Graphiti Skill文档保持一致
- ✅ ADR-0003决策关联完整，约束明确
- ✅ 安全注意事项（凭据脱敏）已标注

**技术亮点**:
- 单例模式工厂函数设计合理
- 重试策略使用指数退避符合ADR约束
- MCP工具调用封装层设计清晰

### Requirements Traceability (Given-When-Then)

| AC | Given | When | Then | 覆盖 |
|----|-------|------|------|------|
| AC1 | GraphitiMemoryWrapper实例化 | 调用add_episode() | 返回memory_id和status | ✅ |
| AC2 | GraphitiMemoryWrapper实例化 | 调用search_memories() | 返回List[Dict]结果 | ✅ |
| AC3 | MCP调用失败 | 触发重试机制 | 3次重试+指数退避 | ✅ |
| AC4 | 现有代码直接调用MCP | 使用Wrapper | 不影响现有调用 | ✅ |

### Compliance Check

- Coding Standards: ✓ 代码示例符合Python异步规范
- Project Structure: ✓ `src/memory/`目录结构正确
- Testing Strategy: ✓ 单元测试+Mock策略明确
- All ACs Met: ✓ 4个AC全部可验证
- ADR Compliance: ✓ ADR-0003约束已引用

### NFR Validation

| NFR | Status | Notes |
|-----|--------|-------|
| Security | ✅ PASS | 凭据使用环境变量，日志脱敏 |
| Performance | ✅ PASS | 异步执行，不阻塞学习流程 |
| Reliability | ✅ PASS | 重试+降级机制 |
| Maintainability | ✅ PASS | 代码注释清晰，文档完整 |

### Improvements Checklist

- [x] AC扩展说明已添加（SM细化合理性）
- [x] 安全注意事项已添加
- [x] JSON Schema引用已添加
- [ ] **建议**: 添加健康检查方法`is_healthy()`用于监控

### Gate Status

**Gate: PASS** → `docs/qa/gates/12.11-graphiti-memory-wrapper.yml`

### Recommended Status

✅ **Ready for Done** - Story规格完整，可进入开发
