# Story 12.15: E2E集成测试

## Status: Draft

## Epic Context & Background

**所属Epic**: EPIC-12 - 三层记忆系统 + Agentic RAG
**Epic文档**: [EPIC-12-STORY-MAP.md](../epics/EPIC-12-STORY-MAP.md)

**本Story在Epic中的定位**:
- Phase 3 (Testing & Monitoring) 的端到端验证Story
- 验证两个核心业务场景的完整流程
- **优先级**: P0 (必须完成)
- **依赖**: Story 12.10 (Canvas检验白板生成集成)
- **可并行**: Story 12.11, 12.12, 12.13, 12.14
- **后续**: Story 12.16 (文档和部署)

**Epic核心问题回顾**:

### Problem 17: 缺乏端到端验证
- **现象**: 单元测试通过但实际业务流程可能失败
- **根因**: 缺少覆盖完整用户旅程的E2E测试
- **修复**: 实现2个核心场景的E2E测试
- **本Story验证**: 检验白板生成 + 艾宾浩斯复习两个场景端到端通过

### 关联EAC-6: Canvas集成无缝
- **要求**: Epic 4集成成功, 360+测试通过, E2E通过
- **本Story贡献**: E2E测试通过验证

### 关联EAC-9: 测试覆盖
- **要求**: 单元测试≥80%, 集成测试2场景, 回归测试360+
- **本Story贡献**: 2个场景集成测试

---

## Story

**As a** Canvas学习系统用户,
**I want** 完整的端到端流程正常工作,
**so that** 从学习到复习的整个旅程无障碍，体验流畅

---

## Acceptance Criteria

### AC 1: 场景1 - 检验白板生成E2E (验证EAC-6)
- **场景描述**: 用户从Canvas生成检验白板的完整流程
- **测试步骤**:
  1. 加载测试Canvas文件 (`离散数学.canvas`)
  2. 提取红色/紫色节点
  3. 调用Agentic RAG检索薄弱点
  4. 生成检验题目
  5. 创建检验白板Canvas
  6. 验证检验白板内容正确
- **验证方式**:
  - E2E测试脚本自动执行
  - 检验白板文件成功创建
  - 包含至少5个检验题节点
  - 无Python异常
- **通过标准**: 端到端执行成功，无报错

### AC 2: 场景2 - 艾宾浩斯复习E2E (验证EAC-6)
- **场景描述**: 用户触发艾宾浩斯复习的完整流程
- **测试步骤**:
  1. 模拟用户学习完成事件
  2. 触发24小时复习提醒 (模拟时间)
  3. 调用Agentic RAG检索需复习内容
  4. 生成复习建议
  5. 更新FSRS记忆卡片状态
  6. 验证复习内容相关性
- **验证方式**:
  - E2E测试脚本自动执行
  - 复习内容与原学习内容相关
  - FSRS状态正确更新
  - 无Python异常
- **通过标准**: 端到端执行成功，无报错

### AC 3: 质量指标达标 (验证EAC-2)
- **检验白板场景**:
  - 检验题相关性 ≥ 85% (人工抽检10题)
  - 检索延迟 < 400ms (P95)
- **艾宾浩斯场景**:
  - 复习内容覆盖率 ≥ 90%
  - 检索延迟 < 400ms (P95)
- **验证方式**: 自动化测试输出质量指标

### AC 4: 错误处理和降级 (验证鲁棒性)
- **测试场景**:
  - Graphiti连接失败 → 降级到LanceDB单源检索
  - Cohere API超时 → 降级到Local Reranking
  - Neo4j不可用 → 使用缓存数据
- **验证方式**:
  - 注入故障后测试
  - 验证降级逻辑正确触发
  - 验证最终结果仍可用 (质量可能降低)
- **通过标准**: 所有降级场景正确处理，无崩溃

### AC 5: 日志和可追溯性 (验证EAC-8)
- **日志要求**:
  - 每个E2E测试生成trace ID
  - 关键步骤有结构化日志
  - 错误日志包含上下文
- **验证方式**:
  - 检查日志文件完整性
  - LangSmith trace可查看 (如启用)
- **通过标准**: 日志完整，可追溯执行路径

---

## Tasks / Subtasks

### 任务1: 创建E2E测试框架 (AC: 1-5)
- [ ] 1.1: 创建 `src/tests/e2e/__init__.py`
- [ ] 1.2: 创建 `src/tests/e2e/conftest.py`
  ```python
  """E2E测试配置"""
  import pytest
  import asyncio
  from pathlib import Path

  # 测试数据目录
  TEST_DATA_DIR = Path(__file__).parent / "fixtures"
  TEST_CANVAS_FILE = TEST_DATA_DIR / "test_discrete_math.canvas"
  OUTPUT_DIR = Path(__file__).parent / "output"

  @pytest.fixture(scope="session")
  def event_loop():
      """创建事件循环"""
      loop = asyncio.get_event_loop_policy().new_event_loop()
      yield loop
      loop.close()

  @pytest.fixture(scope="session")
  def test_canvas_path():
      """测试Canvas文件路径"""
      return str(TEST_CANVAS_FILE)

  @pytest.fixture(scope="session")
  def output_dir():
      """输出目录"""
      OUTPUT_DIR.mkdir(exist_ok=True)
      return OUTPUT_DIR

  @pytest.fixture
  def trace_id():
      """生成trace ID"""
      import uuid
      return str(uuid.uuid4())[:8]
  ```
- [ ] 1.3: 创建测试Canvas fixture
  ```json
  // src/tests/e2e/fixtures/test_discrete_math.canvas
  {
    "nodes": [
      {
        "id": "node_001",
        "type": "text",
        "text": "逆否命题",
        "color": "1"  // 红色 - 需要学习
      },
      {
        "id": "node_002",
        "type": "text",
        "text": "命题的否定与逆否命题的区别",
        "color": "4"  // 紫色 - 部分理解
      },
      {
        "id": "node_003",
        "type": "text",
        "text": "德摩根定律",
        "color": "5"  // 绿色 - 已掌握
      }
    ],
    "edges": []
  }
  ```

### 任务2: 实现场景1 - 检验白板生成E2E (AC: 1, 3, 5)
- [ ] 2.1: 创建 `src/tests/e2e/test_verification_canvas_e2e.py`
  ```python
  """检验白板生成E2E测试"""
  import pytest
  import json
  import logging
  from pathlib import Path

  from src.canvas_utils import CanvasOrchestrator
  from src.agentic_rag.state_graph import canvas_agentic_rag

  logger = logging.getLogger(__name__)

  @pytest.mark.e2e
  @pytest.mark.asyncio
  async def test_verification_canvas_generation_e2e(
      test_canvas_path: str,
      output_dir: Path,
      trace_id: str
  ):
      """
      E2E测试: 检验白板生成完整流程

      步骤:
      1. 加载测试Canvas
      2. 提取红色/紫色节点
      3. 调用Agentic RAG
      4. 生成检验白板
      5. 验证结果
      """
      logger.info(f"[{trace_id}] Starting verification canvas E2E test")

      # Step 1: 初始化Orchestrator
      orchestrator = CanvasOrchestrator()
      logger.info(f"[{trace_id}] Orchestrator initialized")

      # Step 2: 生成检验白板
      output_path = output_dir / f"verification_canvas_{trace_id}.canvas"

      try:
          result_path = await orchestrator.generate_verification_canvas(
              canvas_file=test_canvas_path,
              output_canvas_file=str(output_path)
          )
          logger.info(f"[{trace_id}] Verification canvas generated: {result_path}")
      except Exception as e:
          logger.error(f"[{trace_id}] Failed to generate verification canvas: {e}")
          pytest.fail(f"E2E test failed: {e}")

      # Step 3: 验证输出文件存在
      assert output_path.exists(), f"Output file not created: {output_path}"

      # Step 4: 验证Canvas内容
      with open(output_path) as f:
          canvas_data = json.load(f)

      nodes = canvas_data.get("nodes", [])
      logger.info(f"[{trace_id}] Generated {len(nodes)} nodes")

      # 验证至少有5个检验题节点
      question_nodes = [n for n in nodes if "?" in n.get("text", "") or "检验" in n.get("text", "")]
      assert len(question_nodes) >= 5, f"Expected at least 5 question nodes, got {len(question_nodes)}"

      logger.info(f"[{trace_id}] E2E test PASSED")

  @pytest.mark.e2e
  @pytest.mark.asyncio
  async def test_verification_canvas_quality(
      test_canvas_path: str,
      output_dir: Path,
      trace_id: str
  ):
      """
      E2E测试: 检验白板质量验证

      验证检验题与原Canvas内容相关
      """
      logger.info(f"[{trace_id}] Starting quality verification")

      orchestrator = CanvasOrchestrator()
      output_path = output_dir / f"quality_test_{trace_id}.canvas"

      # 生成检验白板
      await orchestrator.generate_verification_canvas(
          canvas_file=test_canvas_path,
          output_canvas_file=str(output_path)
      )

      # 加载原Canvas
      with open(test_canvas_path) as f:
          original = json.load(f)

      # 加载生成的检验白板
      with open(output_path) as f:
          verification = json.load(f)

      # 提取原Canvas的关键词
      original_keywords = set()
      for node in original.get("nodes", []):
          text = node.get("text", "")
          # 简单分词
          original_keywords.update(text.split())

      # 检查检验题是否包含原关键词
      relevant_count = 0
      total_questions = 0

      for node in verification.get("nodes", []):
          text = node.get("text", "")
          if "?" in text or "检验" in text:
              total_questions += 1
              # 检查是否包含原关键词
              if any(kw in text for kw in original_keywords):
                  relevant_count += 1

      if total_questions > 0:
          relevance_rate = relevant_count / total_questions
          logger.info(f"[{trace_id}] Relevance rate: {relevance_rate:.2%}")
          assert relevance_rate >= 0.85, f"Relevance rate {relevance_rate:.2%} < 85%"

      logger.info(f"[{trace_id}] Quality verification PASSED")
  ```
- [ ] 2.2: 添加延迟测量
- [ ] 2.3: 运行并验证测试

### 任务3: 实现场景2 - 艾宾浩斯复习E2E (AC: 2, 3, 5)
- [ ] 3.1: 创建 `src/tests/e2e/test_ebbinghaus_review_e2e.py`
  ```python
  """艾宾浩斯复习E2E测试"""
  import pytest
  import logging
  from datetime import datetime, timedelta
  from unittest.mock import patch

  from src.ebbinghaus_review import EbbinghausReviewSystem
  from src.agentic_rag.state_graph import canvas_agentic_rag

  logger = logging.getLogger(__name__)

  @pytest.mark.e2e
  @pytest.mark.asyncio
  async def test_ebbinghaus_24h_review_e2e(
      test_canvas_path: str,
      trace_id: str
  ):
      """
      E2E测试: 艾宾浩斯24小时复习流程

      步骤:
      1. 模拟学习完成
      2. 模拟时间推进24小时
      3. 触发复习
      4. 验证复习内容
      """
      logger.info(f"[{trace_id}] Starting Ebbinghaus 24h review E2E test")

      # Step 1: 初始化复习系统
      review_system = EbbinghausReviewSystem()

      # Step 2: 模拟学习完成事件
      learning_event = {
          "canvas_path": test_canvas_path,
          "learned_concepts": ["逆否命题", "德摩根定律"],
          "timestamp": datetime.now() - timedelta(hours=24)
      }

      await review_system.record_learning_event(learning_event)
      logger.info(f"[{trace_id}] Learning event recorded")

      # Step 3: 触发24小时复习
      with patch('src.ebbinghaus_review.datetime') as mock_datetime:
          mock_datetime.now.return_value = datetime.now()

          review_items = await review_system.get_due_reviews()
          logger.info(f"[{trace_id}] Found {len(review_items)} items due for review")

      # Step 4: 对每个复习项调用Agentic RAG
      for item in review_items:
          query = f"复习概念: {item['concept']}"

          result = await canvas_agentic_rag.ainvoke({
              "query": query,
              "canvas_file": test_canvas_path,
              "is_review_mode": True
          })

          # 验证结果
          assert "reranked_results" in result, "Missing reranked_results"
          assert len(result["reranked_results"]) > 0, "Empty results"

          logger.info(f"[{trace_id}] Review for '{item['concept']}': {len(result['reranked_results'])} results")

      # Step 5: 更新FSRS状态
      for item in review_items:
          await review_system.update_review_status(
              item["id"],
              quality=4  # Good
          )

      logger.info(f"[{trace_id}] FSRS status updated")
      logger.info(f"[{trace_id}] E2E test PASSED")

  @pytest.mark.e2e
  @pytest.mark.asyncio
  async def test_ebbinghaus_coverage(
      test_canvas_path: str,
      trace_id: str
  ):
      """
      E2E测试: 复习内容覆盖率

      验证复习内容覆盖原学习内容≥90%
      """
      logger.info(f"[{trace_id}] Starting coverage test")

      review_system = EbbinghausReviewSystem()

      # 模拟多个学习概念
      concepts = ["逆否命题", "命题的否定", "德摩根定律", "量词", "蕴含关系"]

      for concept in concepts:
          await review_system.record_learning_event({
              "canvas_path": test_canvas_path,
              "learned_concepts": [concept],
              "timestamp": datetime.now() - timedelta(hours=24)
          })

      # 获取复习项
      review_items = await review_system.get_due_reviews()

      # 计算覆盖率
      reviewed_concepts = {item["concept"] for item in review_items}
      coverage = len(reviewed_concepts & set(concepts)) / len(concepts)

      logger.info(f"[{trace_id}] Coverage: {coverage:.2%}")
      assert coverage >= 0.90, f"Coverage {coverage:.2%} < 90%"

      logger.info(f"[{trace_id}] Coverage test PASSED")
  ```
- [ ] 3.2: 添加FSRS状态验证
- [ ] 3.3: 运行并验证测试

### 任务4: 实现降级和错误处理测试 (AC: 4)
- [ ] 4.1: 创建 `src/tests/e2e/test_degradation_e2e.py`
  ```python
  """降级和错误处理E2E测试"""
  import pytest
  import logging
  from unittest.mock import patch, AsyncMock

  from src.canvas_utils import CanvasOrchestrator

  logger = logging.getLogger(__name__)

  @pytest.mark.e2e
  @pytest.mark.asyncio
  async def test_graphiti_failure_degradation(
      test_canvas_path: str,
      output_dir,
      trace_id: str
  ):
      """
      测试: Graphiti连接失败时降级到LanceDB
      """
      logger.info(f"[{trace_id}] Testing Graphiti failure degradation")

      orchestrator = CanvasOrchestrator()

      # Mock Graphiti连接失败
      with patch('src.agentic_rag.nodes.retrieval.graphiti_client') as mock_graphiti:
          mock_graphiti.search.side_effect = ConnectionError("Graphiti unavailable")

          output_path = output_dir / f"degradation_test_{trace_id}.canvas"

          # 应该降级到LanceDB，而不是崩溃
          try:
              result = await orchestrator.generate_verification_canvas(
                  canvas_file=test_canvas_path,
                  output_canvas_file=str(output_path)
              )
              logger.info(f"[{trace_id}] Degradation successful, using LanceDB only")
              assert output_path.exists(), "Output should still be created"
          except Exception as e:
              pytest.fail(f"Should not crash on Graphiti failure: {e}")

  @pytest.mark.e2e
  @pytest.mark.asyncio
  async def test_cohere_timeout_degradation(
      test_canvas_path: str,
      output_dir,
      trace_id: str
  ):
      """
      测试: Cohere API超时时降级到Local Reranking
      """
      logger.info(f"[{trace_id}] Testing Cohere timeout degradation")

      orchestrator = CanvasOrchestrator()

      # Mock Cohere超时
      with patch('src.agentic_rag.nodes.reranking.cohere_client') as mock_cohere:
          mock_cohere.rerank.side_effect = TimeoutError("Cohere API timeout")

          output_path = output_dir / f"cohere_degradation_{trace_id}.canvas"

          try:
              result = await orchestrator.generate_verification_canvas(
                  canvas_file=test_canvas_path,
                  output_canvas_file=str(output_path)
              )
              logger.info(f"[{trace_id}] Degradation successful, using Local Reranking")
              assert output_path.exists(), "Output should still be created"
          except Exception as e:
              pytest.fail(f"Should not crash on Cohere timeout: {e}")

  @pytest.mark.e2e
  @pytest.mark.asyncio
  async def test_neo4j_unavailable_degradation(
      test_canvas_path: str,
      output_dir,
      trace_id: str
  ):
      """
      测试: Neo4j不可用时使用缓存
      """
      logger.info(f"[{trace_id}] Testing Neo4j unavailable degradation")

      orchestrator = CanvasOrchestrator()

      # Mock Neo4j连接失败
      with patch('src.agentic_rag.nodes.retrieval.neo4j_driver') as mock_neo4j:
          mock_neo4j.session.side_effect = Exception("Neo4j connection refused")

          output_path = output_dir / f"neo4j_degradation_{trace_id}.canvas"

          try:
              result = await orchestrator.generate_verification_canvas(
                  canvas_file=test_canvas_path,
                  output_canvas_file=str(output_path)
              )
              logger.info(f"[{trace_id}] Degradation successful, using cache")
          except Exception as e:
              # Neo4j是核心依赖，可能需要更严格的处理
              logger.warning(f"[{trace_id}] Neo4j failure handling: {e}")
  ```
- [ ] 4.2: 添加更多降级场景
- [ ] 4.3: 验证日志记录正确

### 任务5: 创建E2E测试执行脚本 (AC: 1-5)
- [ ] 5.1: 创建 `scripts/run_e2e_tests.py`
  ```python
  #!/usr/bin/env python3
  """E2E测试执行脚本"""
  import subprocess
  import sys
  from pathlib import Path

  def main():
      print("=" * 60)
      print("Epic 12 E2E Integration Tests")
      print("=" * 60)

      # 运行E2E测试
      result = subprocess.run([
          "pytest",
          "src/tests/e2e/",
          "-v",
          "--tb=short",
          "-m", "e2e",
          "--log-cli-level=INFO"
      ], cwd=Path(__file__).parent.parent)

      if result.returncode == 0:
          print("\n" + "=" * 60)
          print("ALL E2E TESTS PASSED")
          print("=" * 60)
      else:
          print("\n" + "=" * 60)
          print("SOME E2E TESTS FAILED")
          print("=" * 60)

      return result.returncode

  if __name__ == "__main__":
      sys.exit(main())
  ```
- [ ] 5.2: 添加到CI/CD workflow
- [ ] 5.3: 创建E2E测试报告模板

### 任务6: 文档和报告 (AC: 1-5)
- [ ] 6.1: 创建 `docs/qa/e2e-test-report-epic12.md`
- [ ] 6.2: 记录E2E测试方法论
- [ ] 6.3: 保存E2E测试结果

---

## Dev Notes

### Dependencies Verification

**前置依赖验证** (必须先完成):
- [ ] **Story 12.10已完成**: Canvas检验白板生成集成可用
- [ ] **Agentic RAG StateGraph可用**: `canvas_agentic_rag.ainvoke()`

**可并行Story** (非强依赖，可同时开发):
- Story 12.11 (Query重写循环)
- Story 12.12 (成本监控仪表盘)
- Story 12.13 (回归测试)
- Story 12.14 (性能基准测试)

**技术栈依赖**:
- [ ] pytest >= 7.0.0
- [ ] pytest-asyncio >= 0.21.0
- [ ] pytest-timeout (超时控制)

### SDD规范参考

**E2E测试标准** [Source: BMad QA checklist]:

1. **场景覆盖**: 至少2个核心业务场景
2. **端到端**: 从用户输入到最终输出
3. **降级测试**: 验证故障处理
4. **日志可追溯**: 每个测试有trace ID

**两个核心场景** [Source: Epic 12 EAC-6]:

| 场景 | 入口 | 出口 | 验证点 |
|------|------|------|--------|
| 检验白板生成 | Canvas文件 | 检验白板文件 | 文件存在, 包含检验题, 相关性≥85% |
| 艾宾浩斯复习 | 学习事件 | 复习建议 | 覆盖率≥90%, FSRS更新 |

### Testing Standards

**测试文件位置**: `src/tests/e2e/`

**测试标记**:
```python
@pytest.mark.e2e  # E2E测试标记
@pytest.mark.asyncio  # 异步测试
@pytest.mark.slow  # 慢速测试 (可选跳过)
```

**运行E2E测试**:
```bash
# 只运行E2E测试
pytest src/tests/e2e/ -m e2e -v

# 包含日志输出
pytest src/tests/e2e/ -m e2e -v --log-cli-level=INFO

# 排除慢速测试
pytest src/tests/e2e/ -m "e2e and not slow" -v
```

### Related Documentation

**Epic和Story文档**:
- [EPIC-12-STORY-MAP.md](../epics/EPIC-12-STORY-MAP.md) - Epic 12完整Story Map
- [12.10.story.md](./12.10.story.md) - Canvas检验白板生成集成 (前置依赖)
- [12.13.story.md](./12.13.story.md) - 回归测试 (前置依赖)
- [12.14.story.md](./12.14.story.md) - 性能基准测试 (前置依赖)
- [12.16.story.md](./12.16.story.md) - 文档和部署 (后续Story)

**架构文档**:
- [canvas_utils.py](../../src/canvas_utils.py) - CanvasOrchestrator实现
- [ebbinghaus_review.py](../../src/ebbinghaus_review.py) - 艾宾浩斯复习系统

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-28 | 1.0 | 初始创建 - SM Agent *draft | Bob (SM Agent) |

---

## Dev Agent Record

### Agent Model Used
*待填写*

### Debug Log References
*待填写*

### Completion Notes List
*待填写*

### File List
*待填写*

---

## QA Results

### Review Date: 2025-11-29

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: PASS** - Story 12.15 E2E集成测试设计全面。

**优点**:
- ✅ AC 1-5 覆盖两个核心业务场景
- ✅ 检验白板生成E2E流程完整
- ✅ 艾宾浩斯复习E2E流程完整
- ✅ 降级测试覆盖Graphiti/Cohere/Neo4j三种故障
- ✅ trace_id实现可追溯性

**技术亮点**:
- conftest.py fixture设计合理
- 测试Canvas JSON fixture完整
- 降级场景Mock策略正确

### Requirements Traceability (Given-When-Then)

| AC | Given | When | Then | 覆盖 |
|----|-------|------|------|------|
| AC1 | 测试Canvas文件 | 生成检验白板 | 文件创建，≥5个检验题 | ✅ |
| AC2 | 学习事件 | 触发24h复习 | 复习内容相关，FSRS更新 | ✅ |
| AC3 | 检验/复习场景 | 验证质量指标 | 相关性≥85%, 覆盖率≥90% | ✅ |
| AC4 | 注入故障 | 触发降级 | 正确降级，无崩溃 | ✅ |
| AC5 | E2E执行 | 检查日志 | trace ID完整 | ✅ |

### Compliance Check

- Coding Standards: ✓ pytest-asyncio规范
- Project Structure: ✓ `src/tests/e2e/`目录正确
- Testing Strategy: ✓ E2E+降级测试
- All ACs Met: ✓ 5个AC全部可验证
- ADR Compliance: ✓ EAC-6引用正确

### NFR Validation

| NFR | Status | Notes |
|-----|--------|-------|
| Security | ✅ PASS | N/A |
| Performance | ✅ PASS | P95<400ms验证 |
| Reliability | ✅ PASS | 降级测试覆盖 |
| Maintainability | ✅ PASS | fixture复用性好 |

### Improvements Checklist

- [x] 测试Canvas fixture已定义
- [x] 降级测试场景完整
- [ ] **建议**: 添加更多边界条件测试
- [ ] **建议**: 添加超时测试(pytest-timeout)

### Gate Status

**Gate: PASS** → `docs/qa/gates/12.15-e2e-integration-tests.yml`

### Recommended Status

✅ **Ready for Done** - Story规格完整，可进入开发
