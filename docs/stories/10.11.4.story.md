# Story 10.11.4: 3层降级策略和统一错误处理

## Status
Ready for Review

## Metadata
- **Epic**: Epic 10.11 - Canvas记忆系统启动修复与降级机制
- **Priority**: P1 (高)
- **Estimated Effort**: 2天
- **Risk Level**: 🟢 LOW - 纯增强功能，不修改核心逻辑
- **Assignee**: Dev Agent (James)
- **Sprint**: Epic 10.11 Sprint 1
- **Dependencies**: Story 10.11.1, 10.11.2, 10.11.3 (所有记忆管理器的降级机制)

## Story

**As a** Canvas Learning System的用户,
**I want** 系统能根据可用组件智能降级到合适的运行模式（完整/部分/基础），并清晰告知我当前功能限制,
**so that** 我可以在不完美的环境中继续学习，而不是完全无法使用系统，明确知道哪些功能可用、哪些不可用。

## Acceptance Criteria

### AC1: 定义3层运行模式
✅ 明确定义Canvas Learning System的3层运行模式：

**完整模式 (Full Mode)**: 所有3个记忆系统完全可用
- ✅ 时序记忆管理器 (Temporal Memory) - Neo4j模式
- ✅ Graphiti知识图谱 (Knowledge Graph) - MCP Graphiti服务器
- ✅ 语义记忆管理器 (Semantic Memory) - MCP完整模式

**部分模式 (Partial Mode)**: 2/3系统可用
- ✅ 时序记忆管理器 - Neo4j模式
- ❌ Graphiti知识图谱 - MCP服务器未连接
- ✅ 语义记忆管理器 - 降级模式（本地缓存）

**基础模式 (Basic Mode)**: 仅SQLite降级
- ❌ 时序记忆管理器 - Neo4j不可用
- ❌ Graphiti知识图谱 - MCP服务器未连接
- ✅ 语义记忆管理器 - 降级模式（本地缓存）

### AC2: 创建SystemModeDetector类
✅ 创建`memory_system/system_mode_detector.py`，实现系统模式检测：
```python
class SystemModeDetector:
    """检测Canvas Learning System的运行模式"""

    @staticmethod
    def detect_mode(temporal_manager, graphiti_available, semantic_manager) -> dict:
        """检测当前系统运行模式

        Args:
            temporal_manager: TemporalMemoryManager实例
            graphiti_available: bool，Graphiti是否可用
            semantic_manager: SemanticMemoryManager实例

        Returns:
            {
                'mode': str,  # 'full' | 'partial' | 'basic'
                'available_systems': List[str],
                'unavailable_systems': List[str],
                'functionality_impact': str
            }
        """
        # 检测各系统状态
        temporal_ok = temporal_manager.is_initialized and temporal_manager.mode == 'neo4j'
        graphiti_ok = graphiti_available
        semantic_ok = semantic_manager.is_initialized
        semantic_mode = semantic_manager.mode if semantic_ok else 'unavailable'

        # 计算可用系统数量
        available_count = sum([temporal_ok, graphiti_ok, semantic_ok])

        # 确定模式
        if available_count == 3 and semantic_mode == 'mcp':
            mode = 'full'
        elif available_count >= 2:
            mode = 'partial'
        else:
            mode = 'basic'

        # 构建返回结果
        return {
            'mode': mode,
            'available_systems': _build_available_list(temporal_ok, graphiti_ok, semantic_ok, semantic_mode),
            'unavailable_systems': _build_unavailable_list(temporal_ok, graphiti_ok, semantic_ok, semantic_mode),
            'functionality_impact': _describe_impact(mode, temporal_ok, graphiti_ok, semantic_ok, semantic_mode)
        }
```

### AC3: 在/learning命令开头显示模式横幅
✅ 在`command_handlers/learning_commands.py`中，`/learning`命令入口显示启动横幅：
```
========================================
Canvas Learning System 启动成功
运行模式: 部分模式 (2/3系统可用)

✅ 时序记忆管理器 [Neo4j模式]
✅ 语义记忆管理器 [降级模式 - 本地缓存]
❌ Graphiti知识图谱 [MCP服务器未连接]

影响: 知识图谱功能不可用，学习会话记录功能正常

提示: 运行 deployment\start_all_mcp_servers.bat 启动Graphiti
========================================
```

**横幅格式要求**:
- 清晰显示运行模式（完整/部分/基础）
- 列出所有3个系统的状态（✅可用/❌不可用）
- 对每个不可用系统，显示其模式或原因
- 说明功能影响（哪些功能受限）
- 提供快速修复建议（如果有）

### AC4: 创建format_startup_report()函数
✅ 实现友好的启动报告生成函数：
```python
def format_startup_report(mode_info: dict) -> str:
    """生成友好的系统启动报告

    Args:
        mode_info: SystemModeDetector.detect_mode()的返回值

    Returns:
        格式化的启动报告字符串（见AC3示例）
    """
    # 1. 标题和模式
    report = "=" * 40 + "\n"
    report += "Canvas Learning System 启动成功\n"
    report += f"运行模式: {MODE_NAMES[mode_info['mode']]} ({len(mode_info['available_systems'])}/3系统可用)\n\n"

    # 2. 系统状态列表
    for system in mode_info['available_systems']:
        report += f"✅ {system}\n"
    for system in mode_info['unavailable_systems']:
        report += f"❌ {system}\n"

    # 3. 功能影响说明
    report += f"\n影响: {mode_info['functionality_impact']}\n"

    # 4. 快速修复建议（如果有）
    if mode_info['unavailable_systems']:
        suggestions = generate_fix_suggestions(mode_info['unavailable_systems'])
        report += f"\n提示: {suggestions}\n"

    report += "=" * 40
    return report
```

### AC5: 实现功能限制检查
✅ 在需要特定系统的命令中，检查系统可用性并提供降级提示：
```python
def require_graphiti(mode_info: dict):
    """检查Graphiti是否可用，不可用时显示降级提示

    用于需要Graphiti功能的命令（如/graph-commands）
    """
    if 'Graphiti知识图谱' in mode_info['unavailable_systems']:
        print("❌ 此功能需要Graphiti知识图谱")
        print("当前模式: 部分模式 - Graphiti不可用")
        print("\n解决方案:")
        print("1. 启动MCP服务器: deployment\\start_all_mcp_servers.bat")
        print("2. 或使用其他功能: /learning（不依赖Graphiti）")
        return False
    return True

# 使用示例
@command('/graph-commands')
def graph_commands_handler(mode_info):
    if not require_graphiti(mode_info):
        return  # 显示降级提示并退出

    # 执行Graphiti相关功能
    ...
```

## Tasks / Subtasks

### Task 1: 创建SystemModeDetector类 (AC1, AC2)
- [ ] 在`memory_system/`目录下创建`system_mode_detector.py`
- [ ] 定义3层模式常量：
  ```python
  MODE_FULL = 'full'
  MODE_PARTIAL = 'partial'
  MODE_BASIC = 'basic'

  MODE_NAMES = {
      'full': '完整模式',
      'partial': '部分模式',
      'basic': '基础模式'
  }
  ```
- [ ] 实现`SystemModeDetector`类
- [ ] 实现`detect_mode()`静态方法（见AC2）
- [ ] 实现`_build_available_list()`辅助函数
  - 根据各系统状态构建可用系统列表
  - 格式：`["时序记忆管理器 [Neo4j模式]", "语义记忆管理器 [降级模式]"]`
- [ ] 实现`_build_unavailable_list()`辅助函数
  - 格式：`["Graphiti知识图谱 [MCP服务器未连接]"]`
- [ ] 实现`_describe_impact()`辅助函数
  - 根据不可用系统生成功能影响描述
  - 示例：
    - Graphiti不可用: "知识图谱功能不可用，学习会话记录功能正常"
    - Temporal不可用: "时序记忆功能受限，使用本地缓存"
    - Semantic降级: "高级语义搜索不可用，使用关键词搜索"

### Task 2: 创建启动报告生成器 (AC3, AC4)
- [ ] 在`memory_system/`目录下创建`error_formatters.py`
- [ ] 实现`format_startup_report(mode_info)`函数（见AC4）
- [ ] 实现`generate_fix_suggestions(unavailable_systems)`函数
  - 根据不可用系统生成修复建议
  - Graphiti不可用: "运行 deployment\start_all_mcp_servers.bat 启动Graphiti"
  - Neo4j不可用: "启动Neo4j数据库: neo4j.bat console"
  - Semantic降级: "修复MCP客户端: 运行 deployment\diagnose_mcp_client.py"
- [ ] 实现MODE_NAMES映射（中文模式名称）
- [ ] 添加type hints和docstring

### Task 3: 创建模式信息存储机制 (依赖: Task 1, Task 2)
- [ ] 在`command_handlers/learning_commands.py`中添加全局变量或session存储
  ```python
  # 全局变量存储当前模式信息
  _current_mode_info = None

  def set_mode_info(mode_info):
      global _current_mode_info
      _current_mode_info = mode_info

  def get_mode_info():
      return _current_mode_info
  ```
- [ ] 在/learning命令启动时调用set_mode_info()
- [ ] 在其他命令中通过get_mode_info()获取模式信息
- [ ] 确保线程安全（如果需要）

### Task 4: 集成到/learning命令 (AC3) (依赖: Task 1, Task 2, Task 3)
- [ ] 打开`command_handlers/learning_commands.py`
- [ ] 在`/learning`命令入口添加模式检测：
  ```python
  # 检测系统模式
  mode_info = SystemModeDetector.detect_mode(
      temporal_manager=temporal_manager,
      graphiti_available=graphiti_available,
      semantic_manager=semantic_manager
  )

  # 显示启动横幅
  startup_report = format_startup_report(mode_info)
  print(startup_report)

  # 存储mode_info供后续命令使用
  set_mode_info(mode_info)
  ```
- [ ] 确保在所有3个记忆管理器初始化后才执行检测
- [ ] 验证横幅格式符合AC3要求

### Task 5: 实现功能限制检查装饰器 (AC5) (依赖: Task 2)
- [ ] 在`memory_system/error_formatters.py`中添加功能限制检查函数
- [ ] 实现`require_graphiti(mode_info) -> bool`函数（见AC5）
- [ ] 实现`require_temporal(mode_info) -> bool`函数
  - 检查时序记忆是否可用
  - 不可用时显示降级提示
- [ ] 实现`require_semantic_advanced(mode_info) -> bool`函数
  - 检查高级语义搜索是否可用（MCP模式）
  - 降级模式时显示功能限制提示
- [ ] 创建装饰器版本（可选）：
  ```python
  @requires_system('graphiti')
  def graph_commands_handler():
      ...
  ```

### Task 6: 更新/graph-commands等依赖特定系统的命令 (AC5) (依赖: Task 5)
- [ ] 找到所有依赖Graphiti的命令
  - `/graph-commands` (在`.claude/commands/graph-commands.md`)
  - 使用Grep搜索: `pattern="mcp__graphiti" path="command_handlers/"`
- [ ] 在命令入口添加`require_graphiti()`检查
- [ ] 找到所有依赖高级语义搜索的命令
- [ ] 在命令入口添加`require_semantic_advanced()`检查
- [ ] 验证降级提示清晰且可操作

### Task 7: 单元测试 (AC1, AC2, AC4)
- [ ] 创建`tests/test_system_mode_detector.py`
- [ ] 测试detect_mode()函数
  - 场景1: 所有系统可用 + semantic=mcp → mode='full'
  - 场景2: temporal+semantic可用，graphiti不可用 → mode='partial'
  - 场景3: 只有semantic可用 → mode='basic'
  - 场景4: temporal可用，semantic降级 → mode='partial'（验证semantic_mode正确识别）
- [ ] 测试_build_available_list()和_build_unavailable_list()
  - 验证系统名称和状态正确
- [ ] 测试_describe_impact()
  - 验证功能影响描述准确
- [ ] 创建`tests/test_error_formatters.py`
- [ ] 测试format_startup_report()
  - 验证横幅格式符合AC3要求
  - 验证包含所有必需信息
- [ ] 测试generate_fix_suggestions()
  - 验证建议准确且可操作

### Task 8: 集成测试 (AC3, AC5)
- [ ] 创建`tests/test_mode_detection_integration.py`
- [ ] 测试/learning命令启动流程
  - Mock不同的系统可用性组合
  - 验证正确的模式检测
  - 验证横幅正确显示
- [ ] 测试功能限制检查
  - Mock Graphiti不可用
  - 调用/graph-commands
  - 验证显示降级提示
- [ ] 测试模式信息存储和访问
  - 验证set_mode_info()和get_mode_info()正确工作

### Task 9: 向后兼容性测试 (AC1-AC5)
- [ ] 运行所有420个现有测试：`pytest tests/`
- [ ] 确保100%通过
- [ ] 验证测试时间增加 <2秒
- [ ] 验证所有Sub-agent接口不受影响
- [ ] 验证现有命令在完整模式下功能不变

### Task 10: 手动端到端测试
- [ ] 场景1: 完整模式
  - 启动所有系统（Neo4j + MCP服务器）
  - 运行/learning命令
  - 验证显示"完整模式 (3/3系统可用)"
  - 验证所有功能正常工作
- [ ] 场景2: 部分模式（Graphiti不可用）
  - 停止MCP服务器
  - 运行/learning命令
  - 验证显示"部分模式 (2/3系统可用)"
  - 验证Graphiti功能显示降级提示
  - 验证其他功能正常工作
- [ ] 场景3: 基础模式（只有semantic可用）
  - 停止Neo4j和MCP服务器
  - 运行/learning命令
  - 验证显示"基础模式"
  - 验证功能影响描述准确
  - 验证降级提示有用

## Dev Notes

### 依赖接口规范

**重要**: 本Story依赖于Stories 10.11.1-3的接口，以下是精确的接口定义：

#### 来自 Story 10.11.1: TemporalMemoryManager

**接口定义**:
```python
# memory_system/temporal_memory_manager.py

class TemporalMemoryManager:
    def __init__(self, config):
        self.is_initialized: bool  # True if manager started successfully
        self.mode: str  # 'neo4j' | 'sqlite' | 'unavailable'
        # ...

    # 使用示例:
    temporal_manager = TemporalMemoryManager(config)
    if temporal_manager.is_initialized and temporal_manager.mode == 'neo4j':
        # Neo4j模式运行中
```

**接口含义**:
- `is_initialized=True, mode='neo4j'` → Neo4j连接成功
- `is_initialized=True, mode='sqlite'` → 降级到SQLite
- `is_initialized=False` → 完全不可用

#### 来自 Story 10.11.2: MCP Graphiti健康检查

**接口定义**:
```python
# memory_system/mcp_health_check.py

async def check_mcp_server_health(timeout: int = 2) -> dict:
    """
    Returns:
        {
            'available': bool,  # MCP Graphiti服务器是否可用
            'error': str,  # 错误描述（如果available=False）
            'suggestion': str,  # 操作建议
            'mcp_server_path': str  # MCP服务器路径
        }
    """

# 使用示例:
health_result = await check_mcp_server_health()
graphiti_available = health_result['available']
```

**接口含义**:
- `available=True` → MCP Graphiti服务器健康，可以使用
- `available=False` → 服务器不可用，`error`字段包含详细原因

#### 来自 Story 10.11.3: SemanticMemoryManager

**接口定义**:
```python
# memory_system/semantic_memory_manager.py

class SemanticMemoryManager:
    def __init__(self, config):
        self.is_initialized: bool  # True if manager started (any mode)
        self.mode: str  # 'mcp' | 'fallback' | 'unavailable'
        self.mcp_client: Optional[MCPMemoryClient]  # MCP客户端（如果mode='mcp'）
        self.fallback_cache: Optional[LocalSemanticCache]  # 本地缓存（如果mode='fallback'）
        # ...

    def get_status(self) -> dict:
        return {
            'initialized': self.is_initialized,
            'mode': self.mode,
            'features': {
                'add_memory': bool,
                'search_memories': bool,
                'advanced_semantic_search': bool,  # 只有MCP模式为True
                'vector_similarity': bool  # 只有MCP模式为True
            }
        }

# 使用示例:
semantic_manager = SemanticMemoryManager(config)
status = semantic_manager.get_status()
if status['mode'] == 'mcp':
    # MCP完整模式
elif status['mode'] == 'fallback':
    # 降级模式（本地缓存）
else:
    # 不可用
```

**接口含义**:
- `is_initialized=True, mode='mcp'` → MCP完整模式
- `is_initialized=True, mode='fallback'` → 降级模式（本地SQLite缓存）
- `is_initialized=False, mode='unavailable'` → 完全不可用

### 架构上下文

**Epic 10.11背景** [Source: docs/prd-memory-system-fix.md#Section 2]

本Story实现Epic 10.11的核心目标之一：**3层降级策略**（FR5, FR6）。

**降级策略设计**:
```
完整模式 (Full Mode)
├── Neo4j (时序记忆)
├── MCP Graphiti (知识图谱)
└── MCP Semantic (语义记忆 - 完整功能)

部分模式 (Partial Mode) ← 最常见
├── Neo4j (时序记忆)
├── ❌ Graphiti不可用
└── Semantic Fallback (降级模式 - 基础功能)

基础模式 (Basic Mode) ← 最小可用配置
├── ❌ Neo4j不可用
├── ❌ Graphiti不可用
└── Semantic Fallback (降级模式 - 基础功能)
```

**与Story 10.11.1-3的关系**:
- Story 10.11.1: 提供Neo4j验证 → 检测temporal_ok
- Story 10.11.2: 提供MCP健康检查 → 检测graphiti_ok
- Story 10.11.3: 提供semantic降级模式 → 检测semantic_ok和semantic_mode
- **Story 10.11.4**: 整合所有信息 → 确定系统模式 + 显示报告

### 源码树结构

```
memory_system/
├── system_mode_detector.py          ← NEW (AC2) - 模式检测器
├── error_formatters.py               ← NEW (AC4) - 报告生成器
├── temporal_memory_manager.py        (existing - Story 10.11.1)
├── semantic_memory_manager.py        (existing - Story 10.11.3)
├── mcp_health_check.py              (existing - Story 10.11.2)
└── memory_exceptions.py              (existing)

command_handlers/
└── learning_commands.py              ← MODIFIED (AC3, Task 4)
    - 添加模式检测调用
    - 添加横幅显示
    - 添加mode_info存储

.claude/commands/
└── graph-commands.md                 ← MODIFIED (Task 6)
    - 添加Graphiti可用性检查

tests/
├── test_system_mode_detector.py      ← NEW (Task 7)
├── test_error_formatters.py          ← NEW (Task 7)
└── test_mode_detection_integration.py ← NEW (Task 8)
```

### 技术栈

**Python环境**
- Python 3.9+
- 标准库：typing, enum（可选，用于定义模式常量）

**依赖组件**
- TemporalMemoryManager (Story 10.11.1)
- MCP健康检查 (Story 10.11.2)
- SemanticMemoryManager (Story 10.11.3)

### 设计决策

#### 决策1: 3层模式定义
**决定**: 采用"完整/部分/基础"3层模式

**理由**:
- ✅ 简单明了：用户易于理解
- ✅ 实用性强：覆盖最常见的故障场景
- ✅ 渐进降级：从完整到基础，不是非黑即白
- ❌ 不够精细：没有区分"temporal不可用但graphiti可用"等场景（但这些场景极少）

**替代方案（已拒绝）**:
- 8种模式（2^3组合）：过于复杂，用户困惑
- 2层模式（完整/降级）：不够灵活

#### 决策2: 部分模式的判断标准
**决定**: ≥2个系统可用 = 部分模式

**理由**:
- ✅ 实用定义：2/3系统可用时，核心功能仍然可用
- ✅ 符合用户预期："部分"意味着"大部分功能可用"
- ✅ 与基础模式区分明显：基础模式=仅1个系统

**边界case处理**:
- temporal(neo4j) + semantic(fallback) + ❌graphiti = 部分模式
- temporal(neo4j) + ❌semantic + ❌graphiti = 部分模式（边界，但仍算2个系统）
- ❌temporal + semantic(mcp) + graphiti = 部分模式

#### 决策3: 启动横幅显示时机
**决定**: 在/learning命令入口显示，所有初始化完成后

**理由**:
- ✅ 上下文明确：用户刚启动/learning，正是需要知道系统状态的时候
- ✅ 信息完整：此时所有记忆管理器已初始化，模式信息准确
- ✅ 非侵入性：不影响其他命令或自动化流程

**替代方案（已拒绝）**:
- 在每个命令前显示：过于啰嗦
- 只在有问题时显示：用户无法确认完整模式是否正常

#### 决策4: 功能限制检查方式
**决定**: 使用require_*()函数在命令入口检查

**理由**:
- ✅ 早期失败：在命令执行前就发现问题
- ✅ 友好提示：显示降级提示而非技术栈trace
- ✅ 易于维护：检查逻辑集中在一个模块

**实现选择**:
- 函数式：`if not require_graphiti(mode_info): return`
- 装饰器式：`@requires_system('graphiti')`（可选，更优雅但实现复杂）

### 风险缓解

#### 风险1: 模式检测逻辑有bug，导致错误模式
**影响**: 显示错误的系统状态或功能限制
**概率**: Medium
**缓解策略**:
- 详细的单元测试覆盖所有模式组合
- 在横幅中明确列出各系统状态（用户可视化验证）
- 添加模式验证：启动时double-check模式与实际可用性一致

#### 风险2: 启动横幅信息过载，用户看不懂
**影响**: 用户困惑，不知道如何操作
**概率**: Low-Medium
**缓解策略**:
- 简化语言：使用"完整模式"而非"Full Mode"
- 清晰的视觉结构：使用✅❌和分隔线
- 提供快速修复建议：用户可直接执行命令

#### 风险3: 功能限制检查遗漏，导致功能在不可用系统上崩溃
**影响**: 用户执行命令时遇到技术栈trace
**概率**: Medium
**缓解策略**:
- Code review：检查所有使用Graphiti/Temporal的命令
- 集成测试：模拟各系统不可用场景，验证降级提示
- 保护性编程：在记忆管理器方法中也添加状态检查

#### 风险4: 模式信息存储在全局变量，线程不安全
**影响**: 多线程环境下模式信息错乱
**概率**: Low（大多数使用场景是单线程）
**缓解策略**:
- 如果需要多线程支持，使用threading.local()
- 在文档中说明当前实现是单线程设计
- 提供线程安全的替代实现（如果用户需要）

### 性能考虑

**模式检测时间预算**: ≤100ms

**实际预期时间**:
- 检测temporal状态: <1ms（读取is_initialized和mode）
- 检测graphiti状态: <1ms（读取布尔值）
- 检测semantic状态: <1ms（读取is_initialized和mode）
- 构建报告: 10-20ms（字符串拼接）
- 总计: <50ms ✅ 远低于预算

**启动横幅不影响启动时间**（显示是瞬时的）

### Testing

**测试文件位置**:
- Unit tests: `tests/test_system_mode_detector.py`, `tests/test_error_formatters.py`
- Integration tests: `tests/test_mode_detection_integration.py`

**测试标准**:
- Framework: pytest
- Mocking: Use unittest.mock for system state simulation
- Coverage target: ≥95% for new code
- All 420 existing tests must pass (backward compatibility)

**测试框架和模式**:
- pytest with standard assertions
- Mock for system state simulation
- asyncio testing: Not required (all detection is synchronous)

**特定测试要求**:
- Mode detection tested for all 8 combinations (3 systems × full/degraded states)
- Error formatters tested with real mode_info dictionaries
- Integration tests must validate full /learning command flow

### 测试策略

**单元测试** (tests/test_system_mode_detector.py, tests/test_error_formatters.py)
- detect_mode()的所有模式组合（至少8种场景）
- format_startup_report()的格式验证
- generate_fix_suggestions()的准确性
- 目标覆盖率: ≥95%（纯逻辑代码，易于测试）

**集成测试** (tests/test_mode_detection_integration.py)
- /learning命令启动流程
- 功能限制检查
- 模式信息存储和访问

**手动测试** (3个场景)
- 场景1: 完整模式 - 验证正常工作
- 场景2: 部分模式 - 验证降级提示
- 场景3: 基础模式 - 验证功能限制说明

**回归测试**
- 420个现有测试必须通过
- 验证现有命令功能不变

### Integration Points

**修改的文件**:
- `command_handlers/learning_commands.py` (/learning命令入口，添加模式检测和横幅)
- `.claude/commands/graph-commands.md` 或对应的handler（添加功能限制检查）

**新增的文件**:
- `memory_system/system_mode_detector.py` (模式检测器)
- `memory_system/error_formatters.py` (报告生成器和功能限制检查)
- `tests/test_system_mode_detector.py` (单元测试)
- `tests/test_error_formatters.py` (单元测试)
- `tests/test_mode_detection_integration.py` (集成测试)

**依赖的组件**:
- Story 10.11.1: TemporalMemoryManager (提供is_initialized和mode)
- Story 10.11.2: MCP健康检查 (提供graphiti_available)
- Story 10.11.3: SemanticMemoryManager (提供is_initialized和mode)

### Definition of Done

Story 10.11.4被认为完成，当且仅当：

✅ **所有AC满足**:
- [ ] AC1: 3层运行模式明确定义
- [ ] AC2: SystemModeDetector类实现并测试通过
- [ ] AC3: /learning命令显示启动横幅
- [ ] AC4: format_startup_report()函数实现
- [ ] AC5: 功能限制检查实现

✅ **代码质量**:
- [ ] Pylint评分 ≥8.5/10
- [ ] 所有函数有type hints
- [ ] 所有函数有docstring（Google Style）

✅ **测试覆盖**:
- [ ] 单元测试覆盖率 ≥95% (新增代码)
- [ ] 所有模式组合都有测试用例
- [ ] 集成测试覆盖/learning命令流程
- [ ] 功能限制检查有专门的测试用例

✅ **性能验证**:
- [ ] 模式检测时间 ≤100ms
- [ ] 420个现有测试100%通过
- [ ] 测试时间增加 <2秒

✅ **文档**:
- [ ] 3层模式有明确的文档说明
- [ ] 启动横幅格式友好易懂
- [ ] 功能影响描述准确
- [ ] 快速修复建议可操作

✅ **用户验收**:
- [ ] 在真实环境测试3个手动场景
- [ ] 用户确认横幅信息清晰
- [ ] 用户确认降级提示有用

## QA Checklist

**功能验证**:
- [ ] SystemModeDetector能正确识别所有3种模式
- [ ] 启动横幅包含所有必需信息（模式、系统状态、影响、建议）
- [ ] 横幅格式清晰美观（使用✅❌和分隔线）
- [ ] 功能限制检查能正确识别系统不可用
- [ ] 降级提示包含可操作的修复建议
- [ ] 模式信息存储和访问正确工作

**模式检测验证**:
- [ ] 完整模式：3个系统全部可用 + semantic=mcp
- [ ] 部分模式：2个系统可用 或 semantic=fallback
- [ ] 基础模式：仅1个系统可用
- [ ] 边界case：temporal+semantic(fallback)正确识别为部分模式

**用户体验验证**:
- [ ] 启动横幅在/learning命令开头显示
- [ ] 横幅信息清晰，用户能理解当前模式
- [ ] 功能影响描述准确（不夸大也不淡化）
- [ ] 快速修复建议可直接执行
- [ ] 降级提示友好（非技术性语言）

**兼容性验证**:
- [ ] 所有420个现有测试通过
- [ ] 现有命令在完整模式下功能不变
- [ ] 所有Sub-agent接口不受影响
- [ ] 模式检测不影响启动时间（<100ms）

**代码质量验证**:
- [ ] Pylint评分 ≥8.5/10
- [ ] 所有新函数有完整的docstring
- [ ] 所有新函数有type hints
- [ ] 逻辑清晰，易于维护
- [ ] 没有硬编码的系统名称或路径

**错误处理验证**:
- [ ] 模式检测逻辑健壮（容错各种edge cases）
- [ ] 启动横幅生成不会崩溃（即使mode_info有缺失字段）
- [ ] 功能限制检查有默认行为（如果mode_info不可用）

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | 初始Story创建 | SM Agent (Bob) |
| 2025-10-31 | 1.1 | 修复版本：添加Change Log、依赖接口、Testing小节、源码树 | PO Agent (Sarah) |

---

**Created**: 2025-10-23
**Last Updated**: 2025-10-31
**Story Owner**: Dev Agent (James)
**Review Status**: Ready for Review
