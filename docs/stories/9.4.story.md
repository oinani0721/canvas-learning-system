# Story 9.4: API服务层扩展 - Canvas与记忆系统集成

## Status
Ready for Development

## Story

**As a** Canvas学习系统用户，
**I want** 建立完整的API服务层，集成Canvas监控和艾宾浩斯记忆分析系统，
**so that** 前端应用能够获取Canvas学习状态、复习计划、记忆统计数据，支持Canvas学习监控和智能复习提醒功能。

## Acceptance Criteria

1: 创建完整的Axios HTTP客户端配置，包含基础设置、请求/响应拦截器
2: 实现统一的错误处理机制，支持网络错误、服务器错误、业务错误分类处理
3: 创建Canvas服务接口定义(canvasService.ts)，封装所有Canvas相关的API调用
4: 创建MCP记忆系统服务代理(mcpMemoryService.ts)，支持调用/review、/memory-stats等命令
5: 创建Canvas学习状态服务(canvasLearningService.ts)，获取Canvas学习数据和复习计划
6: 创建复习计划服务(reviewScheduleService.ts)，基于艾宾浩斯算法的复习提醒功能
7: 配置API代理和跨域处理，确保开发环境和生产环境的API调用正常
8: 实现请求重试机制和超时处理，提升网络请求的可靠性
9: 创建类型安全的API响应处理，基于Story 9.2建立的TypeScript类型系统
10: 支持请求取消功能，避免组件卸载后的内存泄漏
11: 实现API响应缓存机制，优化重复请求的性能
12: 添加请求日志记录，便于调试和监控
13: 配置环境变量管理，支持不同环境的API端点切换
14: 与Canvas文件监控引擎和现有艾宾浩斯复习系统完全兼容
15: 为后续Socket.IO实时通信预留接口扩展能力
16: 所有API调用包含适当的加载状态和错误状态管理

## Tasks / Subtasks

- [ ] Task 1: HTTP客户端基础配置
  - [ ] Subtask 1.1: 创建apiClient.ts基础配置文件
  - [ ] Subtask 1.2: 配置Axios实例基础设置(超时、headers等)
  - [ ] Subtask 1.3: 实现请求拦截器(认证token、请求日志等)
  - [ ] Subtask 1.4: 实现响应拦截器(错误处理、响应日志等)

- [ ] Task 2: 错误处理和重试机制
  - [ ] Subtask 2.1: 创建错误分类和处理策略
  - [ ] Subtask 2.2: 实现自动重试机制和退避策略
  - [ ] Subtask 2.3: 添加网络超时和连接错误处理
  - [ ] Subtask 2.4: 创建用户友好的错误消息展示

- [ ] Task 3: Canvas服务接口实现
  - [ ] Subtask 3.1: 创建canvasService.ts服务文件
  - [ ] Subtask 3.2: 实现Canvas列表获取API
  - [ ] Subtask 3.3: 实现Canvas状态查询API
  - [ ] Subtask 3.4: 实现Canvas监控控制API

- [ ] Task 4: MCP记忆系统服务实现 ⭐ **新增重点任务**
  - [ ] Subtask 4.1: 创建mcpMemoryService.ts MCP代理服务
  - [ ] Subtask 4.2: 实现艾宾浩斯复习系统API(/review命令集成)
  - [ ] Subtask 4.3: 实现记忆统计API(/memory-stats命令集成)
  - [ ] Subtask 4.4: 实现学习报告API(/learning-report命令集成)
  - [ ] Subtask 4.5: 实现复习进度API(/review-progress命令集成)

- [ ] Task 5: Canvas学习状态服务实现 ⭐ **新增重点任务**
  - [ ] Subtask 5.1: 创建canvasLearningService.ts学习状态服务
  - [ ] Subtask 5.2: 实现Canvas学习进度分析API
  - [ ] Subtask 5.3: 实现Canvas节点状态分布统计API
  - [ ] Subtask 5.4: 实现Canvas学习趋势数据API
  - [ ] Subtask 5.5: 实现Canvas学习建议生成API

- [ ] Task 6: 复习计划服务实现 ⭐ **新增重点任务**
  - [ ] Subtask 6.1: 创建reviewScheduleService.ts复习计划服务
  - [ ] Subtask 6.2: 实现基于艾宾浩斯算法的复习计划API
  - [ ] Subtask 6.3: 实现复习提醒时间线API
  - [ ] Subtask 6.4: 实现复习优先级排序API
  - [ ] Subtask 6.5: 实现复习效果跟踪API

- [ ] Task 7: 高级功能实现
  - [ ] Subtask 7.1: 实现请求缓存机制(特别缓存记忆数据)
  - [ ] Subtask 7.2: 添加请求取消功能
  - [ ] Subtask 7.3: 创建API响应类型安全处理
  - [ ] Subtask 7.4: 实现并发请求管理和队列控制
  - [ ] Subtask 7.5: 实现MCP命令调用的异步处理机制

- [ ] Task 8: 环境配置和测试
  - [ ] Subtask 8.1: 配置环境变量管理(包含MCP服务配置)
  - [ ] Subtask 8.2: 创建API服务单元测试
  - [ ] Subtask 8.3: 实现Mock数据和测试环境(包含记忆数据Mock)
  - [ ] Subtask 8.4: 验证与后端API和MCP系统的集成测试

## Dev Notes

### Previous Story Insights

从Story 9.2 (前端项目基础架构搭建) 和 Story 9.3 (路由和页面框架实现) 中获得的关键经验：
- **Axios 1.12.2已安装**: HTTP客户端依赖已准备就绪
- **TypeScript类型系统完整**: canvas.ts和api.ts类型定义已创建
- **API代理配置完成**: vite.config.ts中已配置代理设置
- **构建配置优化**: 支持环境变量和代码分割
- **测试框架就绪**: Jest和React Testing Library已配置完成

从Story 9.1 (Canvas文件监控引擎) 中获得的API接口信息：
- **Canvas监控引擎API**: 提供Canvas状态查询、监控控制等接口
- **实时数据推送**: 支持WebSocket/Socket.IO实时通信
- **数据格式规范**: JSON格式的Canvas状态和进度数据

### Technical Context

**HTTP客户端技术栈** [Source: canvas-progress-tracker-frontend-spec.md#API集成规范]:
- **Axios 1.12.2**: HTTP客户端库，已安装依赖
- **TypeScript 5.9.3**: 类型安全的API接口定义
- **环境变量管理**: .env.development和.env.production已配置
- **代理配置**: Vite开发代理已设置，指向localhost:8000

**API架构设计** [Source: canvas-progress-tracker-frontend-spec.md#API集成规范]:
```typescript
// API基础配置
const API_BASE_URL = process.env.VITE_API_BASE_URL || 'http://localhost:8000/api';

// 请求/响应拦截器设计
- 请求拦截: 认证token、请求ID、用户代理
- 响应拦截: 错误处理、数据转换、日志记录
- 错误分类: 网络错误、服务器错误、业务错误
```

### Data Models

**API客户端配置**:
```typescript
interface ApiClientConfig {
  baseURL: string;
  timeout: number;
  headers: Record<string, string>;
  retryConfig: RetryConfig;
  cacheConfig: CacheConfig;
}

interface RetryConfig {
  maxRetries: number;
  retryDelay: number;
  retryCondition: (error: any) => boolean;
}

interface CacheConfig {
  enabled: boolean;
  ttl: number; // 缓存时间(秒)
  maxSize: number; // 最大缓存条目数
}
```

**API响应包装**:
```typescript
interface ApiResponse<T> {
  success: boolean;
  data: T;
  message?: string;
  timestamp: string;
  requestId: string;
}

interface ApiError {
  code: string;
  message: string;
  details?: any;
  timestamp: string;
  requestId: string;
}
```

**Canvas服务接口**:
```typescript
interface CanvasService {
  // 获取Canvas列表
  getCanvasList(): Promise<ApiResponse<CanvasInfo[]>>;

  // 获取Canvas状态
  getCanvasState(canvasId: string): Promise<ApiResponse<CanvasState>>;

  // 获取进度历史
  getProgressHistory(canvasId: string, timeRange: string): Promise<ApiResponse<ProgressHistoryItem[]>>;

  // 启动/停止监控
  toggleMonitoring(canvasId: string): Promise<ApiResponse<boolean>>;

  // 获取系统状态
  getSystemStatus(): Promise<ApiResponse<SystemStatus>>;
}
```

**MCP记忆系统服务接口** ⭐ **新增**:
```typescript
interface MCMemoryService {
  // 获取今日复习任务
  getTodayReviews(userId?: string): Promise<ApiResponse<ReviewTask[]>>;

  // 获取复习统计
  getReviewStats(userId?: string, days?: number): Promise<ApiResponse<ReviewStats>>;

  // 获取记忆统计数据
  getMemoryStats(options?: MemoryStatsOptions): Promise<ApiResponse<MemoryStats>>;

  // 获取学习报告
  getLearningReport(days?: number): Promise<ApiResponse<LearningReport>>;

  // 获取复习进度
  getReviewProgress(planId?: string): Promise<ApiResponse<ReviewProgress>>;

  // 完成复习记录
  completeReview(scheduleId: string, rating: number): Promise<ApiResponse<boolean>>;
}
```

**Canvas学习状态服务接口** ⭐ **新增**:
```typescript
interface CanvasLearningService {
  // 获取Canvas学习进度
  getCanvasLearningProgress(canvasId: string): Promise<ApiResponse<CanvasLearningProgress>>;

  // 获取Canvas节点状态分布
  getCanvasNodeDistribution(canvasId: string): Promise<ApiResponse<NodeDistribution>>;

  // 获取Canvas学习趋势
  getCanvasLearningTrend(canvasId: string, timeRange: string): Promise<ApiResponse<LearningTrendItem[]>>;

  // 获取Canvas学习建议
  getCanvasLearningSuggestions(canvasId: string): Promise<ApiResponse<LearningSuggestion[]>>;

  // 获取所有Canvas学习概览
  getAllCanvasLearningOverview(): Promise<ApiResponse<CanvasLearningOverview[]>>;
}
```

**复习计划服务接口** ⭐ **新增**:
```typescript
interface ReviewScheduleService {
  // 获取复习时间线
  getReviewTimeline(days?: number): Promise<ApiResponse<ReviewTimelineItem[]>>;

  // 获取复习计划详情
  getReviewSchedule(planId: string): Promise<ApiResponse<ReviewSchedule>>;

  // 获取复习优先级
  getReviewPriorities(): Promise<ApiResponse<ReviewPriority[]>>;

  // 生成复习计划
  generateReviewSchedule(canvasIds: string[]): Promise<ApiResponse<ReviewSchedule>>;

  // 更新复习计划
  updateReviewSchedule(planId: string, updates: Partial<ReviewSchedule>): Promise<ApiResponse<ReviewSchedule>>;
}
```

### 新增数据类型定义 ⭐ **扩展**

**复习相关数据类型**:
```typescript
interface ReviewTask {
  scheduleId: string;
  canvasFile: string;
  canvasId: string;
  conceptName: string;
  nodeId: string;
  nextReviewDate: string;
  reviewIntervalDays: number;
  memoryStrength: number;
  retentionRate: number;
  masteryLevel: number;
  lastReviewScore?: number;
}

interface ReviewStats {
  totalReviews: number;
  completedReviews: number;
  averageScore: number;
  retentionRate: number;
  memoryStrength: number;
  weeklyProgress: ReviewProgress[];
  subjectDistribution: SubjectStats[];
}

interface MemoryStats {
  semanticMemories: number;
  episodicLinks: number;
  workingMemorySnapshots: number;
  totalLearningSessions: number;
  totalStudyTime: number;
  averageSessionLength: number;
  learningFrequency: number;
  improvementRate: number;
  agentUsageStats: AgentUsage[];
  subjectDistribution: SubjectStats[];
}

interface LearningReport {
  generatedAt: string;
  periodStart: string;
  periodEnd: string;
  learningDays: number;
  totalLearningTime: {
    hours: number;
    minutes: number;
  };
  avgDailyMinutes: number;
  activityLevel: number;
  mastery: MasteryStats;
  patterns: LearningPatterns;
  achievements: Achievement[];
  subjects: SubjectStats[];
  recommendations: LearningRecommendations;
}

interface ReviewProgress {
  planId: string;
  planName: string;
  totalConcepts: number;
  completedConcepts: number;
  averageScore: number;
  timeEfficiency: number;
  targetAchievementRate: number;
  masteryImprovement: number;
  weakAreasReduction: number;
  reviewQuality: 'excellent' | 'good' | 'needs_improvement';
}
```

**Canvas学习状态数据类型**:
```typescript
interface CanvasLearningProgress {
  canvasId: string;
  canvasName: string;
  totalNodes: number;
  redNodes: number;
  yellowNodes: number;
  purpleNodes: number;
  greenNodes: number;
  blueNodes: number;
  completionRate: number;
  masteryRate: number;
  lastStudyTime: string;
  studyCount: number;
  averageScore: number;
  improvementTrend: 'improving' | 'stable' | 'declining';
}

interface NodeDistribution {
  red: {
    count: number;
    percentage: number;
    concepts: string[];
  };
  yellow: {
    count: number;
    percentage: number;
    concepts: string[];
  };
  purple: {
    count: number;
    percentage: number;
    concepts: string[];
  };
  green: {
    count: number;
    percentage: number;
    concepts: string[];
  };
  blue: {
    count: number;
    percentage: number;
    concepts: string[];
  };
}

interface LearningTrendItem {
  date: string;
  totalNodes: number;
  completedNodes: number;
  completionRate: number;
  studyTime: number;
  averageScore: number;
  newConceptsLearned: number;
  conceptsReviewed: number;
}

interface LearningSuggestion {
  type: 'review' | 'study' | 'practice' | 'rest';
  priority: 'high' | 'medium' | 'low';
  title: string;
  description: string;
  targetConcepts: string[];
  estimatedTime: number;
  reasoning: string;
}
```

**复习计划数据类型**:
```typescript
interface ReviewSchedule {
  planId: string;
  planName: string;
  canvasIds: string[];
  createdAt: string;
  totalReviews: number;
  completedReviews: number;
  nextReviewDate: string;
  reviewInterval: number;
  memoryStrength: number;
  status: 'active' | 'completed' | 'paused';
}

interface ReviewTimelineItem {
  date: string;
  reviewType: 'daily' | 'weekly' | 'monthly';
  concepts: ReviewTask[];
  estimatedTime: number;
  priority: 'high' | 'medium' | 'low';
  status: 'pending' | 'completed' | 'overdue';
}

interface ReviewPriority {
  canvasId: string;
  canvasName: string;
  conceptName: string;
  priority: number;
  urgency: 'immediate' | 'soon' | 'scheduled';
  reason: string;
  memoryStrength: number;
  retentionRate: number;
  suggestedAction: string;
}
```

### API Specifications

**Canvas监控引擎API接口** [Source: Story 9.1 API设计和canvas-progress-tracker-frontend-spec.md]:

```typescript
// src/services/canvasService.ts
export class CanvasService {
  private static apiClient = createApiClient();

  // 获取所有Canvas列表
  static async getCanvasList(): Promise<CanvasInfo[]> {
    const response = await this.apiClient.get('/canvases');
    return response.data.data;
  }

  // 获取Canvas详细状态
  static async getCanvasState(canvasId: string): Promise<CanvasState> {
    const response = await this.apiClient.get(`/canvases/${canvasId}/state`);
    return response.data.data;
  }

  // 获取进度历史数据
  static async getProgressHistory(
    canvasId: string,
    timeRange: '7d' | '30d' | '90d' = '30d'
  ): Promise<ProgressHistoryItem[]> {
    const response = await this.apiClient.get(
      `/canvases/${canvasId}/history?range=${timeRange}`
    );
    return response.data.data;
  }

  // 切换监控状态
  static async toggleMonitoring(canvasId: string): Promise<boolean> {
    const response = await this.apiClient.post(`/canvases/${canvasId}/monitoring/toggle`);
    return response.data.data;
  }

  // 获取系统状态
  static async getSystemStatus(): Promise<SystemStatus> {
    const response = await this.apiClient.get('/system/status');
    return response.data.data;
  }
}
```

**请求拦截器配置**:
```typescript
// src/services/apiClient.ts
export const createApiClient = () => {
  const apiClient = axios.create({
    baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api',
    timeout: 10000,
    headers: {
      'Content-Type': 'application/json',
      'X-Client-Version': '1.0.0',
    },
  });

  // 请求拦截器
  apiClient.interceptors.request.use(
    (config) => {
      // 添加请求ID
      config.headers['X-Request-ID'] = generateRequestId();

      // 添加认证token (如果存在)
      const token = getAuthToken();
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }

      // 记录请求日志
      console.log(`API Request: ${config.method?.toUpperCase()} ${config.url}`);

      return config;
    },
    (error) => {
      console.error('Request interceptor error:', error);
      return Promise.reject(error);
    }
  );

  // 响应拦截器
  apiClient.interceptors.response.use(
    (response) => {
      // 记录响应日志
      console.log(`API Response: ${response.status} ${response.config.url}`);

      // 统一响应格式处理
      return response;
    },
    (error) => {
      // 错误处理
      handleApiError(error);
      return Promise.reject(error);
    }
  );

  return apiClient;
};
```

**MCP记忆系统服务API接口** ⭐ **新增**:
```typescript
// src/services/mcpMemoryService.ts
export class MCMemoryService {
  private static apiClient = createApiClient();
  private static mcpCommandProxy = createMCPCommandProxy();

  // 获取今日复习任务 (调用 /review show 命令)
  static async getTodayReviews(userId?: string): Promise<ReviewTask[]> {
    const response = await this.mcpCommandProxy.execute('/review', {
      action: 'show',
      userId: userId || 'default',
      format: 'json'
    });
    return response.data;
  }

  // 获取复习统计 (调用 /review stats 命令)
  static async getReviewStats(userId?: string, days: number = 30): Promise<ReviewStats> {
    const response = await this.mcpCommandProxy.execute('/review-progress', {
      userId: userId || 'default',
      timeRange: 'month',
      format: 'detailed'
    });
    return response.data;
  }

  // 获取记忆统计数据 (调用 /memory-stats 命令)
  static async getMemoryStats(options?: MemoryStatsOptions): Promise<MemoryStats> {
    const response = await this.mcpCommandProxy.execute('/memory-stats', {
      detailed: options?.detailed || false,
      system: options?.system || false,
      privacy: options?.privacy || false
    });
    return response.data;
  }

  // 获取学习报告 (调用 /learning-report 命令)
  static async getLearningReport(days: number = 7): Promise<LearningReport> {
    const response = await this.mcpCommandProxy.execute('/learning-report', {
      days: days
    });
    return response.data;
  }

  // 获取复习进度 (调用 /review-progress 命令)
  static async getReviewProgress(planId?: string): Promise<ReviewProgress> {
    const response = await this.mcpCommandProxy.execute('/review-progress', {
      planId: planId,
      format: 'detailed',
      timeRange: 'week'
    });
    return response.data;
  }

  // 完成复习记录 (调用 /review complete 命令)
  static async completeReview(scheduleId: string, rating: number): Promise<boolean> {
    const response = await this.mcpCommandProxy.execute('/review', {
      action: 'complete',
      scheduleId: scheduleId
    });
    return response.success;
  }
}
```

**Canvas学习状态服务API接口** ⭐ **新增**:
```typescript
// src/services/canvasLearningService.ts
export class CanvasLearningService {
  private static apiClient = createApiClient();
  private static mcpCommandProxy = createMCPCommandProxy();

  // 获取Canvas学习进度 (整合Canvas文件数据 + 记忆数据)
  static async getCanvasLearningProgress(canvasId: string): Promise<CanvasLearningProgress> {
    const canvasState = await CanvasService.getCanvasState(canvasId);
    const memoryStats = await MCMemoryService.getMemoryStats();

    // 整合数据，计算学习进度
    return {
      canvasId,
      canvasName: canvasState.name,
      totalNodes: canvasState.totalNodes,
      redNodes: canvasState.redNodes,
      yellowNodes: canvasState.yellowNodes,
      purpleNodes: canvasState.purpleNodes,
      greenNodes: canvasState.greenNodes,
      blueNodes: canvasState.blueNodes,
      completionRate: calculateCompletionRate(canvasState),
      masteryRate: calculateMasteryRate(canvasState),
      lastStudyTime: getLastStudyTime(canvasId),
      studyCount: getStudyCount(canvasId),
      averageScore: calculateAverageScore(canvasId),
      improvementTrend: calculateImprovementTrend(canvasId)
    };
  }

  // 获取Canvas节点状态分布
  static async getCanvasNodeDistribution(canvasId: string): Promise<NodeDistribution> {
    const canvasState = await CanvasService.getCanvasState(canvasId);
    return {
      red: {
        count: canvasState.redNodes,
        percentage: (canvasState.redNodes / canvasState.totalNodes) * 100,
        concepts: getRedNodeConcepts(canvasId)
      },
      yellow: {
        count: canvasState.yellowNodes,
        percentage: (canvasState.yellowNodes / canvasState.totalNodes) * 100,
        concepts: getYellowNodeConcepts(canvasId)
      },
      purple: {
        count: canvasState.purpleNodes,
        percentage: (canvasState.purpleNodes / canvasState.totalNodes) * 100,
        concepts: getPurpleNodeConcepts(canvasId)
      },
      green: {
        count: canvasState.greenNodes,
        percentage: (canvasState.greenNodes / canvasState.totalNodes) * 100,
        concepts: getGreenNodeConcepts(canvasId)
      },
      blue: {
        count: canvasState.blueNodes,
        percentage: (canvasState.blueNodes / canvasState.totalNodes) * 100,
        concepts: getBlueNodeConcepts(canvasId)
      }
    };
  }

  // 获取Canvas学习趋势
  static async getCanvasLearningTrend(canvasId: string, timeRange: string = '30d'): Promise<LearningTrendItem[]> {
    const history = await CanvasService.getProgressHistory(canvasId, timeRange);
    return history.map(item => ({
      date: item.date,
      totalNodes: item.totalNodes,
      completedNodes: item.greenNodes,
      completionRate: item.completionRate,
      studyTime: getStudyTimeForDate(canvasId, item.date),
      averageScore: getAverageScoreForDate(canvasId, item.date),
      newConceptsLearned: getNewConceptsForDate(canvasId, item.date),
      conceptsReviewed: getReviewedConceptsForDate(canvasId, item.date)
    }));
  }

  // 获取所有Canvas学习概览
  static async getAllCanvasLearningOverview(): Promise<CanvasLearningOverview[]> {
    const canvasList = await CanvasService.getCanvasList();
    const overviews = await Promise.all(
      canvasList.map(canvas => this.getCanvasLearningProgress(canvas.canvasId))
    );
    return overviews.sort((a, b) => b.priority - a.priority);
  }
}
```

**复习计划服务API接口** ⭐ **新增**:
```typescript
// src/services/reviewScheduleService.ts
export class ReviewScheduleService {
  private static mcpCommandProxy = createMCPCommandProxy();

  // 获取复习时间线 (基于艾宾浩斯算法)
  static async getReviewTimeline(days: number = 7): Promise<ReviewTimelineItem[]> {
    const todayReviews = await MCMemoryService.getTodayReviews();
    const memoryStats = await MCMemoryService.getMemoryStats();

    // 生成基于遗忘曲线的复习时间线
    const timeline = generateReviewTimeline(todayReviews, days);
    return timeline;
  }

  // 获取复习优先级排序
  static async getReviewPriorities(): Promise<ReviewPriority[]> {
    const todayReviews = await MCMemoryService.getTodayReviews();

    // 基于记忆强度和保持率计算优先级
    const priorities = todayReviews.map(review => ({
      canvasId: review.canvasId,
      canvasName: review.canvasFile,
      conceptName: review.conceptName,
      priority: calculateReviewPriority(review),
      urgency: getUrgencyLevel(review),
      reason: getPriorityReason(review),
      memoryStrength: review.memoryStrength,
      retentionRate: review.retentionRate,
      suggestedAction: getSuggestedAction(review)
    }));

    return priorities.sort((a, b) => b.priority - a.priority);
  }

  // 生成智能复习计划
  static async generateReviewSchedule(canvasIds: string[]): Promise<ReviewSchedule> {
    const planId = generatePlanId();
    const learningData = await Promise.all(
      canvasIds.map(id => CanvasLearningService.getCanvasLearningProgress(id))
    );

    const schedule = {
      planId,
      planName: `智能复习计划 - ${new Date().toLocaleDateString()}`,
      canvasIds,
      createdAt: new Date().toISOString(),
      totalReviews: learningData.reduce((sum, data) => sum + data.redNodes + data.purpleNodes, 0),
      completedReviews: 0,
      nextReviewDate: calculateNextReviewDate(learningData),
      reviewInterval: calculateOptimalInterval(learningData),
      memoryStrength: calculateAverageMemoryStrength(learningData),
      status: 'active' as const
    };

    return schedule;
  }
}
```

**MCP命令代理服务** ⭐ **新增核心组件**:
```typescript
// src/services/mcpCommandProxy.ts
export class MCPCommandProxy {
  private static instance: MCPCommandProxy;

  // 执行MCP命令的通用方法
  async execute(command: string, params?: any): Promise<any> {
    try {
      // 这里需要实现MCP命令的HTTP代理调用
      // 具体实现可能需要与Claude Code的MCP系统集成
      const response = await fetch('/api/mcp/execute', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          command,
          params
        })
      });

      return await response.json();
    } catch (error) {
      console.error(`MCP command execution failed: ${command}`, error);
      throw error;
    }
  }

  static getInstance(): MCPCommandProxy {
    if (!this.instance) {
      this.instance = new MCPCommandProxy();
    }
    return this.instance;
  }
}

function createMCPCommandProxy(): MCPCommandProxy {
  return MCPCommandProxy.getInstance();
}
```

### Component Specifications

**错误处理组件**:
```typescript
// src/components/common/ApiErrorBoundary.tsx
interface ApiErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType<{error: ApiError; retry: () => void}>;
}

const ApiErrorBoundary: React.FC<ApiErrorBoundaryProps> = ({ children, fallback }) => {
  // 实现API错误边界逻辑
  // 提供重试机制和用户友好的错误显示
};
```

**加载状态管理**:
```typescript
// src/hooks/useApiRequest.ts
interface UseApiRequestResult<T> {
  data: T | null;
  loading: boolean;
  error: ApiError | null;
  execute: () => Promise<void>;
  reset: () => void;
}

export const useApiRequest = <T>(apiCall: () => Promise<T>): UseApiRequestResult<T> => {
  // 实现API请求状态管理Hook
  // 包含加载状态、错误处理、重试逻辑
};
```

### File Locations

**项目根目录**: `canvas-progress-tracker/` [Source: canvas-progress-tracker-frontend-spec.md#项目结构]

**关键文件位置**:
- `src/services/apiClient.ts` - HTTP客户端基础配置
- `src/services/canvasService.ts` - Canvas服务接口定义
- `src/services/mcpMemoryService.ts` ⭐ **新增** - MCP记忆系统服务
- `src/services/canvasLearningService.ts` ⭐ **新增** - Canvas学习状态服务
- `src/services/reviewScheduleService.ts` ⭐ **新增** - 复习计划服务
- `src/services/mcpCommandProxy.ts` ⭐ **新增** - MCP命令代理
- `src/services/types.ts` - API相关类型定义
- `src/hooks/useApiRequest.ts` - API请求状态管理Hook
- `src/hooks/useMCPCommand.ts` ⭐ **新增** - MCP命令调用Hook
- `src/utils/errorHandler.ts` - 错误处理工具函数
- `src/components/common/ApiErrorBoundary.tsx` - API错误边界组件

**环境配置文件**:
- `.env.development` - 开发环境变量
- `.env.production` - 生产环境变量

### Testing Requirements

**测试框架配置** [Source: Story 9.2测试配置]:
- **测试框架**: Jest + React Testing Library
- **Mock库**: MSW (Mock Service Worker) 或 axios-mock-adapter
- **覆盖率要求**: >90%代码覆盖率 (API服务层关键代码)

**核心测试文件**:
- `tests/services/apiClient.test.ts` - HTTP客户端测试
- `tests/services/canvasService.test.ts` - Canvas服务测试
- `tests/services/mcpMemoryService.test.ts` ⭐ **新增** - MCP记忆服务测试
- `tests/services/canvasLearningService.test.ts` ⭐ **新增** - Canvas学习服务测试
- `tests/services/reviewScheduleService.test.ts` ⭐ **新增** - 复习计划服务测试
- `tests/services/mcpCommandProxy.test.ts` ⭐ **新增** - MCP命令代理测试
- `tests/hooks/useApiRequest.test.ts` - API Hook测试
- `tests/hooks/useMCPCommand.test.ts` ⭐ **新增** - MCP命令Hook测试
- `tests/utils/errorHandler.test.ts` - 错误处理测试

**API服务测试示例**:
```typescript
// tests/services/canvasService.test.ts
describe('CanvasService', () => {
  let mockApiClient: jest.Mocked<AxiosInstance>;

  beforeEach(() => {
    mockApiClient = createMockApiClient();
  });

  test('should fetch canvas list successfully', async () => {
    const mockCanvasList = [
      { canvasId: 'test-1', name: 'Test Canvas 1' },
      { canvasId: 'test-2', name: 'Test Canvas 2' }
    ];

    mockApiClient.get.mockResolvedValue({
      data: { success: true, data: mockCanvasList }
    });

    const result = await CanvasService.getCanvasList();
    expect(result).toEqual(mockCanvasList);
    expect(mockApiClient.get).toHaveBeenCalledWith('/canvases');
  });

  test('should handle API errors gracefully', async () => {
    mockApiClient.get.mockRejectedValue(new Error('Network Error'));

    await expect(CanvasService.getCanvasList()).rejects.toThrow('Network Error');
  });
});
```

### Technical Constraints

**性能约束** [Source: canvas-progress-tracker-frontend-spec.md#性能要求]:
- **API响应时间**: 基础操作<3秒，复杂操作<10秒
- **请求超时**: 10秒超时，支持重试机制
- **并发限制**: 同时最多5个请求，避免过载
- **缓存策略**: 常用数据缓存5分钟，减少重复请求

**安全约束**:
- **HTTPS通信**: 生产环境必须使用HTTPS
- **认证管理**: JWT token安全存储和自动刷新
- **CORS配置**: 严格的跨域资源共享配置
- **输入验证**: 所有API参数进行类型验证和清理

**兼容性约束**:
- **浏览器支持**: Axios支持所有现代浏览器
- **Node.js兼容**: API客户端可在服务端渲染中使用
- **向后兼容**: API版本控制，支持旧版本客户端
- **错误处理**: 统一的错误响应格式，便于客户端处理

### Error Handling Strategy

**错误分类处理**:
```typescript
enum ErrorType {
  NETWORK_ERROR = 'NETWORK_ERROR',      // 网络连接错误
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',      // 请求超时
  SERVER_ERROR = 'SERVER_ERROR',        // 服务器错误(5xx)
  CLIENT_ERROR = 'CLIENT_ERROR',        // 客户端错误(4xx)
  BUSINESS_ERROR = 'BUSINESS_ERROR',    // 业务逻辑错误
  UNKNOWN_ERROR = 'UNKNOWN_ERROR'       // 未知错误
}

interface ErrorHandler {
  handleError(error: any): ApiError;
  getErrorMessage(error: ApiError): string;
  shouldRetry(error: ApiError): boolean;
}
```

**重试策略**:
- **网络错误**: 自动重试3次，指数退避
- **超时错误**: 重试2次，增加超时时间
- **服务器错误**: 重试1次，记录错误日志
- **客户端错误**: 不重试，直接显示错误信息
- **业务错误**: 不重试，根据业务逻辑处理

## Testing

### 测试标准要求

**API客户端测试**:
- **配置验证**: Axios实例配置正确性测试
- **拦截器测试**: 请求/响应拦截器功能测试
- **错误处理测试**: 各类错误场景的处理测试
- **重试机制测试**: 自动重试逻辑验证

**服务层测试**:
- **接口调用测试**: Canvas服务各方法功能测试
- **参数验证测试**: API参数传递和验证测试
- **响应处理测试**: API响应数据解析和转换测试
- **错误传播测试**: 服务层错误处理和传播测试

**集成测试要求**:
```typescript
// 示例：API集成测试
describe('API Integration', () => {
  test('should integrate with Canvas monitoring engine', async () => {
    // 模拟Canvas监控引擎API响应
    const mockEngine = setupMockCanvasEngine();

    // 测试完整的API调用流程
    const canvasService = new CanvasService();
    const result = await canvasService.getCanvasList();

    expect(result).toBeDefined();
    expect(mockEngine.getCanvases).toHaveBeenCalled();
  });
});
```

**Mock服务设置**:
- 使用MSW (Mock Service Worker) 拦截HTTP请求
- 提供完整的API响应模拟
- 支持不同错误场景的模拟测试
- 确保测试环境的稳定性和可重复性

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-25 | 1.0 | 初始故事创建，完成Story 9.2 Task 6的详细设计 | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4.5

### Debug Log References
No debugging issues encountered during story creation.

### Completion Notes List
- ✅ 基于Story 9.2已完成的基础架构进行API服务层开发
- ✅ 遵循canvas-progress-tracker-frontend-spec.md API集成规范
- ✅ Axios HTTP客户端配置和拦截器设计完成
- ✅ Canvas服务接口定义和类型安全处理完成
- ✅ 错误处理和重试机制策略制定完成
- ✅ 请求缓存和性能优化方案设计完成
- ✅ 环境变量管理和测试策略制定完成
- ✅ 与Canvas监控引擎API兼容性验证完成
- ✅ 为Socket.IO实时通信预留扩展接口
- ✅ 完整的测试策略和Mock服务设计完成
- ✅ **扩展MCP记忆系统集成** - 集成艾宾浩斯复习系统和记忆统计数据
- ✅ **新增Canvas学习状态服务** - 提供Canvas学习进度和趋势分析
- ✅ **新增复习计划服务** - 基于遗忘曲线的智能复习提醒
- ✅ **MCP命令代理设计** - 为前端提供调用现有复习命令的接口
- ✅ **完整数据类型定义** - 复习任务、记忆统计、学习进度等核心数据模型

### File List
**Story文件:**
- `docs/stories/9.4.story.md` - 本Story文件

**预期实现文件:**
- `src/services/apiClient.ts` - HTTP客户端基础配置
- `src/services/canvasService.ts` - Canvas服务接口定义
- `src/services/mcpMemoryService.ts` ⭐ **新增** - MCP记忆系统服务
- `src/services/canvasLearningService.ts` ⭐ **新增** - Canvas学习状态服务
- `src/services/reviewScheduleService.ts` ⭐ **新增** - 复习计划服务
- `src/services/mcpCommandProxy.ts` ⭐ **新增** - MCP命令代理
- `src/services/types.ts` - API相关类型定义
- `src/hooks/useApiRequest.ts` - API请求状态管理Hook
- `src/hooks/useMCPCommand.ts` ⭐ **新增** - MCP命令调用Hook
- `src/utils/errorHandler.ts` - 错误处理工具函数
- `src/components/common/ApiErrorBoundary.tsx` - API错误边界组件

**测试文件:**
- `tests/services/apiClient.test.ts` - HTTP客户端测试
- `tests/services/canvasService.test.ts` - Canvas服务测试
- `tests/services/mcpMemoryService.test.ts` ⭐ **新增** - MCP记忆服务测试
- `tests/services/canvasLearningService.test.ts` ⭐ **新增** - Canvas学习服务测试
- `tests/services/reviewScheduleService.test.ts` ⭐ **新增** - 复习计划服务测试
- `tests/services/mcpCommandProxy.test.ts` ⭐ **新增** - MCP命令代理测试
- `tests/hooks/useApiRequest.test.ts` - API Hook测试
- `tests/hooks/useMCPCommand.test.ts` ⭐ **新增** - MCP命令Hook测试
- `mocks/api/handlers.ts` - MSW API处理器
- `mocks/mcp/handlers.ts` ⭐ **新增** - MCP命令Mock处理器

**配置文件:**
- `.env.development` - 开发环境API配置
- `.env.production` - 生产环境API配置

## QA Results
[待QA评估时填写]

---

**最后更新**: 2025-10-25
**Scrum Master**: Bob
**预计开发时间**: 5-7小时 focused development