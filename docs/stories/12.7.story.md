# Story 12.7: 3种融合算法实现

## Status: Approved

## Epic Context & Background

**所属Epic**: EPIC-12 - 三层记忆系统 + Agentic RAG
**Epic文档**: [EPIC-12-STORY-MAP.md](../epics/EPIC-12-STORY-MAP.md)

**本Story在Epic中的定位**:
- Phase 2 (检索融合层) 的核心Story
- 实现RRF、Weighted、Cascade三种融合算法
- **依赖**: Story 12.6 (并行检索结果可用)
- **被依赖**: Story 12.8, 12.9 (Reranking和Canvas集成依赖融合结果)

**Epic核心问题回顾**:

### Problem 11: 多源结果无融合机制
- **现象**: Graphiti和LanceDB结果各自独立，无法统一排序
- **根因**: 缺乏融合算法
- **修复**: 实现RRF、Weighted、Cascade三种融合算法
- **本Story验证**: 验证融合结果MRR@10 ≥ 0.350

### Problem 12: 融合策略无法自适应
- **现象**: 不同Canvas操作需要不同的融合策略
- **根因**: 缺乏自适应选择机制
- **修复**: 根据Canvas操作类型自动选择最优融合算法
- **本Story验证**: 验证自适应选择逻辑正确

---

## Story

**As a** Agentic RAG系统,
**I want** 使用多种融合算法合并Graphiti和LanceDB的检索结果,
**so that** 不同Canvas操作场景能获得最优的融合结果

---

## Acceptance Criteria

### AC 1: RRF算法正确实现 (验证Problem 11基础)
- **公式**: `RRF_score(d) = Σ(1/(k+rank_i(d)))` (k=60)
- **输入**:
  - `graphiti_results`: GraphSearchResults (nodes, edges, episodes)
  - `lancedb_results`: List[Dict] (含distance)
- **输出**: `List[UnifiedResult]` 按RRF分数排序
- **验证方式**: 单元测试验证RRF分数计算正确
- **架构来源**: `docs/architecture/FUSION-ALGORITHM-DESIGN.md` Section 2

### AC 2: Weighted算法支持alpha/beta参数 (验证Problem 11扩展)
- **公式**: `Weighted_score(d) = α*norm(graphiti) + β*norm(lancedb)` (α+β=1)
- **参数**:
  - `graphiti_weight`: float (默认0.7)
  - `lancedb_weight`: float (默认0.3)
  - `normalization`: "min_max" | "z_score"
- **验证方式**: 不同权重配置下排序结果变化符合预期
- **架构来源**: `docs/architecture/FUSION-ALGORITHM-DESIGN.md` Section 3

### AC 3: Cascade算法Tier 1/Tier 2正确触发 (验证Problem 11完整)
- **Tier 1**: Graphiti检索，结果足够(≥threshold, score≥min_score)则返回
- **Tier 2**: 结果不足时，调用LanceDB补充，使用RRF融合
- **参数**:
  - `graphiti_threshold`: int (默认5)
  - `graphiti_min_score`: float (默认0.7)
- **验证方式**: 模拟Tier 1不足场景，验证Tier 2触发
- **架构来源**: `docs/architecture/FUSION-ALGORITHM-DESIGN.md` Section 4

### AC 4: 自适应选择逻辑 (验证Problem 12)
- **决策树**:
  - 检验白板生成 → RRF (平衡)
  - 薄弱点聚类 → Weighted (α=0.7)
  - 概念关联检索 → Cascade (图优先)
  - 文档检索 → Weighted (β=0.7)
- **实现**: `FusionStrategy` 枚举 + `select_fusion_algorithm()` 函数
- **验证方式**: 给定Canvas操作类型，返回正确的融合算法
- **架构来源**: `docs/architecture/FUSION-ALGORITHM-DESIGN.md` Section 5.2

### AC 5: 融合结果质量 MRR@10 ≥ 0.350 (验证Problem 11核心指标)
- **评估数据集**: 100个测试query + 人工标注相关文档
- **评估指标**: MRR@10 (Mean Reciprocal Rank)
- **基线**: 单独Graphiti MRR@10 ≈ 0.280, 单独LanceDB MRR@10 ≈ 0.250
- **目标**: 融合后 MRR@10 ≥ 0.350 (提升25%+)
- **Epic关联**: 确保融合提升检索质量，而非仅仅合并
- **⚠️ 目标说明**: 0.350是Story层面最低验收门槛；Epic-12 MVP目标为≥0.380 (见EPIC-12-STORY-MAP.md)。达到0.350即可通过Story验收，后续Story 12.8-12.9 Reranking将进一步提升至0.380+

---

## Tasks / Subtasks

### 任务1: 创建融合算法模块结构 (AC: 1, 2, 3, 4)
- [ ] 1.1: 创建目录 `src/agentic_rag/fusion/`
- [ ] 1.2: 创建文件结构:
  ```
  src/agentic_rag/fusion/
  ├── __init__.py
  ├── unified_result.py      # UnifiedResult数据模型
  ├── rrf_fusion.py          # RRF算法
  ├── weighted_fusion.py     # Weighted算法
  ├── cascade_retrieval.py   # Cascade算法
  ├── strategy_selector.py   # 自适应选择
  └── evaluator.py           # MRR评估
  ```
- [ ] 1.3: 定义 `UnifiedResult` 数据模型

### 任务2: 实现RRF融合算法 (AC: 1)
- [ ] 2.1: 创建 `rrf_fusion.py`
  ```python
  # ✅ Verified from docs/architecture/FUSION-ALGORITHM-DESIGN.md Section 2
  from dataclasses import dataclass
  from typing import List, Dict

  @dataclass
  class UnifiedResult:
      id: str
      content: str
      source: str  # "graphiti" | "lancedb"
      type: str    # "node" | "edge" | "episode" | "document"
      original_score: float
      rrf_score: float = 0.0
      metadata: Dict = None

  def reciprocal_rank_fusion(
      graphiti_results: GraphSearchResults,
      lancedb_results: List[Dict],
      k: int = 60
  ) -> List[UnifiedResult]:
      """
      RRF融合: score(d) = Σ(1/(k+rank_i(d)))
      """
      # ... 实现详见架构文档
  ```
- [ ] 2.2: 实现Graphiti结果转换 (nodes, edges, episodes)
- [ ] 2.3: 实现LanceDB结果转换 (distance → score)
- [ ] 2.4: 实现RRF分数计算和排序
- [ ] 2.5: 测试: 验证RRF分数计算正确

### 任务3: 实现Weighted融合算法 (AC: 2)
- [ ] 3.1: 创建 `weighted_fusion.py`
  ```python
  # ✅ Verified from docs/architecture/FUSION-ALGORITHM-DESIGN.md Section 3
  def weighted_fusion(
      graphiti_results: GraphSearchResults,
      lancedb_results: List[Dict],
      graphiti_weight: float = 0.7,
      lancedb_weight: float = 0.3,
      normalization: str = "min_max"  # "min_max" | "z_score"
  ) -> List[UnifiedResult]:
      """
      Weighted Average Fusion
      score(d) = α*norm(graphiti) + β*norm(lancedb)
      """
      assert abs(graphiti_weight + lancedb_weight - 1.0) < 1e-6
      # ... 实现详见架构文档
  ```
- [ ] 3.2: 实现Min-Max归一化
- [ ] 3.3: 实现Z-Score归一化
- [ ] 3.4: 实现加权平均计算
- [ ] 3.5: 测试: 验证权重变化影响排序

### 任务4: 实现Cascade检索算法 (AC: 3)
- [ ] 4.1: 创建 `cascade_retrieval.py`
  ```python
  # ✅ Verified from docs/architecture/FUSION-ALGORITHM-DESIGN.md Section 4
  async def cascade_retrieval(
      query: str,
      graphiti_threshold: int = 5,
      graphiti_min_score: float = 0.7,
      use_lancedb_fallback: bool = True,
      num_results: int = 10
  ) -> Tuple[List[UnifiedResult], Dict[str, Any]]:
      """
      Cascade Retrieval: Graphiti优先，不足时回退到LanceDB
      """
      # Tier 1: Graphiti
      # Decision: 是否需要Tier 2?
      # Tier 2 (if needed): LanceDB + RRF融合
  ```
- [ ] 4.2: 实现Tier 1 Graphiti检索
- [ ] 4.3: 实现阈值判断逻辑
- [ ] 4.4: 实现Tier 2 LanceDB回退
- [ ] 4.5: 测试: 模拟Tier 1不足，验证Tier 2触发

### 任务5: 实现自适应选择器 (AC: 4)
- [ ] 5.1: 创建 `strategy_selector.py`
  ```python
  # ✅ Verified from docs/architecture/FUSION-ALGORITHM-DESIGN.md Section 5.2
  from enum import Enum

  class FusionStrategy(Enum):
      RRF = "rrf"
      WEIGHTED_GRAPHITI = "weighted_graphiti"  # α=0.7
      WEIGHTED_LANCEDB = "weighted_lancedb"    # β=0.7
      CASCADE = "cascade"

  class CanvasOperation(Enum):
      VERIFICATION_CANVAS = "verification_canvas"
      WEAK_POINT_CLUSTERING = "weak_point_clustering"
      CONCEPT_RELATION = "concept_relation"
      DOCUMENT_RETRIEVAL = "document_retrieval"

  def select_fusion_algorithm(operation: CanvasOperation) -> FusionStrategy:
      """自适应选择融合算法"""
      mapping = {
          CanvasOperation.VERIFICATION_CANVAS: FusionStrategy.RRF,
          CanvasOperation.WEAK_POINT_CLUSTERING: FusionStrategy.WEIGHTED_GRAPHITI,
          CanvasOperation.CONCEPT_RELATION: FusionStrategy.CASCADE,
          CanvasOperation.DOCUMENT_RETRIEVAL: FusionStrategy.WEIGHTED_LANCEDB,
      }
      return mapping.get(operation, FusionStrategy.RRF)
  ```
- [ ] 5.2: 实现融合执行器 `execute_fusion()`
- [ ] 5.3: 测试: 验证所有Canvas操作映射正确

### 任务6: 集成到fuse_results节点 (AC: 1, 2, 3, 4)
- [ ] 6.1: 修改 `src/agentic_rag/nodes/fuse_results.py`
  ```python
  # ✅ Updated from Story 12.5 fuse_results node
  from ..fusion.strategy_selector import (
      select_fusion_algorithm,
      execute_fusion,
      CanvasOperation,
      FusionStrategy
  )

  def fuse_results(state: CanvasRAGState) -> dict:
      """融合Graphiti和LanceDB检索结果"""
      operation = CanvasOperation(state.get("operation", "verification_canvas"))
      strategy = select_fusion_algorithm(operation)

      fused = execute_fusion(
          strategy=strategy,
          graphiti_results=state["graphiti_results"],
          lancedb_results=state["lancedb_results"]
      )

      return {"fused_results": fused}
  ```
- [ ] 6.2: 测试: 端到端验证融合节点工作

### 任务7: 实现MRR评估器 (AC: 5)
- [ ] 7.1: 创建 `evaluator.py`
  ```python
  def calculate_mrr_at_k(
      results: List[UnifiedResult],
      relevant_ids: Set[str],
      k: int = 10
  ) -> float:
      """计算MRR@K"""
      for i, result in enumerate(results[:k]):
          if result.id in relevant_ids:
              return 1.0 / (i + 1)
      return 0.0

  def evaluate_fusion(
      test_queries: List[Dict],
      fusion_func: Callable,
      k: int = 10
  ) -> Dict[str, float]:
      """评估融合算法"""
      mrr_scores = []
      for query in test_queries:
          results = fusion_func(query["text"])
          mrr = calculate_mrr_at_k(results, query["relevant_ids"], k)
          mrr_scores.append(mrr)

      return {
          "mrr@k": sum(mrr_scores) / len(mrr_scores),
          "num_queries": len(test_queries)
      }
  ```
- [ ] 7.2: 创建测试数据集 (100 queries + 标注)
- [ ] 7.3: 运行评估，验证MRR@10 ≥ 0.350

### 任务8: 创建测试套件 (AC: 1-5)
- [ ] 8.1: 创建 `src/tests/agentic_rag/test_fusion_algorithms.py`
- [ ] 8.2: 测试RRF算法
- [ ] 8.3: 测试Weighted算法
- [ ] 8.4: 测试Cascade算法
- [ ] 8.5: 测试自适应选择
- [ ] 8.6: 测试MRR评估

---

## Dev Notes

### Dependencies Verification

**前置依赖验证** (必须先完成):
- [ ] **Story 12.6已完成**: 并行检索结果可用
  - 验证命令: `pytest src/tests/agentic_rag/test_parallel_retrieval.py -v`
  - 验证文件: `src/agentic_rag/nodes/parallel_retrieval.py` 存在
- [ ] `state["graphiti_results"]` 和 `state["lancedb_results"]` 字段存在
  - 验证方法: 检查 `src/agentic_rag/state.py` 中 `CanvasRAGState` TypedDict定义
- [ ] GraphSearchResults数据模型可用 (from graphiti-core)
  - 验证命令: `python -c "from graphiti_core.search.search_utils import GraphSearchResults; print('OK')"`

**技术栈依赖**:
- [ ] graphiti-core (GraphSearchResults类型)
  - 验证: `pip show graphiti-core`
- [ ] numpy (Z-Score归一化)
  - 验证: `pip show numpy`
- [ ] pytest (测试框架)
  - 验证: `pip show pytest`

### SDD规范参考

**RRF公式** [Source: docs/architecture/FUSION-ALGORITHM-DESIGN.md Section 2.1]:

```python
# ✅ Verified from Architecture doc - RRF公式
RRF_score(d) = Σ(1/(k + rank_i(d)))

where:
    k = 60 (常数，防止高排名文档分数过高)
    rank_i(d) = 文档d在源i中的排名 (从1开始)
```

**Weighted公式** [Source: docs/architecture/FUSION-ALGORITHM-DESIGN.md Section 3.1]:

```python
# ✅ Verified from Architecture doc - Weighted公式
Weighted_score(d) = α * normalize(score_graphiti(d))
                  + β * normalize(score_lancedb(d))

where:
    α + β = 1
    α = Graphiti权重 (默认0.7)
    β = LanceDB权重 (默认0.3)
```

**Cascade决策逻辑** [Source: docs/architecture/FUSION-ALGORITHM-DESIGN.md Section 4.1]:

```python
# ✅ Verified from Architecture doc - Cascade决策树
if len(high_quality_graphiti) >= threshold:
    return graphiti_results  # Tier 1足够
else:
    # Tier 2: LanceDB回退 + RRF融合
    return rrf_fusion(graphiti_results, lancedb_results)
```

**Canvas场景推荐** [Source: docs/architecture/FUSION-ALGORITHM-DESIGN.md Section 5.2]:

| Canvas操作 | 推荐算法 | 配置参数 |
|-----------|---------|---------|
| 检验白板生成 | RRF | k=60 |
| 薄弱点聚类 | Weighted | α=0.7, β=0.3 |
| 概念关联检索 | Cascade | threshold=3, score≥0.6 |
| 文档检索 | Weighted | α=0.3, β=0.7 |

### ADR决策关联

**ADR-003: Graphiti Memory System** [Source: docs/architecture/decisions/0003-graphiti-memory.md]:
- **决策**: 使用Graphiti作为3层记忆系统的核心
- **融合需求**: Graphiti结果需要与LanceDB语义检索结果融合
- **本Story关系**: 实现融合层，支持多种融合策略

**融合算法设计文档** [Source: docs/architecture/FUSION-ALGORITHM-DESIGN.md]:
- **RRF**: 默认推荐，平衡两源结果
- **Weighted**: 可配置权重，适配特定场景
- **Cascade**: Graphiti优先，延迟优化

### Testing Standards

**测试文件位置**: `src/tests/agentic_rag/`

**测试类型**:
- 单元测试 (各融合算法)
- 集成测试 (fuse_results节点)
- 评估测试 (MRR@10基准)

**Mock策略**:
- Graphiti使用Mock GraphSearchResults
- LanceDB使用Mock结果列表
- 评估使用人工标注测试数据

**覆盖率目标**: ≥80%

### Performance Benchmarks

**性能目标** (from Epic 12 PRD):

| 融合算法 | 预期延迟 | 计算复杂度 |
|----------|---------|-----------|
| RRF | < 10ms | O(n) |
| Weighted | < 15ms | O(n) |
| Cascade Tier 1 | < 100ms | O(n) |
| Cascade Tier 2 | < 200ms | O(2n) |

### Related Documentation

**Epic和Story文档**:
- [EPIC-12-STORY-MAP.md](../epics/EPIC-12-STORY-MAP.md) - Epic 12完整Story Map
- [12.6.story.md](./12.6.story.md) - 并行检索实现 (前置依赖)
- [12.8.story.md](./12.8.story.md) - 混合Reranking (后续Story)

**架构文档** [Source: docs/architecture/]:
- [FUSION-ALGORITHM-DESIGN.md](../architecture/FUSION-ALGORITHM-DESIGN.md) - 融合算法详细设计
- [0003-graphiti-memory.md](../architecture/decisions/0003-graphiti-memory.md) - Graphiti记忆系统ADR

**外部文档**:
- Graphiti Skill: `.claude/skills/graphiti/SKILL.md`
- RRF论文参考: Cormack et al., "Reciprocal Rank Fusion"

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-28 | 1.0 | 初始创建 - SM Agent *draft | Bob (SM Agent) |
| 2025-11-28 | 1.1 | PO验证后修复: 1) AC5添加MRR目标差异说明 2) 添加前置依赖验证命令 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*待填写*

### Debug Log References
*待填写*

### Completion Notes List
*待填写*

### File List
*待填写*

---

## QA Results

*待QA Agent审查*
