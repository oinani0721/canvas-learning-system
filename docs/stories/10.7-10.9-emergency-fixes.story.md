# Epic 10紧急修复Story集 (10.7-10.9)

**创建日期**: 2025-10-29
**Epic**: Epic 10 - Canvas并行处理与学习系统完整集成
**状态**: 🔥 紧急修复中
**优先级**: 🔴 最高

---

# Story 10.7: Canvas集成协调器 (Problem 1紧急修复)

**Story ID**: STORY-010-007
**优先级**: 🔴 P0 (最高)
**故事点数**: 8
**预计工期**: 1天

---

## 📝 用户故事

**作为** Canvas学习系统用户
**我希望** /intelligent-parallel生成的Agent内容能够自动添加到Canvas白板中
**以便** 我能直接在Obsidian中看到生成的解释和总结，无需手动复制粘贴

## 🎯 验收标准

### 功能验收标准
- [ ] Agent生成内容后，自动在Canvas中创建蓝色解释节点
- [ ] 自动创建黄色总结节点（用于用户填写理解）
- [ ] 节点之间有正确的连接边
- [ ] 节点布局合理，无重叠
- [ ] Canvas文件更新成功率100%

### 性能验收标准
- [ ] 节点创建时间 < 500ms
- [ ] Canvas文件写入时间 < 2秒
- [ ] 支持并发写入（使用文件锁）

### 质量验收标准
- [ ] 单元测试覆盖率 ≥ 95%
- [ ] 集成测试通过率 100%
- [ ] 无Canvas文件损坏风险

---

## 🔧 技术实现方案

### 核心组件设计

```python
# 新增文件: canvas_utils/canvas_integration_coordinator.py

class CanvasIntegrationCoordinator:
    """Canvas集成协调器 - 连接并行处理和Canvas操作的桥梁"""

    def __init__(self, canvas_operator, canvas_orchestrator):
        self.canvas_op = canvas_operator
        self.canvas_orch = canvas_orchestrator
        self.node_layout = NodeLayoutEngine()
        self.transaction_mgr = CanvasTransactionManager()

    async def integrate_agent_result(self,
                                     agent_result: Dict,
                                     canvas_path: str,
                                     source_node_id: str) -> IntegrationResult:
        """
        将Agent执行结果集成到Canvas中

        这是Problem 1的核心解决方法
        """
        try:
            # 1. 开始事务
            transaction = await self.transaction_mgr.begin_transaction(canvas_path)

            # 2. 读取当前Canvas
            canvas_data = self.canvas_op.read_canvas(canvas_path)

            # 3. 创建蓝色解释节点
            explanation_node = await self._create_explanation_node(
                agent_result=agent_result,
                source_node_id=source_node_id,
                canvas_data=canvas_data
            )

            # 4. 创建黄色总结节点
            summary_node = await self._create_summary_node(
                explanation_node_id=explanation_node['id'],
                canvas_data=canvas_data
            )

            # 5. 创建连接边
            edges = await self._create_connection_edges(
                source_node_id=source_node_id,
                explanation_node_id=explanation_node['id'],
                summary_node_id=summary_node['id']
            )

            # 6. 添加到Canvas
            canvas_data['nodes'].extend([explanation_node, summary_node])
            canvas_data['edges'].extend(edges)

            # 7. 提交事务（原子性写入）
            await self.transaction_mgr.commit_transaction(
                transaction=transaction,
                canvas_data=canvas_data
            )

            return IntegrationResult(
                success=True,
                explanation_node_id=explanation_node['id'],
                summary_node_id=summary_node['id'],
                edges_created=len(edges)
            )

        except Exception as e:
            # 回滚事务
            await self.transaction_mgr.rollback_transaction(transaction)
            return IntegrationResult(
                success=False,
                error=str(e)
            )

    async def _create_explanation_node(self,
                                       agent_result: Dict,
                                       source_node_id: str,
                                       canvas_data: Dict) -> Dict:
        """创建蓝色解释节点"""
        # 1. 生成节点ID
        node_id = self._generate_node_id('explanation')

        # 2. 获取Agent类型和内容
        agent_type = agent_result.get('agent_type', 'unknown')
        content = agent_result.get('content', '')

        # 3. 计算节点位置（避免重叠）
        source_node = self.canvas_op.find_node_by_id(canvas_data, source_node_id)
        position = self.node_layout.calculate_position(
            source_node=source_node,
            node_type='explanation',
            existing_nodes=canvas_data['nodes']
        )

        # 4. 创建节点数据结构
        explanation_node = {
            'id': node_id,
            'type': 'text',
            'x': position['x'],
            'y': position['y'],
            'width': 700,  # 解释节点较宽
            'height': 500,  # 解释节点较高
            'color': '5',  # 蓝色 (AI解释)
            'text': self._format_explanation_text(agent_type, content)
        }

        return explanation_node

    async def _create_summary_node(self,
                                   explanation_node_id: str,
                                   canvas_data: Dict) -> Dict:
        """创建黄色总结节点（空白，供用户填写）"""
        node_id = self._generate_node_id('summary')

        # 获取解释节点位置
        explanation_node = self.canvas_op.find_node_by_id(canvas_data, explanation_node_id)

        # 计算位置（在解释节点右侧）
        position = self.node_layout.calculate_position(
            source_node=explanation_node,
            node_type='summary',
            existing_nodes=canvas_data['nodes']
        )

        summary_node = {
            'id': node_id,
            'type': 'text',
            'x': position['x'],
            'y': position['y'],
            'width': 600,
            'height': 400,
            'color': '6',  # 黄色 (个人理解)
            'text': ''  # 空白，供用户填写
        }

        return summary_node

    async def _create_connection_edges(self,
                                       source_node_id: str,
                                       explanation_node_id: str,
                                       summary_node_id: str) -> List[Dict]:
        """创建连接边"""
        edges = []

        # 边1: 源节点 → 解释节点
        edges.append({
            'id': self._generate_edge_id(),
            'fromNode': source_node_id,
            'toNode': explanation_node_id,
            'color': '5',  # 蓝色
            'label': 'AI解释'
        })

        # 边2: 解释节点 → 总结节点
        edges.append({
            'id': self._generate_edge_id(),
            'fromNode': explanation_node_id,
            'toNode': summary_node_id,
            'color': '6',  # 黄色
            'label': '个人总结'
        })

        return edges

    def _format_explanation_text(self, agent_type: str, content: str) -> str:
        """格式化解释文本"""
        agent_names = {
            'oral-explanation': '口语化解释',
            'clarification-path': '澄清路径',
            'comparison-table': '对比表格',
            'memory-anchor': '记忆锚点',
            'four-level-explanation': '四层次解释',
            'example-teaching': '例题教学'
        }

        agent_display = agent_names.get(agent_type, agent_type)

        return f"""# {agent_display}

{content}

---
*本内容由{agent_display} Agent自动生成*
"""

class NodeLayoutEngine:
    """节点布局引擎 - 智能计算节点位置"""

    def calculate_position(self,
                          source_node: Dict,
                          node_type: str,
                          existing_nodes: List[Dict]) -> Dict:
        """计算新节点位置，避免重叠"""
        base_x = source_node['x']
        base_y = source_node['y']
        base_height = source_node['height']

        if node_type == 'explanation':
            # 解释节点放在源节点下方
            x = base_x
            y = base_y + base_height + 50  # 50px间距

            # 检查重叠
            while self._has_overlap(x, y, 700, 500, existing_nodes):
                y += 100  # 向下移动直到无重叠

        elif node_type == 'summary':
            # 总结节点放在解释节点右侧
            x = base_x + source_node['width'] + 50
            y = base_y

            # 检查重叠
            while self._has_overlap(x, y, 600, 400, existing_nodes):
                x += 100  # 向右移动直到无重叠

        return {'x': x, 'y': y}

    def _has_overlap(self, x: int, y: int, width: int, height: int,
                    existing_nodes: List[Dict]) -> bool:
        """检查是否与现有节点重叠"""
        for node in existing_nodes:
            if self._rectangles_overlap(
                x, y, width, height,
                node['x'], node['y'], node['width'], node['height']
            ):
                return True
        return False

    def _rectangles_overlap(self, x1, y1, w1, h1, x2, y2, w2, h2) -> bool:
        """检查两个矩形是否重叠"""
        return not (x1 + w1 < x2 or x2 + w2 < x1 or
                   y1 + h1 < y2 or y2 + h2 < y1)

class CanvasTransactionManager:
    """Canvas事务管理器 - 确保原子性操作"""

    async def begin_transaction(self, canvas_path: str) -> Transaction:
        """开始事务"""
        # 1. 获取文件锁
        lock = await self._acquire_file_lock(canvas_path)

        # 2. 创建备份
        backup_path = await self._create_backup(canvas_path)

        return Transaction(
            canvas_path=canvas_path,
            lock=lock,
            backup_path=backup_path,
            start_time=datetime.now()
        )

    async def commit_transaction(self, transaction: Transaction, canvas_data: Dict):
        """提交事务（原子性写入）"""
        try:
            # 1. 写入临时文件
            temp_path = f"{transaction.canvas_path}.tmp"
            with open(temp_path, 'w', encoding='utf-8') as f:
                json.dump(canvas_data, f, ensure_ascii=False, indent='\t')

            # 2. 原子性替换
            os.replace(temp_path, transaction.canvas_path)

            # 3. 释放锁
            await self._release_file_lock(transaction.lock)

        except Exception as e:
            # 失败则回滚
            await self.rollback_transaction(transaction)
            raise e

    async def rollback_transaction(self, transaction: Transaction):
        """回滚事务（恢复备份）"""
        if transaction.backup_path and os.path.exists(transaction.backup_path):
            shutil.copy2(transaction.backup_path, transaction.canvas_path)

        # 释放锁
        if transaction.lock:
            await self._release_file_lock(transaction.lock)

@dataclass
class IntegrationResult:
    success: bool
    explanation_node_id: Optional[str] = None
    summary_node_id: Optional[str] = None
    edges_created: int = 0
    error: Optional[str] = None

@dataclass
class Transaction:
    canvas_path: str
    lock: Any
    backup_path: str
    start_time: datetime
```

### 集成到ConcurrentAgentProcessor

```python
# 修改文件: canvas_utils.py (ConcurrentAgentProcessor部分)

class ConcurrentAgentProcessor:
    def __init__(self):
        # ... 现有代码 ...

        # 新增: Canvas集成协调器
        self.canvas_coordinator = CanvasIntegrationCoordinator(
            canvas_operator=CanvasJSONOperator(),
            canvas_orchestrator=CanvasOrchestrator()
        )

    async def process_tasks_parallel(self, tasks: List[Dict], canvas_path: str) -> List[Dict]:
        """并行处理任务（修复版）"""
        results = []

        for task in tasks:
            # 1. 执行Agent
            agent_result = await self._execute_agent(task)

            # 2. 集成到Canvas (Problem 1的核心修复)
            integration_result = await self.canvas_coordinator.integrate_agent_result(
                agent_result=agent_result,
                canvas_path=canvas_path,
                source_node_id=task['node_id']
            )

            # 3. 记录结果
            results.append({
                'task_id': task['id'],
                'agent_result': agent_result,
                'canvas_integration': integration_result,
                'success': integration_result.success
            })

        return results
```

---

## 📋 开发任务清单

### 任务1: 创建Canvas集成协调器
- [ ] 创建 `canvas_utils/canvas_integration_coordinator.py`
- [ ] 实现 `CanvasIntegrationCoordinator` 类
- [ ] 实现 `integrate_agent_result()` 方法
- [ ] 实现节点创建逻辑

### 任务2: 实现节点布局引擎
- [ ] 创建 `NodeLayoutEngine` 类
- [ ] 实现位置计算算法
- [ ] 实现重叠检测
- [ ] 优化布局美观性

### 任务3: 实现事务管理器
- [ ] 创建 `CanvasTransactionManager` 类
- [ ] 实现文件锁机制
- [ ] 实现备份和回滚
- [ ] 确保原子性操作

### 任务4: 集成到现有代码
- [ ] 修改 `ConcurrentAgentProcessor`
- [ ] 添加Canvas集成调用
- [ ] 更新错误处理逻辑
- [ ] 确保向后兼容

### 任务5: 测试和验证
- [ ] 编写单元测试
- [ ] 编写集成测试
- [ ] 端到端测试
- [ ] 性能测试

---

## 🧪 测试计划

### 验收测试
```python
async def test_intelligent_parallel_canvas_integration():
    """测试完整的并行处理+Canvas集成流程"""
    # 1. 准备测试Canvas
    canvas_path = "tests/fixtures/test.canvas"

    # 2. 运行intelligent-parallel
    result = await run_intelligent_parallel(canvas_path)

    # 3. 验证Canvas更新
    canvas_data = read_canvas(canvas_path)

    # 4. 检查蓝色节点
    blue_nodes = [n for n in canvas_data['nodes'] if n['color'] == '5']
    assert len(blue_nodes) > 0, "应该有蓝色解释节点"

    # 5. 检查黄色节点
    yellow_nodes = [n for n in canvas_data['nodes'] if n['color'] == '6']
    assert len(yellow_nodes) > 0, "应该有黄色总结节点"

    # 6. 检查连接边
    new_edges = [e for e in canvas_data['edges'] if 'AI解释' in e.get('label', '')]
    assert len(new_edges) > 0, "应该有连接边"

    # 7. 验证节点内容
    for blue_node in blue_nodes:
        assert len(blue_node['text']) > 100, "解释节点应该有实质内容"
```

---

# Story 10.8: 真实学习服务启动器 (Problem 2紧急修复)

**Story ID**: STORY-010-008
**优先级**: 🔴 P0 (最高)
**故事点数**: 5
**预计工期**: 1天

---

## 📝 用户故事

**作为** Canvas学习系统用户
**我希望** /learning命令能够真正启动所有三级记忆系统
**以便** 我的学习过程被完整记录，数据不会丢失

## 🎯 验收标准

### 功能验收标准
- [ ] Graphiti知识图谱真实启动
- [ ] MCP语义服务真实启动
- [ ] 学习行为监控真实启动
- [ ] /learning status能显示所有服务状态
- [ ] 三级记忆数据真实写入

### 性能验收标准
- [ ] 服务启动时间 < 3秒
- [ ] 记录延迟 < 100ms
- [ ] 内存占用 < 50MB

### 质量验收标准
- [ ] 服务启动成功率 100%
- [ ] 记录完整性 100%
- [ ] 支持服务重启恢复

---

## 🔧 技术实现方案

### 核心组件设计

```python
# 新增文件: learning_system/real_service_launcher.py

class RealServiceLauncher:
    """真实学习服务启动器 - Problem 2的核心解决方案"""

    def __init__(self):
        self.graphiti_client = None
        self.mcp_client = None
        self.behavior_monitor = None
        self.service_health = {}

    async def start_all_services(self, canvas_path: str, session: LearningSession) -> Dict:
        """启动所有学习服务（真实实现）"""
        results = {
            'graphiti': await self._start_graphiti_real(canvas_path, session),
            'mcp_semantic': await self._start_mcp_semantic_real(canvas_path, session),
            'behavior_monitor': await self._start_behavior_monitor_real(session)
        }

        # 验证服务健康
        await self._verify_services_health()

        return results

    async def _start_graphiti_real(self, canvas_path: str, session: LearningSession) -> Dict:
        """真正启动Graphiti知识图谱"""
        try:
            # 1. 初始化Graphiti MCP客户端
            from mcp_graphiti import GraphitiClient
            self.graphiti_client = GraphitiClient()

            # 2. 连接到Graphiti服务
            await self.graphiti_client.connect()

            # 3. 创建学习会话记录
            session_key = f"learning_session_{session.session_id}"
            await mcp__graphiti_memory__add_memory(
                key=session_key,
                content=f"开始学习会话: {canvas_path}",
                metadata={
                    'type': 'session_start',
                    'canvas_path': canvas_path,
                    'session_id': session.session_id
                }
            )

            # 4. 验证记录成功
            memory = await mcp__graphiti_memory__get_memory(session_key)
            if not memory:
                raise Exception("Graphiti记录验证失败")

            return {
                'success': True,
                'service': 'graphiti',
                'status': 'running',
                'session_key': session_key
            }

        except Exception as e:
            logger.error(f"Graphiti启动失败: {e}")
            return {
                'success': False,
                'service': 'graphiti',
                'error': str(e)
            }

    async def _start_mcp_semantic_real(self, canvas_path: str, session: LearningSession) -> Dict:
        """真正启动MCP语义服务"""
        try:
            # 1. 初始化MCP客户端
            from unified_memory_interface import UnifiedMemoryInterface
            self.mcp_client = UnifiedMemoryInterface()

            # 2. 连接到MCP服务
            await self.mcp_client.connect()

            # 3. 存储语义记忆
            canvas_id = Path(canvas_path).stem
            result = await self.mcp_client.store_memory(
                canvas_id=canvas_id,
                event_type='session_start',
                content="开始学习会话",
                color='green',
                importance=1.0
            )

            # 4. 验证存储成功
            if not result or not result.get('success'):
                raise Exception("MCP语义记忆存储失败")

            return {
                'success': True,
                'service': 'mcp_semantic',
                'status': 'running',
                'memory_id': result.get('memory_id')
            }

        except Exception as e:
            logger.error(f"MCP语义服务启动失败: {e}")
            return {
                'success': False,
                'service': 'mcp_semantic',
                'error': str(e)
            }

    async def _start_behavior_monitor_real(self, session: LearningSession) -> Dict:
        """真正启动学习行为监控"""
        try:
            # 1. 初始化行为监控器
            from learning_activity_capture import LearningActivityCapture
            self.behavior_monitor = LearningActivityCapture()

            # 2. 启动监控
            await self.behavior_monitor.start_monitoring(
                session_id=session.session_id,
                canvas_path=session.canvas_path
            )

            # 3. 验证监控运行
            status = await self.behavior_monitor.get_status()
            if status['status'] != 'running':
                raise Exception("行为监控启动但未运行")

            return {
                'success': True,
                'service': 'behavior_monitor',
                'status': 'running',
                'monitor_id': status.get('monitor_id')
            }

        except Exception as e:
            logger.error(f"行为监控启动失败: {e}")
            return {
                'success': False,
                'service': 'behavior_monitor',
                'error': str(e)
            }

    async def _verify_services_health(self) -> Dict:
        """验证所有服务健康状态"""
        health_checks = {}

        # 检查Graphiti
        if self.graphiti_client:
            try:
                await self.graphiti_client.ping()
                health_checks['graphiti'] = 'healthy'
            except:
                health_checks['graphiti'] = 'unhealthy'

        # 检查MCP
        if self.mcp_client:
            try:
                await self.mcp_client.ping()
                health_checks['mcp_semantic'] = 'healthy'
            except:
                health_checks['mcp_semantic'] = 'unhealthy'

        # 检查行为监控
        if self.behavior_monitor:
            try:
                status = await self.behavior_monitor.get_status()
                health_checks['behavior_monitor'] = 'healthy' if status['status'] == 'running' else 'unhealthy'
            except:
                health_checks['behavior_monitor'] = 'unhealthy'

        self.service_health = health_checks
        return health_checks

    async def get_services_status(self) -> Dict:
        """获取所有服务状态"""
        return {
            'graphiti': {
                'status': 'running' if self.graphiti_client else 'stopped',
                'health': self.service_health.get('graphiti', 'unknown')
            },
            'mcp_semantic': {
                'status': 'running' if self.mcp_client else 'stopped',
                'health': self.service_health.get('mcp_semantic', 'unknown')
            },
            'behavior_monitor': {
                'status': 'running' if self.behavior_monitor else 'stopped',
                'health': self.service_health.get('behavior_monitor', 'unknown')
            }
        }

    async def stop_all_services(self):
        """停止所有服务"""
        if self.graphiti_client:
            await self.graphiti_client.disconnect()

        if self.mcp_client:
            await self.mcp_client.disconnect()

        if self.behavior_monitor:
            await self.behavior_monitor.stop_monitoring()
```

### 修改LearningSessionWrapper

```python
# 修改文件: learning_session_wrapper.py

class LearningSessionWrapper:
    def __init__(self):
        # 替换mock实现为真实服务启动器
        self.service_launcher = RealServiceLauncher()

    async def start_session(self, canvas_path: str, options: Dict) -> LearningSession:
        """启动学习会话（修复版）"""
        session = LearningSession(
            session_id=self._generate_session_id(),
            canvas_path=canvas_path,
            user_id=options.get('user_id', 'default'),
            start_time=datetime.now()
        )

        # 真正启动所有服务（Problem 2的核心修复）
        results = await self.service_launcher.start_all_services(canvas_path, session)

        # 检查启动结果
        if not all(r['success'] for r in results.values()):
            failed_services = [k for k, v in results.items() if not v['success']]
            logger.error(f"服务启动失败: {failed_services}")

        session.services_status = results
        return session

    async def get_session_status(self, session_id: str) -> Dict:
        """获取会话状态"""
        # 获取真实服务状态
        services_status = await self.service_launcher.get_services_status()

        return {
            'session_id': session_id,
            'services': services_status,
            'all_healthy': all(
                s['status'] == 'running' and s['health'] == 'healthy'
                for s in services_status.values()
            )
        }
```

---

## 📋 开发任务清单

### 任务1: 创建真实服务启动器
- [ ] 创建 `learning_system/real_service_launcher.py`
- [ ] 实现 `RealServiceLauncher` 类
- [ ] 实现Graphiti真实调用
- [ ] 实现MCP真实调用
- [ ] 实现行为监控真实启动

### 任务2: 服务健康检查
- [ ] 实现服务健康验证
- [ ] 实现服务状态查询
- [ ] 实现自动重连机制
- [ ] 添加服务降级策略

### 任务3: 修改LearningSessionWrapper
- [ ] 移除mock实现
- [ ] 集成RealServiceLauncher
- [ ] 更新错误处理
- [ ] 确保向后兼容

### 任务4: 测试和验证
- [ ] 编写单元测试
- [ ] 编写集成测试
- [ ] 服务可用性测试
- [ ] 数据完整性验证

---

## 🧪 测试计划

### 验收测试
```python
async def test_learning_command_real_activation():
    """测试/learning命令的真实激活"""
    # 1. 启动学习会话
    session = await start_learning_session("test.canvas")

    # 2. 等待服务启动
    await asyncio.sleep(2)

    # 3. 获取服务状态
    status = await get_session_status(session.session_id)

    # 4. 验证Graphiti运行
    assert status['services']['graphiti']['status'] == 'running'
    assert status['services']['graphiti']['health'] == 'healthy'

    # 5. 验证MCP语义服务运行
    assert status['services']['mcp_semantic']['status'] == 'running'
    assert status['services']['mcp_semantic']['health'] == 'healthy'

    # 6. 验证行为监控运行
    assert status['services']['behavior_monitor']['status'] == 'running'
    assert status['services']['behavior_monitor']['health'] == 'healthy'

    # 7. 验证数据记录
    # 检查Graphiti记忆
    graphiti_memories = await mcp__graphiti_memory__list_memories()
    assert len(graphiti_memories) > 0

    # 检查MCP语义记忆
    mcp_memories = await get_mcp_memories(session.session_id)
    assert len(mcp_memories) > 0

    # 检查行为记录
    behavior_records = await get_behavior_records(session.session_id)
    assert len(behavior_records) > 0
```

---

# Story 10.9: 端到端集成验证

**Story ID**: STORY-010-009
**优先级**: 🟡 P1 (高)
**故事点数**: 3
**预计工期**: 1天

---

## 📝 用户故事

**作为** 系统维护者
**我希望** 有完整的端到端测试验证所有修复
**以便** 确保系统真正可用，无隐藏问题

## 🎯 验收标准

- [ ] 完整学习流程端到端测试通过
- [ ] Canvas操作完整性验证通过
- [ ] 三级记忆系统验证通过
- [ ] 并发安全性测试通过
- [ ] 性能基准测试通过

## 🔧 测试实现

```python
# tests/test_epic10_e2e.py

async def test_complete_learning_workflow():
    """完整学习工作流端到端测试"""
    # Phase 1: 启动学习会话
    session = await start_learning_session("test_learning.canvas")
    assert session.session_id is not None

    # Phase 2: 运行智能并行处理
    parallel_result = await run_intelligent_parallel("test_learning.canvas")
    assert parallel_result['success'] == True

    # Phase 3: 验证Canvas更新
    canvas_data = read_canvas("test_learning.canvas")
    blue_nodes = [n for n in canvas_data['nodes'] if n['color'] == '5']
    yellow_nodes = [n for n in canvas_data['nodes'] if n['color'] == '6']
    assert len(blue_nodes) > 0
    assert len(yellow_nodes) > 0

    # Phase 4: 验证学习记录
    graphiti_records = await get_graphiti_records(session.session_id)
    mcp_records = await get_mcp_records(session.session_id)
    behavior_records = await get_behavior_records(session.session_id)
    assert len(graphiti_records) > 0
    assert len(mcp_records) > 0
    assert len(behavior_records) > 0

    # Phase 5: 停止学习会话
    stop_result = await stop_learning_session(session.session_id)
    assert stop_result['success'] == True
```

---

## 🚀 实施时间表

| Story | 任务 | 时间 | 负责人 | 状态 |
|-------|------|------|--------|------|
| 10.7 | Canvas集成协调器 | Day 1 | Dev Team | 待开发 |
| 10.8 | 真实服务启动器 | Day 2 | Dev Team | 待开发 |
| 10.9 | 端到端验证 | Day 3 | QA Team | 待开发 |

---

**文档状态**: ✅ 已评审
**创建日期**: 2025-10-29
**紧急程度**: 🔴 最高
**预计完成**: 2025-11-01 (3个工作日)
