# Story 12.9: 质量控制循环

## Status: Approved

## Epic Context & Background

**所属Epic**: EPIC-12 - 三层记忆系统 + Agentic RAG
**Epic文档**: [EPIC-12-STORY-MAP.md](../epics/EPIC-12-STORY-MAP.md)

**本Story在Epic中的定位**:
- Phase 2 (检索融合层) 的收尾Story
- 实现Agentic RAG的自我修正循环 (Self-Correction Loop)
- **依赖**: Story 12.7 (融合算法), Story 12.8 (Reranking)
- **被依赖**: Story 12.10 (检验白板集成依赖完整的Agentic RAG)

**Epic核心问题回顾**:

### Problem 11: 低质量检索结果无优化机制
- **现象**: 模糊查询或噪声数据导致检索结果质量低
- **根因**: 缺乏质量评估和自动重试机制
- **修复**: 实现Quality Checker + Query Rewriter循环
- **本Story验证**: 验证low质量触发重写，重写后质量提升

### Problem 12: 检索死循环风险
- **现象**: 持续低质量可能导致无限重写
- **根因**: 缺乏硬编码退出条件
- **修复**: max_rewrite=2，总延迟<10秒
- **本Story验证**: 验证最多2次迭代后强制返回

---

## Story

**As a** Agentic RAG系统,
**I want** 实现质量检查和Query重写循环,
**so that** 在检索质量不足时自动优化查询，提升最终结果

---

## Acceptance Criteria

### AC 1: Quality checker正确分级 (验证Problem 11基础)
- **分级标准**:
  - `high`: Top-3平均分 ≥ 0.7
  - `medium`: Top-3平均分 0.5-0.7
  - `low`: Top-3平均分 < 0.5
- **质量评分维度** (4维度加权):
  - 薄弱点覆盖率 (40%)
  - 平均相关性分数 (30%)
  - 数据源多样性 (20%)
  - 文档数量 (10%)
- **验证方式**: 单元测试验证3种分级正确
- **Context7来源**: LangGraph Skill - "Conditional edges for dynamic routing"

### AC 2: Query rewriter在low质量时触发 (验证Problem 11核心)
- **触发条件**: `quality_grade == "low" AND retry_count < 2`
- **LLM调用**: gpt-3.5-turbo (成本低，速度快)
- **Prompt策略**:
  - 薄弱点覆盖率不足 → 明确要求temporal数据源
  - 相关性分数低 → 优化关键词
  - 数据源单一 → 要求多工具调用
- **Epic关联**: 自动优化低质量检索

### AC 3: 最多2次迭代后强制返回 (验证Problem 12)
- **退出条件**:
  - `retry_count >= 2`: 直接返回END
  - `quality_score >= 0.5`: 提前退出
  - `total_latency >= 10秒`: 超时退出
- **验证方式**: 集成测试验证循环次数≤2
- **Context7来源**: LangGraph Skill - "timeout policies to prevent infinite loops"

### AC 4: Rewrite后质量提升 (验证Problem 11效果)
- **测试集**: 20个low质量query
- **预期结果**:
  - 平均quality_grade提升 (low → medium/high)
  - avg_score提升 ≥ +0.15
- **验证方式**: 对比Rewrite前后质量分数
- **Epic关联**: 确保自我修正有效

### AC 5: 循环逻辑正确 (验证Problem 11+12完整性)
- **StateGraph流程**:
  ```
  grade_documents → (low?) → rewrite_query → question_router → retrieve → grade_documents
                 → (medium/high?) → generate → END
  ```
- **验证方式**: LangSmith trace可视化，确认循环路径正确
- **Epic关联**: 完整Agentic RAG自我修正机制

---

## Tasks / Subtasks

### 任务1: 实现QualityChecker类 (AC: 1)
- [ ] 1.1: 创建 `src/agentic_rag/quality/quality_checker.py`
  ```python
  # ✅ Verified from LANGGRAPH-MEMORY-INTEGRATION-DESIGN.md (Section 10.5.2)
  from enum import Enum
  from typing import List, Dict

  class QualityGrade(str, Enum):
      HIGH = "high"      # Top-3平均分 >= 0.7
      MEDIUM = "medium"  # Top-3平均分 0.5-0.7
      LOW = "low"        # Top-3平均分 < 0.5

  class QualityChecker:
      """检索结果质量评估器"""

      def __init__(self, config: dict = None):
          self.config = config or {}
          # 权重配置
          self.weak_point_weight = 0.4   # 薄弱点覆盖率
          self.relevance_weight = 0.3    # 平均相关性
          self.diversity_weight = 0.2    # 数据源多样性
          self.doc_count_weight = 0.1    # 文档数量

      def grade_documents(self, documents: List[Dict]) -> Dict:
          """评估文档质量，返回分级和详细信息"""
          if not documents:
              return {
                  "quality_grade": QualityGrade.LOW,
                  "quality_score": 0.0,
                  "quality_issues": ["No documents retrieved"]
              }

          score = 0.0
          issues = []

          # 1. 薄弱点覆盖率 (40%)
          temporal_docs = [d for d in documents if d.get("source") == "temporal"]
          weak_point_coverage = len(temporal_docs) / max(len(documents), 1)
          score += weak_point_coverage * self.weak_point_weight
          if weak_point_coverage < 0.5:
              issues.append("薄弱点覆盖率不足(<50%)")

          # 2. 平均相关性 (30%)
          avg_relevance = sum(
              d.get("metadata", {}).get("relevance_score", 0)
              for d in documents
          ) / len(documents)
          score += avg_relevance * self.relevance_weight
          if avg_relevance < 0.6:
              issues.append(f"平均相关性分数过低({avg_relevance:.2f})")

          # 3. 数据源多样性 (20%)
          sources = set(d.get("source", "unknown") for d in documents)
          source_diversity = len(sources) / 3.0  # 最多3个数据源
          score += source_diversity * self.diversity_weight
          if len(sources) < 2:
              issues.append("数据源单一(建议至少2个)")

          # 4. 文档数量 (10%)
          doc_count_score = min(len(documents) / 20.0, 1.0)
          score += doc_count_score * self.doc_count_weight
          if len(documents) < 10:
              issues.append(f"文档数量不足({len(documents)}<10)")

          # 分级
          if score >= 0.7:
              grade = QualityGrade.HIGH
          elif score >= 0.5:
              grade = QualityGrade.MEDIUM
          else:
              grade = QualityGrade.LOW

          return {
              "quality_grade": grade,
              "quality_score": score,
              "quality_issues": issues
          }
  ```
- [ ] 1.2: 测试: 验证3种分级正确

### 任务2: 实现QueryRewriter类 (AC: 2)
- [ ] 2.1: 创建 `src/agentic_rag/quality/query_rewriter.py`
  ```python
  # ✅ Verified from LANGGRAPH-MEMORY-INTEGRATION-DESIGN.md (Node 3: rewrite_query)
  from langchain_openai import ChatOpenAI
  from typing import List

  class QueryRewriter:
      """查询重写器 - 优化低质量查询"""

      def __init__(self, model: str = "gpt-3.5-turbo"):
          self.llm = ChatOpenAI(model=model, temperature=0.3)

      async def rewrite(self, original_query: str, quality_issues: List[str]) -> str:
          """基于质量问题重写查询"""

          system_prompt = """你是查询优化专家。

  当前查询的问题:
  {quality_issues}

  请重写查询,改进策略:
  1. 如果薄弱点覆盖率不足 → 明确要求检索历史薄弱点数据
  2. 如果相关性分数低 → 使用更精确的关键词
  3. 如果数据源单一 → 明确要求多数据源检索
  4. 如果文档数量不足 → 扩展查询范围

  原查询: {original_query}

  请输出重写后的查询（仅输出查询文本）:"""

          response = await self.llm.ainvoke([
              {
                  "role": "system",
                  "content": system_prompt.format(
                      quality_issues="\n".join(quality_issues),
                      original_query=original_query
                  )
              }
          ])

          return response.content.strip()
  ```
- [ ] 2.2: 测试: 验证重写逻辑

### 任务3: 实现grade_documents节点 (AC: 1, 5)
- [ ] 3.1: 创建 `src/agentic_rag/nodes/grade_documents.py`
  ```python
  # ✅ Verified from LangGraph Skill - Node function pattern
  from ..state import CanvasRAGState
  from ..quality.quality_checker import QualityChecker

  async def grade_documents_node(state: CanvasRAGState) -> dict:
      """文档质量评分节点"""
      checker = QualityChecker()

      # 获取检索结果 (使用Schema定义的fused_results字段)
      documents = state.get("fused_results", [])

      # 评估质量
      result = checker.grade_documents(documents)

      # 更新重试计数 (使用Schema定义的retry_count字段)
      retry_count = state.get("retry_count", 0)

      return {
          "quality_grade": result["quality_grade"],
          "quality_score": result["quality_score"],
          "quality_issues": result["quality_issues"],
          "retry_count": retry_count
      }
  ```
- [ ] 3.2: 测试: 验证节点返回值正确

### 任务4: 实现rewrite_query节点 (AC: 2, 3)
- [ ] 4.1: 创建 `src/agentic_rag/nodes/rewrite_query.py`
  ```python
  # ✅ Verified from LangGraph Skill - Async node pattern
  from ..state import CanvasRAGState
  from ..quality.query_rewriter import QueryRewriter

  async def rewrite_query_node(state: CanvasRAGState) -> dict:
      """查询重写节点"""
      rewriter = QueryRewriter()

      original_query = state.get("query", "")
      quality_issues = state.get("quality_issues", [])
      retry_count = state.get("retry_count", 0)  # 使用Schema定义的retry_count字段

      # 重写查询
      new_query = await rewriter.rewrite(original_query, quality_issues)

      return {
          "query": new_query,
          "retry_count": retry_count + 1,  # 使用Schema定义的retry_count字段
          "original_queries": state.get("original_queries", []) + [original_query]
      }
  ```
- [ ] 4.2: 测试: 验证重写计数递增

### 任务5: 实现条件路由函数 (AC: 3, 5)
- [ ] 5.1: 创建 `src/agentic_rag/routing/quality_router.py`
  ```python
  # ✅ Verified from LangGraph Skill - Conditional edges pattern
  from ..state import CanvasRAGState
  from ..quality.quality_checker import QualityGrade

  def grade_documents_route(state: CanvasRAGState) -> str:
      """
      基于文档质量决定下一步
      - generate: 质量足够，直接生成
      - rewrite: 质量不足，重写查询
      """
      quality_score = state.get("quality_score", 0.0)
      retry_count = state.get("retry_count", 0)  # 使用Schema定义的retry_count字段

      # 质量足够 → 生成
      if quality_score >= 0.5:
          return "generate"

      # 已达最大重试次数 → 强制生成
      if retry_count >= 2:
          return "generate"

      # 质量不足且可重试 → 重写
      return "rewrite"
  ```
- [ ] 5.2: 测试: 验证3种路由条件

### 任务6: 更新StateGraph添加循环边 (AC: 5)
- [ ] 6.1: 修改 `src/agentic_rag/graph.py`
  ```python
  # ✅ Verified from LangGraph Skill - Conditional edges
  from .nodes.grade_documents import grade_documents_node
  from .nodes.rewrite_query import rewrite_query_node
  from .routing.quality_router import grade_documents_route

  # 添加节点
  builder.add_node("grade_documents", grade_documents_node)
  builder.add_node("rewrite", rewrite_query_node)

  # 添加循环边
  # rerank → grade_documents
  builder.add_edge("rerank", "grade_documents")

  # grade_documents → (rewrite | generate)
  builder.add_conditional_edges(
      "grade_documents",
      grade_documents_route,
      {
          "rewrite": "rewrite",
          "generate": "generate"
      }
  )

  # rewrite → question_router (重新进入检索流程)
  builder.add_edge("rewrite", "question_router")
  ```
- [ ] 6.2: 测试: 验证图编译成功

### 任务7: 性能测试和质量验证 (AC: 4)
- [ ] 7.1: 创建 `src/tests/agentic_rag/test_quality_control.py`
- [ ] 7.2: 实现20个low质量query测试
  ```python
  import pytest
  from agentic_rag.graph import canvas_agentic_rag

  @pytest.mark.asyncio
  async def test_quality_improvement():
      """验证Rewrite后质量提升"""
      low_quality_queries = [
          "离散数学",  # 太模糊
          "逻辑",      # 过于宽泛
          # ... 20个测试query
      ]

      improvements = []
      for query in low_quality_queries:
          # 第一次检索
          result_before = await canvas_agentic_rag.ainvoke({
              "query": query,
              "max_rewrites": 0  # 禁用重写
          })

          # 启用重写
          result_after = await canvas_agentic_rag.ainvoke({
              "query": query,
              "max_rewrites": 2
          })

          improvement = result_after["quality_score"] - result_before["quality_score"]
          improvements.append(improvement)

      avg_improvement = sum(improvements) / len(improvements)
      assert avg_improvement >= 0.15, f"平均质量提升应≥0.15，实际: {avg_improvement:.3f}"
  ```
- [ ] 7.3: 生成质量提升报告

### 任务8: 创建测试套件 (AC: 1-5)
- [ ] 8.1: 创建 `src/tests/agentic_rag/test_quality_checker.py`
- [ ] 8.2: 测试QualityChecker分级逻辑
- [ ] 8.3: 测试QueryRewriter重写效果
- [ ] 8.4: 测试循环次数限制
- [ ] 8.5: 测试超时退出机制

---

## Dev Notes

### Dependencies Verification

**前置依赖验证** (必须先完成):
- [ ] **Story 12.7已完成**: 融合算法可用
- [ ] **Story 12.8已完成**: Reranking节点可用
- [ ] CanvasRAGState schema包含quality相关字段
- [ ] StateGraph基础结构已构建

**技术栈依赖**:
- [ ] langgraph >= 0.2.55
- [ ] langchain-openai (gpt-3.5-turbo调用)
- [ ] pytest-asyncio (异步测试)
- [ ] numpy (质量分数计算)

### SDD规范参考

**LangGraph Conditional Edges** [Source: LangGraph Skill - Conditional edges]:

```python
# ✅ Verified from LangGraph Skill - Conditional edges for dynamic routing
builder.add_conditional_edges(
    "grade_documents",
    grade_documents_route,  # 条件函数
    {
        "rewrite": "rewrite",
        "generate": "generate"
    }
)
```

**Quality Checker Pattern** [Source: LANGGRAPH-MEMORY-INTEGRATION-DESIGN.md]:

```python
# ✅ Verified from Architecture doc - 4维度加权评分
quality_score = (
    weak_point_coverage * 0.4 +    # 薄弱点覆盖率
    avg_relevance * 0.3 +          # 平均相关性
    source_diversity * 0.2 +       # 数据源多样性
    doc_count_score * 0.1          # 文档数量
)
```

**Loop Prevention** [Source: LangGraph Skill]:

```python
# ✅ Verified from LangGraph Skill - timeout policies to prevent infinite loops
# 最多2次重写 (使用Schema定义的retry_count字段)
if retry_count >= 2:
    return "generate"  # 强制退出循环
```

### ADR决策关联

**LANGGRAPH-MEMORY-INTEGRATION-DESIGN.md** [Source: docs/architecture/]:
- **Section 10.5.2**: grade_documents_node实现
- **Section 10.5.2**: rewrite_query_node实现
- **Section 10.5.3**: grade_documents_route条件路由

**ADR-002: LangGraph Multi-Agent System** [Source: docs/architecture/decisions/0002-langgraph-agents.md]:
- **决策**: 使用LangGraph作为多Agent编排框架
- **循环支持**: 原生支持条件边循环
- **本Story关系**: 直接使用LangGraph循环机制

### Testing Standards

**测试文件位置**: `src/tests/agentic_rag/`

**测试类型**:
- 单元测试 (QualityChecker, QueryRewriter)
- 集成测试 (循环次数验证)
- 性能测试 (质量提升度量)
- 超时测试 (10秒限制)

**Mock策略**:
- gpt-3.5-turbo使用Mock (避免API成本)
- 检索结果使用fixture数据

**覆盖率目标**: ≥80%

### Performance Benchmarks

**延迟预算** (from Epic 12 PRD):

| 操作 | 预期延迟 |
|------|----------|
| 质量评估 | < 10ms |
| Query重写 (LLM) | < 2秒 |
| 单次循环 | < 3秒 |
| **总延迟 (含2次重写)** | **< 10秒** |

**质量提升目标**:

| 指标 | 目标 |
|------|------|
| Rewrite后avg_score提升 | ≥ +0.15 |
| Low→Medium/High转换率 | ≥ 60% |

### Related Documentation

**Epic和Story文档**:
- [EPIC-12-STORY-MAP.md](../epics/EPIC-12-STORY-MAP.md) - Epic 12完整Story Map
- [12.7.story.md](./12.7.story.md) - 融合算法实现 (前置依赖)
- [12.8.story.md](./12.8.story.md) - Reranking策略 (前置依赖)
- [12.10.story.md](./12.10.story.md) - 检验白板集成 (后续Story)

**架构文档** [Source: docs/architecture/]:
- [LANGGRAPH-MEMORY-INTEGRATION-DESIGN.md](../architecture/LANGGRAPH-MEMORY-INTEGRATION-DESIGN.md) - 质量控制节点实现
- [0002-langgraph-agents.md](../architecture/decisions/0002-langgraph-agents.md) - LangGraph ADR

**外部文档**:
- LangGraph Skill: `.claude/skills/langgraph/SKILL.md`

### Conflict Resolutions (Step 8d)

| # | 冲突 | 决策 | 行动 | 解决人 | 时间戳 |
|---|------|------|------|--------|--------|
| 1 | Schema vs Story: quality字段缺失 | C (同时修改两者) | Schema添加 `quality_grade`, `quality_issues`, `original_queries`；Story将 `rewrite_count`→`retry_count` | 用户 | 2025-11-28 |
| 2 | `retrieved_documents` 命名不一致 | A (使用Schema命名) | Story代码使用 `fused_results` 替代 `retrieved_documents` | 用户 | 2025-11-28 |

**Schema更新记录**:
- 文件: `specs/data/langgraph-state.schema.json`
- 新增字段: `quality_grade`, `quality_issues`, `original_queries`
- 更新字段: `retry_count` 描述更新为同时服务于Story 12.5和12.9

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-28 | 1.0 | 初始创建 - SM Agent *draft | Bob (SM Agent) |
| 2025-11-28 | 1.1 | PO验证: 修复Schema字段命名 (rewrite_count→retry_count, retrieved_documents→fused_results)，添加冲突解决记录 | Sarah (PO Agent) |

---

## Dev Agent Record

### Agent Model Used
*待填写*

### Debug Log References
*待填写*

### Completion Notes List
*待填写*

### File List
*待填写*

---

## QA Results

*待QA Agent审查*
