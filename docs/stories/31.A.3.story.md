# Story 31.A.3: å†™å…¥å¯é æ€§å¢å¼º

## Status

Pending

---

## Story

**As a** Canvas Learning System ç”¨æˆ·,
**I want** Graphiti JSON å†™å…¥å…·æœ‰é‡è¯•æœºåˆ¶,
**so that** ç½‘ç»œæŠ–åŠ¨æˆ–ä¸´æ—¶æ•…éšœæ—¶æ•°æ®ä¸ä¼šä¸¢å¤±ã€‚

---

## å…ƒæ•°æ®

| å±æ€§ | å€¼ |
|------|------|
| Story ID | 31.A.3 |
| EPIC | 31.A - è®°å¿†ç³»ç»Ÿç®¡é“ä¿®å¤ |
| ä¼˜å…ˆçº§ | P1 - High |
| ä¿®å¤æ–­ç‚¹ | æ–­ç‚¹4: Graphiti å†™å…¥ fire-and-forget æ— é‡è¯• |

---

## 1. é—®é¢˜æè¿°

### 1.1 å½“å‰çŠ¶æ€

`memory_service.py:302-312` ä½¿ç”¨ `asyncio.create_task()` fire-and-forget æ¨¡å¼è°ƒç”¨ `_write_to_graphiti_json()`ï¼š

```python
# å½“å‰ä»£ç  - memory_service.py:302-312
# [Source: backend/app/services/memory_service.py:302-312]
if getattr(settings, "ENABLE_GRAPHITI_JSON_DUAL_WRITE", False):
    asyncio.create_task(
        self._write_to_graphiti_json(
            episode_id=episode_id,
            canvas_name=canvas_path,
            node_id=node_id,
            concept=concept,
            score=float(score) if score is not None else None,
            agent_feedback=agent_type,
        )
    )
# âŒ æ— é‡è¯•æœºåˆ¶
# âŒ è¶…æ—¶åé™é»˜å¤±è´¥ï¼ˆä»… warning æ—¥å¿—ï¼‰
# âŒ æ— æ³•è¿½è¸ªå†™å…¥æˆåŠŸç‡
```

### 1.2 å½±å“

- ç½‘ç»œæŠ–åŠ¨æ—¶æ•°æ®å¯èƒ½ä¸¢å¤±
- 500ms è¶…æ—¶åé™é»˜å¤±è´¥ï¼Œæ— é‡è¯•
- æ— æ³•çŸ¥é“å“ªäº›æ•°æ®æˆåŠŸå†™å…¥ Graphiti JSON
- ä¸ Neo4j åŒæ­¥å†™å…¥çš„å¯é æ€§ä¸ä¸€è‡´

### 1.3 å¯¹æ¯”ï¼šæœŸæœ›è¡Œä¸º

```python
# æœŸæœ›è¡Œä¸º - å¸¦é‡è¯•çš„å†™å…¥
async def _write_to_graphiti_json_with_retry(self, ..., max_retries: int = 2) -> bool:
    for attempt in range(max_retries + 1):
        try:
            await asyncio.wait_for(
                self._learning_memory.add_learning_episode(LearningMemory(...)),
                timeout=GRAPHITI_JSON_WRITE_TIMEOUT,
            )
            return True
        except (asyncio.TimeoutError, Exception) as e:
            if attempt < max_retries:
                await asyncio.sleep(0.1 * (2 ** attempt))  # æŒ‡æ•°é€€é¿
                continue
            logger.warning(f"Graphiti write failed after {max_retries + 1} attempts: {e}")
            return False
```

---

## 2. Acceptance Criteria

### AC-31.A.3.1: æ·»åŠ é‡è¯•æœºåˆ¶

**æ–‡ä»¶**: `backend/app/services/memory_service.py`
**æ’å…¥ä½ç½®**: åœ¨ `_write_to_graphiti_json()` æ–¹æ³•ä¹‹åï¼ˆçº¦ L212ï¼‰

**ä¿®æ”¹å†…å®¹**:
```python
async def _write_to_graphiti_json_with_retry(
    self,
    episode_id: str,
    canvas_name: str,
    node_id: str,
    concept: str,
    score: Optional[float] = None,
    agent_feedback: Optional[str] = None,
    user_understanding: Optional[str] = None,
    max_retries: int = 2
) -> bool:
    """
    å¸¦é‡è¯•çš„ Graphiti JSON å†™å…¥ã€‚

    Story 31.A.3: å¢å¼º _write_to_graphiti_json çš„å¯é æ€§
    - æ·»åŠ æŒ‡æ•°é€€é¿é‡è¯•æœºåˆ¶
    - æœ€å¤šé‡è¯• 2 æ¬¡ï¼ˆå…± 3 æ¬¡å°è¯•ï¼‰
    - è®°å½•é‡è¯•å’Œå¤±è´¥æ—¥å¿—

    Args:
        episode_id: å”¯ä¸€ episode æ ‡è¯†ï¼ˆç”¨äºæ—¥å¿—ï¼‰
        canvas_name: Canvas æ–‡ä»¶è·¯å¾„/åç§°
        node_id: æ­£åœ¨å­¦ä¹ çš„èŠ‚ç‚¹ ID
        concept: æ­£åœ¨å­¦ä¹ çš„æ¦‚å¿µ
        score: å­¦ä¹ å¾—åˆ† (0-100, optional)
        agent_feedback: Agent åé¦ˆ/å“åº” (optional)
        user_understanding: ç”¨æˆ·ç†è§£æ–‡æœ¬ (optional)
        max_retries: æœ€å¤§é‡è¯•æ¬¡æ•° (default: 2)

    Returns:
        True if successful, False otherwise

    [Source: docs/stories/31.A.3.story.md#AC-31.A.3.1]
    """
    for attempt in range(max_retries + 1):
        try:
            await asyncio.wait_for(
                self._learning_memory.add_learning_episode(
                    LearningMemory(
                        canvas_name=canvas_name,
                        node_id=node_id,
                        concept=concept,
                        user_understanding=user_understanding,
                        score=score,
                        agent_feedback=agent_feedback,
                        timestamp=datetime.now().isoformat(),
                    )
                ),
                timeout=GRAPHITI_JSON_WRITE_TIMEOUT,
            )
            if attempt > 0:
                logger.info(f"Graphiti write succeeded after {attempt + 1} attempts: {episode_id}")
            else:
                logger.debug(f"Graphiti JSON dual-write succeeded: {episode_id}")
            return True
        except asyncio.TimeoutError:
            if attempt < max_retries:
                delay = 0.1 * (2 ** attempt)  # æŒ‡æ•°é€€é¿: 0.1s, 0.2s, 0.4s
                logger.debug(f"Graphiti write timeout, retrying in {delay}s (attempt {attempt + 1}): {episode_id}")
                await asyncio.sleep(delay)
                continue
            logger.warning(f"Graphiti write failed after {max_retries + 1} attempts (timeout): {episode_id}")
            return False
        except Exception as e:
            if attempt < max_retries:
                delay = 0.1 * (2 ** attempt)
                logger.debug(f"Graphiti write error: {e}, retrying in {delay}s (attempt {attempt + 1}): {episode_id}")
                await asyncio.sleep(delay)
                continue
            logger.warning(f"Graphiti write failed after {max_retries + 1} attempts: {episode_id} - {e}")
            return False
```

**éªŒæ”¶æ¡ä»¶**:
- [ ] æ–°å¢ `_write_to_graphiti_json_with_retry()` æ–¹æ³•
- [ ] æ–¹æ³•ç­¾åä¸ç°æœ‰ `_write_to_graphiti_json()` å‚æ•°ä¸€è‡´ï¼ˆå¢åŠ  max_retriesï¼‰
- [ ] é»˜è®¤é‡è¯• 2 æ¬¡ï¼ˆå…± 3 æ¬¡å°è¯•ï¼‰
- [ ] ä½¿ç”¨æŒ‡æ•°é€€é¿ç­–ç•¥ï¼ˆ0.1s, 0.2s, 0.4sï¼‰
- [ ] é‡è¯•åæˆåŠŸè®°å½• info æ—¥å¿—
- [ ] æœ€ç»ˆå¤±è´¥è®°å½• warning æ—¥å¿—

---

### AC-31.A.3.2: æ›¿æ¢ fire-and-forget è°ƒç”¨

**æ–‡ä»¶**: `backend/app/services/memory_service.py`
**è°ƒç”¨ä½ç½® 1**: L302-312 (`record_learning_event()` æ–¹æ³•)
**è°ƒç”¨ä½ç½® 2**: L899-907 (`record_temporal_event()` æ–¹æ³•)

**ä¿®æ”¹å†…å®¹**:
```python
# æ›¿æ¢å‰ (memory_service.py:302-312)
if getattr(settings, "ENABLE_GRAPHITI_JSON_DUAL_WRITE", False):
    asyncio.create_task(
        self._write_to_graphiti_json(
            episode_id=episode_id,
            canvas_name=canvas_path,
            node_id=node_id,
            concept=concept,
            score=float(score) if score is not None else None,
            agent_feedback=agent_type,
        )
    )

# æ›¿æ¢å
if getattr(settings, "ENABLE_GRAPHITI_JSON_DUAL_WRITE", False):
    asyncio.create_task(
        self._write_to_graphiti_json_with_retry(
            episode_id=episode_id,
            canvas_name=canvas_path,
            node_id=node_id,
            concept=concept,
            score=float(score) if score is not None else None,
            agent_feedback=agent_type,
        )
    )
```

**éªŒæ”¶æ¡ä»¶**:
- [ ] `record_learning_event()` ä¸­çš„è°ƒç”¨æ”¹ç”¨æ–°æ–¹æ³• (L302-312)
- [ ] `record_temporal_event()` ä¸­çš„è°ƒç”¨æ”¹ç”¨æ–°æ–¹æ³• (L899-907)
- [ ] ä¿æŒå¼‚æ­¥éé˜»å¡ï¼ˆä»ä½¿ç”¨ `asyncio.create_task()`ï¼‰
- [ ] ä¸å½±å“ä¸»æµç¨‹å“åº”æ—¶é—´

---

### AC-31.A.3.3: å†™å…¥ç»“æœè¿½è¸ªï¼ˆå¯é€‰å¢å¼ºï¼‰

> âš ï¸ **æ³¨æ„**: `/api/v1/memory/stats` ç«¯ç‚¹å½“å‰ä¸å­˜åœ¨ã€‚
> å¯ä½¿ç”¨ç°æœ‰ `/api/v1/memory/health` ç«¯ç‚¹ä½œä¸ºæ›¿ä»£ã€‚
> [Source: backend/app/api/v1/endpoints/memory.py:340-369]

**éªŒæ”¶æ¡ä»¶**:
- [ ] (å¯é€‰) æ·»åŠ å†™å…¥è®¡æ•°å™¨ï¼ˆæˆåŠŸ/å¤±è´¥ï¼‰åˆ° `MemoryService` å®ä¾‹
- [ ] (å¯é€‰) é€šè¿‡ `/api/v1/memory/health` æˆ–æ–°å¢ `/api/v1/memory/stats` æš´éœ²ç»Ÿè®¡
- [ ] (å¯é€‰) æ—¥å¿—åŒ…å« episode_id ä¾¿äºè¿½è¸ªï¼ˆå·²å®ç°ï¼‰

---

### AC-31.A.3.4: å•å…ƒæµ‹è¯•è¦†ç›–

**æ–‡ä»¶**: `backend/tests/unit/test_memory_service_write_retry.py` (æ–°å»º)

**éªŒæ”¶æ¡ä»¶**:
- [ ] æµ‹è¯•é¦–æ¬¡æˆåŠŸåœºæ™¯
- [ ] æµ‹è¯•é‡è¯•åæˆåŠŸåœºæ™¯
- [ ] æµ‹è¯•å…¨éƒ¨é‡è¯•å¤±è´¥åœºæ™¯
- [ ] æµ‹è¯•å¼‚å¸¸ï¼ˆéè¶…æ—¶ï¼‰è§¦å‘é‡è¯•åœºæ™¯
- [ ] æµ‹è¯•æŒ‡æ•°é€€é¿æ—¶é—´
- [ ] æµ‹è¯•æ—¥å¿—è®°å½•

---

## 3. Tasks / Subtasks

- [ ] **Task 1**: å®ç° `_write_to_graphiti_json_with_retry()` æ–¹æ³• (AC-31.A.3.1)
  - [ ] åœ¨ `memory_service.py` L212 åæ·»åŠ æ–°æ–¹æ³•
  - [ ] å¤ç”¨ `LearningMemory` dataclass å‚æ•°
  - [ ] å®ç°æŒ‡æ•°é€€é¿é‡è¯•é€»è¾‘
  - [ ] æ·»åŠ æ—¥å¿—è®°å½•

- [ ] **Task 2**: æ›¿æ¢ç°æœ‰è°ƒç”¨ç‚¹ (AC-31.A.3.2)
  - [ ] ä¿®æ”¹ `record_learning_event()` ä¸­çš„è°ƒç”¨ (L302-312)
  - [ ] ä¿®æ”¹ `record_temporal_event()` ä¸­çš„è°ƒç”¨ (L899-907)
  - [ ] éªŒè¯ä¸å½±å“ä¸»æµç¨‹å“åº”æ—¶é—´

- [ ] **Task 3**: ç¼–å†™å•å…ƒæµ‹è¯• (AC-31.A.3.4)
  - [ ] åˆ›å»º `test_memory_service_write_retry.py`
  - [ ] **ä½¿ç”¨æ¨¡å—çº§ fixtureï¼ˆä¸åœ¨ç±»å†…å®šä¹‰ï¼‰**
  - [ ] è¦†ç›–æ‰€æœ‰æµ‹è¯•åœºæ™¯

- [ ] **Task 4**: éªŒè¯ç°æœ‰æµ‹è¯•ä¸å›å½’
  - [ ] è¿è¡Œ `pytest backend/tests/unit/test_graphiti_json_dual_write.py`
  - [ ] ç¡®ä¿æ‰€æœ‰ç°æœ‰æµ‹è¯•é€šè¿‡

---

## 4. Dev Notes

### 4.1 SDD è§„èŒƒå‚è€ƒï¼ˆå®é™…ä»£ç éªŒè¯ï¼‰

> ä»¥ä¸‹æ‰€æœ‰ä»£ç ä½ç½®å·²é€šè¿‡ Explore agent äº 2026-02-05 éªŒè¯

**_write_to_graphiti_json() æ–¹æ³•** [Source: `backend/app/services/memory_service.py:153-211`]:
```python
async def _write_to_graphiti_json(
    self,
    episode_id: str,
    canvas_name: str,
    node_id: str,
    concept: str,
    score: Optional[float] = None,
    agent_feedback: Optional[str] = None,
    user_understanding: Optional[str] = None,
) -> None:
    # ... å®ç° ...
```

**LearningMemory Dataclass** [Source: `backend/app/clients/graphiti_client.py:594-615`]:
```python
@dataclass
class LearningMemory:
    canvas_name: str                          # å¿…éœ€
    node_id: str                              # å¿…éœ€
    concept: str                              # å¿…éœ€
    user_understanding: Optional[str] = None  # å¯é€‰
    score: Optional[float] = None             # å¯é€‰
    agent_feedback: Optional[str] = None      # å¯é€‰
    timestamp: Optional[str] = None           # å¯é€‰

    @property
    def memory_key(self) -> str:
        """Unique key: canvas:node:timestamp"""
        ts = self.timestamp or datetime.now().isoformat()
        return f"{self.canvas_name}:{self.node_id}:{ts}"
```

**add_learning_episode() æ–¹æ³•** [Source: `backend/app/clients/graphiti_client.py:695-732`]:
```python
async def add_learning_episode(self, memory: LearningMemory) -> bool:
    # è¿”å›: True if successful, False on error
```

**å¸¸é‡å®šä¹‰** [Source: `backend/app/services/memory_service.py:69`]:
```python
GRAPHITI_JSON_WRITE_TIMEOUT = 0.5  # 500ms
```

**è°ƒç”¨ä½ç½®ï¼ˆå·²éªŒè¯ï¼‰**:
| ä½ç½® | æ–¹æ³• | å®é™…è¡Œå· |
|------|------|----------|
| ç¬¬1å¤„ | `record_learning_event()` | L302-312 |
| ç¬¬2å¤„ | `record_temporal_event()` | L899-907 |

**MemoryService æ„é€ å‡½æ•°** [Source: `backend/app/services/memory_service.py:118-136`]:
```python
def __init__(
    self,
    neo4j_client: Optional[Neo4jClient] = None,
    learning_memory_client: Optional[LearningMemoryClient] = None,
):
```

---

### 4.2 ADR å†³ç­–å…³è”

| ADR ç¼–å· | å†³ç­–æ ‡é¢˜ | å¯¹ Story çš„å½±å“ |
|----------|----------|----------------|
| **ADR-009** | é”™è¯¯å¤„ç†ä¸é‡è¯•ç­–ç•¥ | **å…³é”®å‚è€ƒ** - å®šä¹‰äº†é‡è¯•å’Œç†”æ–­ç­–ç•¥ |

**ADR-009 å…³é”®å†³ç­–æ‘˜è¦** [Source: `docs/architecture/decisions/ADR-009-ERROR-HANDLING-RETRY-STRATEGY.md`]:

| ç»„ä»¶ | ADR-009 å†³ç­– | Story 31.A.3 å®ç° | å·®å¼‚è¯´æ˜ |
|------|-------------|------------------|----------|
| é‡è¯•åº“ | æ¨è tenacity | è‡ªå®šä¹‰å¼‚æ­¥å®ç° | âš ï¸ è§ä¸‹æ–¹è¯´æ˜ |
| ç†”æ–­å™¨ | è½»é‡çº§è‡ªå®ç° (5æ¬¡/60s) | æœªå®ç° | âš ï¸ è§ä¸‹æ–¹è¯´æ˜ |
| é‡è¯•æ¬¡æ•° | Embedding: 2æ¬¡ | 2æ¬¡ (å…±3æ¬¡å°è¯•) | âœ… ä¸€è‡´ |
| é€€é¿ç­–ç•¥ | æŒ‡æ•°é€€é¿+æŠ–åŠ¨ | æŒ‡æ•°é€€é¿ (0.1, 0.2, 0.4s) | âœ… åŸºæœ¬ä¸€è‡´ |

**ä¸ºä½•ä¸ä½¿ç”¨ tenacityï¼ˆè®¾è®¡å†³ç­–è¯´æ˜ï¼‰**:

1. **Fire-and-forget åœºæ™¯ç‰¹æ®Šæ€§**ï¼šGraphiti å†™å…¥åœ¨ `asyncio.create_task()` ä¸­æ‰§è¡Œï¼Œtenacity è£…é¥°å™¨ä¸é€‚åˆè¿™ç§ fire-and-forget æ¨¡å¼
2. **è½»é‡çº§éœ€æ±‚**ï¼šä»…éœ€ç®€å•é‡è¯•ï¼Œä¸éœ€è¦ tenacity çš„å…¨éƒ¨ç‰¹æ€§
3. **è¶…æ—¶æ§åˆ¶**ï¼šéœ€è¦é…åˆ `asyncio.wait_for()` çš„ç²¾ç¡®è¶…æ—¶æ§åˆ¶
4. **å¯å®¹å¿å¤±è´¥**ï¼šGraphiti å†™å…¥å¤±è´¥ä¸å½±å“ä¸»æµç¨‹ï¼ˆæ•°æ®å·²åŒæ­¥åˆ° Neo4jï¼‰

**ä¸ºä½•ä¸æ·»åŠ ç†”æ–­å™¨ï¼ˆè®¾è®¡å†³ç­–è¯´æ˜ï¼‰**:

1. **ä½é¢‘ç‡è°ƒç”¨**ï¼šGraphiti å†™å…¥éšç”¨æˆ·å­¦ä¹ äº‹ä»¶è§¦å‘ï¼Œä¸æ˜¯é«˜é¢‘ API è°ƒç”¨
2. **å¯å®¹å¿å¤±è´¥**ï¼šå†™å…¥å¤±è´¥ä»…å½±å“ JSON å‰¯æœ¬ï¼ŒNeo4j ä¸»å­˜å‚¨ä¸å—å½±å“
3. **é¿å…å¤æ‚åº¦**ï¼šç†”æ–­å™¨çŠ¶æ€ç®¡ç†å¢åŠ ä»£ç å¤æ‚åº¦ï¼Œæ”¶ç›Šæœ‰é™
4. **æœªæ¥å¯æ‰©å±•**ï¼šå¦‚éœ€ç†”æ–­å™¨ï¼Œå¯åœ¨åç»­ Story ä¸­æ·»åŠ 

**å…³é”®çº¦æŸï¼ˆæ¥è‡ª ADR-009ï¼‰**:
- å†™å…¥æ“ä½œå¿…é¡»ä¿æŒéé˜»å¡ï¼ˆä½¿ç”¨ `asyncio.create_task()`ï¼‰
- é‡è¯•æ€»è€—æ—¶ä¸åº”è¶…è¿‡ 2 ç§’ï¼ˆå½“å‰æœ€åæƒ…å†µ 1.8sï¼‰âœ…
- é‡è¯•å¤±è´¥ä»…è®°å½• warningï¼Œä¸æŠ›å‡ºå¼‚å¸¸ âœ…

---

### 4.3 æµ‹è¯•æ ‡å‡†ï¼ˆå®é™…é¡¹ç›®æ¨¡å¼ï¼‰

> ä»¥ä¸‹æµ‹è¯•æ¨¡å¼å·²é€šè¿‡ Explore agent ä» `test_graphiti_json_dual_write.py` éªŒè¯

**æµ‹è¯•æ–‡ä»¶ä½ç½®**: `backend/tests/unit/`

**å‚è€ƒæµ‹è¯•**: `backend/tests/unit/test_graphiti_json_dual_write.py`

**ğŸ”´ å…³é”®ï¼šFixture å¿…é¡»åœ¨æ¨¡å—çº§åˆ«å®šä¹‰** [Source: `backend/tests/unit/test_graphiti_json_dual_write.py:30-56`]:
```python
# âœ… æ­£ç¡®ï¼šæ¨¡å—çº§åˆ«å®šä¹‰ fixture
import asyncio
import pytest
from unittest.mock import AsyncMock, patch

from app.services.memory_service import MemoryService, GRAPHITI_JSON_WRITE_TIMEOUT
from app.clients.graphiti_client import LearningMemory


@pytest.fixture
def mock_neo4j_client():
    """Create a mock Neo4jClient."""
    client = AsyncMock()
    client.initialize = AsyncMock(return_value=True)
    client.stats = {"connected": True, "mode": "NEO4J", "initialized": True}
    client.create_learning_relationship = AsyncMock(return_value=True)
    client.get_concept_history = AsyncMock(return_value=[])
    return client


@pytest.fixture
def mock_learning_memory_client():
    """Create a mock LearningMemoryClient."""
    client = AsyncMock()
    client.initialize = AsyncMock(return_value=True)
    client.add_learning_episode = AsyncMock(return_value=True)
    return client


@pytest.fixture
def memory_service(mock_neo4j_client, mock_learning_memory_client):
    """Create MemoryService with mocked dependencies."""
    return MemoryService(
        neo4j_client=mock_neo4j_client,
        learning_memory_client=mock_learning_memory_client,
    )


# âŒ é”™è¯¯ï¼šä¸è¦åœ¨ç±»å†…å®šä¹‰ fixture
class TestWriteRetry:
    # @pytest.fixture  # âŒ ä¸è¦è¿™æ ·åš
    # def memory_service(self): ...
    pass
```

**å¼‚æ­¥æµ‹è¯•æ¨¡å¼** [Source: `backend/tests/unit/test_graphiti_json_dual_write.py:62-95`]:
```python
class TestWriteToGraphitiJsonWithRetry:
    """Tests for _write_to_graphiti_json_with_retry method."""

    @pytest.mark.asyncio
    async def test_write_succeeds_first_attempt(
        self, memory_service, mock_learning_memory_client
    ):
        """AC-31.A.3.4: æµ‹è¯•é¦–æ¬¡å†™å…¥æˆåŠŸ"""
        await memory_service.initialize()

        result = await memory_service._write_to_graphiti_json_with_retry(
            episode_id="test-episode-1",
            canvas_name="test.canvas",
            node_id="node-123",
            concept="æµ‹è¯•æ¦‚å¿µ",
        )

        assert result is True
        assert mock_learning_memory_client.add_learning_episode.call_count == 1
```

**é‡è¯•æ¨¡æ‹Ÿæ¨¡å¼ï¼ˆside_effectï¼‰**:
```python
# æ–¹å¼ 1ï¼šåˆ—è¡¨å½¢å¼ï¼ˆç¬¬ä¸€æ¬¡å¤±è´¥ï¼Œç¬¬äºŒæ¬¡æˆåŠŸï¼‰
mock_learning_memory_client.add_learning_episode = AsyncMock(
    side_effect=[asyncio.TimeoutError(), True]
)

# æ–¹å¼ 2ï¼šå•ä¸ªå¼‚å¸¸ï¼ˆæ‰€æœ‰è°ƒç”¨éƒ½å¤±è´¥ï¼‰
mock_learning_memory_client.add_learning_episode = AsyncMock(
    side_effect=asyncio.TimeoutError()
)
```

**æ—¥å¿—éªŒè¯æ¨¡å¼** [Source: `backend/tests/unit/test_graphiti_json_dual_write.py:279-305`]:
```python
with patch("app.services.memory_service.logger") as mock_logger:
    result = await memory_service._write_to_graphiti_json_with_retry(...)

mock_logger.debug.assert_called()
mock_logger.warning.assert_called()
log_call_args = str(mock_logger.warning.call_args)
assert "episode_id" in log_call_args
```

**Fire-and-forget ç­‰å¾…æ—¶é—´**:
```python
# ç­‰å¾… fire-and-forget ä»»åŠ¡å®Œæˆ
await asyncio.sleep(0.2)  # å»ºè®® 0.2-0.3sï¼Œä¸è¦å¤ªçŸ­
```

---

### 4.4 ç›¸å…³ä»£ç ä½ç½®ï¼ˆå·²éªŒè¯ï¼‰

| ç»„ä»¶ | æ–‡ä»¶ | è¡Œå· | éªŒè¯çŠ¶æ€ |
|------|------|------|---------|
| `_write_to_graphiti_json()` | `memory_service.py` | 153-211 | âœ… |
| è°ƒç”¨ä½ç½® 1 | `memory_service.py` | 302-312 | âœ… |
| è°ƒç”¨ä½ç½® 2 | `memory_service.py` | 899-907 | âœ… |
| `GRAPHITI_JSON_WRITE_TIMEOUT` | `memory_service.py` | 69 | âœ… |
| `LearningMemory` dataclass | `graphiti_client.py` | 594-615 | âœ… |
| `add_learning_episode()` | `graphiti_client.py` | 695-732 | âœ… |
| ç°æœ‰æµ‹è¯• | `test_graphiti_json_dual_write.py` | å…¨æ–‡ä»¶ | âœ… |

---

## 5. æµ‹è¯•è®¡åˆ’

### 5.1 å•å…ƒæµ‹è¯•

```python
# backend/tests/unit/test_memory_service_write_retry.py
"""
Unit tests for Graphiti JSON write retry functionality.

Story 31.A.3: å†™å…¥å¯é æ€§å¢å¼º
- AC-31.A.3.1: æ·»åŠ é‡è¯•æœºåˆ¶
- AC-31.A.3.4: å•å…ƒæµ‹è¯•è¦†ç›–

[Source: docs/stories/31.A.3.story.md#Testing]
"""
import asyncio
import pytest
from unittest.mock import AsyncMock, patch

from app.services.memory_service import MemoryService, GRAPHITI_JSON_WRITE_TIMEOUT
from app.clients.graphiti_client import LearningMemory


# âœ… æ¨¡å—çº§åˆ« fixtureï¼ˆä¸åœ¨ç±»å†…å®šä¹‰ï¼‰

@pytest.fixture
def mock_neo4j_client():
    """Create a mock Neo4jClient."""
    client = AsyncMock()
    client.initialize = AsyncMock(return_value=True)
    client.stats = {"connected": True, "mode": "NEO4J", "initialized": True}
    client.create_learning_relationship = AsyncMock(return_value=True)
    client.get_concept_history = AsyncMock(return_value=[])
    return client


@pytest.fixture
def mock_learning_memory_client():
    """Create a mock LearningMemoryClient."""
    client = AsyncMock()
    client.initialize = AsyncMock(return_value=True)
    client.add_learning_episode = AsyncMock(return_value=True)
    return client


@pytest.fixture
def memory_service(mock_neo4j_client, mock_learning_memory_client):
    """Create MemoryService with mocked dependencies."""
    return MemoryService(
        neo4j_client=mock_neo4j_client,
        learning_memory_client=mock_learning_memory_client,
    )


class TestWriteToGraphitiJsonWithRetry:
    """Tests for _write_to_graphiti_json_with_retry method."""

    @pytest.mark.asyncio
    async def test_write_succeeds_first_attempt(
        self, memory_service, mock_learning_memory_client
    ):
        """AC-31.A.3.4: æµ‹è¯•é¦–æ¬¡å†™å…¥æˆåŠŸ"""
        await memory_service.initialize()

        result = await memory_service._write_to_graphiti_json_with_retry(
            episode_id="test-episode-1",
            canvas_name="test.canvas",
            node_id="node-123",
            concept="æµ‹è¯•æ¦‚å¿µ",
        )

        assert result is True
        assert mock_learning_memory_client.add_learning_episode.call_count == 1

    @pytest.mark.asyncio
    async def test_write_succeeds_after_retry(
        self, memory_service, mock_learning_memory_client
    ):
        """AC-31.A.3.4: æµ‹è¯•é‡è¯•åæˆåŠŸ"""
        await memory_service.initialize()

        # ç¬¬ä¸€æ¬¡è¶…æ—¶ï¼Œç¬¬äºŒæ¬¡æˆåŠŸ
        mock_learning_memory_client.add_learning_episode = AsyncMock(
            side_effect=[asyncio.TimeoutError(), True]
        )

        result = await memory_service._write_to_graphiti_json_with_retry(
            episode_id="test-episode-2",
            canvas_name="test.canvas",
            node_id="node-123",
            concept="æµ‹è¯•æ¦‚å¿µ",
        )

        assert result is True
        assert mock_learning_memory_client.add_learning_episode.call_count == 2

    @pytest.mark.asyncio
    async def test_write_fails_after_all_retries(
        self, memory_service, mock_learning_memory_client
    ):
        """AC-31.A.3.4: æµ‹è¯•å…¨éƒ¨é‡è¯•å¤±è´¥"""
        await memory_service.initialize()

        mock_learning_memory_client.add_learning_episode = AsyncMock(
            side_effect=asyncio.TimeoutError()
        )

        result = await memory_service._write_to_graphiti_json_with_retry(
            episode_id="test-episode-3",
            canvas_name="test.canvas",
            node_id="node-123",
            concept="æµ‹è¯•æ¦‚å¿µ",
            max_retries=2,
        )

        assert result is False
        assert mock_learning_memory_client.add_learning_episode.call_count == 3

    @pytest.mark.asyncio
    async def test_exception_triggers_retry(
        self, memory_service, mock_learning_memory_client
    ):
        """AC-31.A.3.4: æµ‹è¯•å¼‚å¸¸è§¦å‘é‡è¯•"""
        await memory_service.initialize()

        # ç¬¬ä¸€æ¬¡å¼‚å¸¸ï¼Œç¬¬äºŒæ¬¡æˆåŠŸ
        mock_learning_memory_client.add_learning_episode = AsyncMock(
            side_effect=[Exception("Network error"), True]
        )

        result = await memory_service._write_to_graphiti_json_with_retry(
            episode_id="test-episode-4",
            canvas_name="test.canvas",
            node_id="node-123",
            concept="æµ‹è¯•æ¦‚å¿µ",
        )

        assert result is True
        assert mock_learning_memory_client.add_learning_episode.call_count == 2

    @pytest.mark.asyncio
    async def test_retry_success_logging(
        self, memory_service, mock_learning_memory_client
    ):
        """AC-31.A.3.4: æµ‹è¯•é‡è¯•æˆåŠŸåè®°å½• info æ—¥å¿—"""
        await memory_service.initialize()

        mock_learning_memory_client.add_learning_episode = AsyncMock(
            side_effect=[asyncio.TimeoutError(), True]
        )

        with patch("app.services.memory_service.logger") as mock_logger:
            result = await memory_service._write_to_graphiti_json_with_retry(
                episode_id="test-episode-5",
                canvas_name="test.canvas",
                node_id="node-123",
                concept="æµ‹è¯•æ¦‚å¿µ",
            )

        assert result is True
        # éªŒè¯é‡è¯•æ—¥å¿— (debug)
        mock_logger.debug.assert_called()
        # éªŒè¯æˆåŠŸæ—¥å¿—ï¼ˆé‡è¯•åæˆåŠŸåº”è®°å½• infoï¼‰
        mock_logger.info.assert_called()

    @pytest.mark.asyncio
    async def test_all_retries_failed_logging(
        self, memory_service, mock_learning_memory_client
    ):
        """AC-31.A.3.4: æµ‹è¯•å…¨éƒ¨é‡è¯•å¤±è´¥åè®°å½• warning æ—¥å¿—"""
        await memory_service.initialize()

        mock_learning_memory_client.add_learning_episode = AsyncMock(
            side_effect=asyncio.TimeoutError()
        )

        with patch("app.services.memory_service.logger") as mock_logger:
            result = await memory_service._write_to_graphiti_json_with_retry(
                episode_id="test-episode-timeout",
                canvas_name="test.canvas",
                node_id="node-123",
                concept="æµ‹è¯•æ¦‚å¿µ",
                max_retries=2,
            )

        assert result is False
        # éªŒè¯å¤±è´¥æ—¥å¿—ä½¿ç”¨ warning
        mock_logger.warning.assert_called()
        log_call_args = str(mock_logger.warning.call_args)
        assert "test-episode-timeout" in log_call_args
```

---

## 6. æŠ€æœ¯å®ç°

### 6.1 ä¿®æ”¹æ–‡ä»¶æ¸…å•

| æ–‡ä»¶ | ä¿®æ”¹ç±»å‹ | è¯´æ˜ |
|------|---------|------|
| `backend/app/services/memory_service.py` | ä¿®æ”¹ | æ·»åŠ é‡è¯•æ–¹æ³•ï¼Œä¿®æ”¹è°ƒç”¨ç‚¹ |
| `backend/tests/unit/test_memory_service_write_retry.py` | æ–°å»º | é‡è¯•æœºåˆ¶æµ‹è¯• |

### 6.2 é‡è¯•ç­–ç•¥å‚æ•°

| å‚æ•° | å€¼ | è¯´æ˜ | ADR-009 å¯¹æ¯” |
|------|------|------|-------------|
| max_retries | 2 | æœ€å¤šé‡è¯• 2 æ¬¡ï¼ˆå…± 3 æ¬¡å°è¯•ï¼‰ | âœ… ä¸ Embedding åœºæ™¯ä¸€è‡´ |
| base_delay | 0.1s | åŸºç¡€å»¶è¿Ÿ | âš ï¸ ADR-009 Embedding ç”¨ 2s |
| backoff_factor | 2 | æŒ‡æ•°é€€é¿å› å­ | âœ… ä¸€è‡´ |
| timeout | 500ms | å•æ¬¡å°è¯•è¶…æ—¶ | N/A (Graphiti ç‰¹æœ‰) |

### 6.3 æ€»æœ€å¤§è€—æ—¶

```
æœ€åæƒ…å†µ: 500ms + 100ms + 500ms + 200ms + 500ms = 1.8s
```

ç”±äºä½¿ç”¨ `asyncio.create_task()`ï¼Œä¸ä¼šé˜»å¡ä¸»æµç¨‹ã€‚

---

## 7. é£é™©ä¸ç¼“è§£

| é£é™© | ç¼“è§£æªæ–½ |
|------|---------|
| é‡è¯•å¯¼è‡´é‡å¤å†™å…¥ | Graphiti JSON ä½¿ç”¨ memory_key ä½œä¸ºå”¯ä¸€æ ‡è¯†ï¼Œæ”¯æŒå¹‚ç­‰å†™å…¥ |
| é€€é¿æ—¶é—´è¿‡é•¿ | é™åˆ¶æœ€å¤§æ€»è€—æ—¶ 1.8sï¼Œä¸”ä¸é˜»å¡ä¸»æµç¨‹ |
| create_task ç»“æœæ— æ³•æ•è· | é€šè¿‡æ—¥å¿—è®°å½•æˆåŠŸ/å¤±è´¥çŠ¶æ€ |
| æœªä½¿ç”¨ ADR-009 æ¨èçš„ tenacity | è§ Dev Notes 4.2 è®¾è®¡å†³ç­–è¯´æ˜ |
| æœªå®ç°ç†”æ–­å™¨ | è§ Dev Notes 4.2 è®¾è®¡å†³ç­–è¯´æ˜ |

---

## 8. Definition of Done

- [ ] AC-31.A.3.1: `_write_to_graphiti_json_with_retry()` æ–¹æ³•å®ç°
- [ ] AC-31.A.3.2: ä¸¤ä¸ªè°ƒç”¨ç‚¹æ›¿æ¢å®Œæˆ
- [ ] AC-31.A.3.4: æ‰€æœ‰æµ‹è¯•ç”¨ä¾‹é€šè¿‡
- [ ] ç°æœ‰æµ‹è¯• `test_graphiti_json_dual_write.py` ä¸å›å½’
- [ ] æ—¥å¿—è¾“å‡ºç¬¦åˆé¢„æœŸ
- [ ] ä»£ç  review é€šè¿‡

---

## Dev Agent Record

### Agent Model Used
_TBD_

### Debug Log References
_TBD_

### Completion Notes List
_TBD_

### File List
_TBD_

---

## QA Results

_å¾… QA Agent å¡«å†™_

---

## Change Log

| æ—¥æœŸ | ç‰ˆæœ¬ | æè¿° | ä½œè€… |
|------|------|------|------|
| 2026-02-05 | 1.0 | åˆå§‹åˆ›å»º | PM Agent |
| 2026-02-05 | 2.0 | PO éªŒè¯ä¿®å¤ï¼šä¿®æ­£ API ç­¾åã€æ·»åŠ  Dev Notesã€ç¬¦åˆ BMad æ¨¡æ¿ | PO Agent (Sarah) |
| 2026-02-05 | 3.0 | **æ·±åº¦ä»£ç è°ƒç ”ä¿®å¤**ï¼šä¿®æ­£è¡Œå· (L302-312, L899-907)ã€æ·»åŠ  ADR-009 å…³è”ã€ä¿®æ­£æµ‹è¯• fixture æ¨¡å¼ï¼ˆæ¨¡å—çº§å®šä¹‰ï¼‰ã€æ·»åŠ è®¾è®¡å†³ç­–è¯´æ˜ | PO Agent (Sarah) |
