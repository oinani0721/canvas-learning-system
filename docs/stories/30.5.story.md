# Story 30.5: Canvas CRUD Operations Memory Trigger
# Canvas CRUD操作记忆触发

**Epic**: [EPIC-30: Memory System Complete Activation](../epics/EPIC-30-MEMORY-SYSTEM-COMPLETE-ACTIVATION.md)
**Story ID**: 30.5
**Priority**: P1
**Status**: Complete
**Created**: 2026-01-16
**Completed**: 2026-01-17

---

## Story

**As a** Canvas Learning System backend developer,
**I want** automatic memory event triggers on Canvas node/edge CRUD operations,
**so that** every learning structure change is persistently stored to Neo4j, enabling accurate learning trajectory reconstruction and intelligent review suggestions.

---

## Acceptance Criteria

- **AC-30.5.1**: 创建Canvas节点时记录`node_created`事件到Neo4j
- **AC-30.5.2**: 创建边关系时记录`edge_created`事件到Neo4j
- **AC-30.5.3**: 节点内容更新时记录`node_updated`事件到Neo4j
- **AC-30.5.4**: 建立Canvas-Concept-LearningEpisode关系图（Neo4j Cypher关系）

---

## Tasks / Subtasks

- [x] **Task 0: Update temporal-event.schema.json** (前置依赖 - Schema SoT更新)
  - [x] 0.1 在`specs/data/temporal-event.schema.json`的`event_type`枚举中添加`"edge_created"`
  - [x] 0.2 验证JSON Schema有效性 (jsonschema或IDE验证)
  - [x] 0.3 提交Schema更新 (需在Task 1之前完成)
  - **来源**: PO验证报告 Step 8d冲突解决 (2026-01-16)
  - **原因**: Story AC-30.5.2要求`edge_created`事件，但Schema未包含此枚举值

- [x] **Task 1: Create Canvas Event Models** (AC-30.5.1, AC-30.5.2, AC-30.5.3)
  - [x] 1.1 Create `backend/app/models/canvas_events.py` with Pydantic models
  - [x] 1.2 Define `CanvasEventType` enum: `node_created`, `node_updated`, `edge_created`
  - [x] 1.3 Define `CanvasEvent` Pydantic model matching temporal-event.schema.json
  - [x] 1.4 Add `CanvasEventContext` dataclass for hook context (canvas_name, node_id, etc.)

- [x] **Task 2: Implement Memory Trigger Hook in CanvasService** (AC-30.5.1, AC-30.5.2, AC-30.5.3)
  - [x] 2.1 Add `_memory_client: Optional[MemoryService]` dependency injection to `__init__`
  - [x] 2.2 Create `_trigger_memory_event()` private async method with fire-and-forget pattern
  - [x] 2.3 Hook into `add_node()` → trigger `node_created` event after write
  - [x] 2.4 Hook into `update_node()` → trigger `node_updated` event after write
  - [x] 2.5 Hook into `add_edge()` → trigger `edge_created` event after write

- [x] **Task 3: Implement Async Non-Blocking Write Pattern** (AC-30.5.1, AC-30.5.2, AC-30.5.3)
  - [x] 3.1 Wrap memory write in `asyncio.create_task()` for fire-and-forget
  - [x] 3.2 Add timeout protection (500ms) using `asyncio.wait_for()`
  - [x] 3.3 Ensure CRUD operation returns immediately without waiting for memory write
  - [x] 3.4 Verify no performance degradation in CRUD response times

- [x] **Task 4: Implement Silent Degradation** (AC-30.5.1, AC-30.5.2, AC-30.5.3)
  - [x] 4.1 Wrap memory write in try/except block
  - [x] 4.2 Log error with `logger.error()` on failure (include event_type, canvas_name, error)
  - [x] 4.3 Return gracefully without raising exception to caller
  - [x] 4.4 Add skip logic when `_memory_client` is None (mock mode)

- [x] **Task 5: Create Canvas-Concept Relationship Graph** (AC-30.5.4)
  - [x] 5.1 Define Neo4j relationship types: `CONTAINS_NODE`, `HAS_EDGE`, `PART_OF_CANVAS`
  - [x] 5.2 Create Cypher templates for relationship creation
  - [x] 5.3 Implement `_create_canvas_concept_relationship()` method
  - [x] 5.4 Store node text as potential concept entity (for future linking)

- [x] **Task 6: Unit Tests**
  - [x] 6.1 Test canvas_events.py models validate correctly
  - [x] 6.2 Test _trigger_memory_event() is called after add_node()
  - [x] 6.3 Test _trigger_memory_event() is called after update_node()
  - [x] 6.4 Test _trigger_memory_event() is called after add_edge()
  - [x] 6.5 Test async write doesn't block CRUD response
  - [x] 6.6 Test silent degradation on memory write failure

- [x] **Task 7: Integration Tests**
  - [x] 7.1 Test full CRUD flow triggers memory write
  - [x] 7.2 Test memory write persists to MemoryService (mock Neo4j)
  - [x] 7.3 Test concurrent CRUD operations with memory writes
  - [x] 7.4 Test Canvas-Concept relationship is created

---

## Dev Notes

### Existing Implementation Reference

**CanvasService CRUD Methods** (canvas_service.py):

| Method | Line | Current Behavior |
|--------|------|-----------------|
| `add_node()` | 214-246 | Adds node, writes canvas, returns node |
| `update_node()` | 248-279 | Updates node, writes canvas, returns node |
| `add_edge()` | 339-367 | Adds edge, writes canvas, returns edge |

**Current Code Pattern** (add_node as example):
```python
async def add_node(self, canvas_name: str, node_data: Dict[str, Any]) -> Dict[str, Any]:
    canvas_data = await self.read_canvas(canvas_name)
    # ... node processing ...
    canvas_data["nodes"].append(new_node)
    await self.write_canvas(canvas_name, canvas_data)
    return new_node  # ← Hook AFTER this line
```

**Proposed Hook Insertion Point**:
```python
async def add_node(self, canvas_name: str, node_data: Dict[str, Any]) -> Dict[str, Any]:
    canvas_data = await self.read_canvas(canvas_name)
    # ... node processing ...
    canvas_data["nodes"].append(new_node)
    await self.write_canvas(canvas_name, canvas_data)

    # Story 30.5: Trigger memory event (fire-and-forget)
    await self._trigger_memory_event(
        event_type=CanvasEventType.NODE_CREATED,
        canvas_name=canvas_name,
        node_id=new_node["id"],
        node_data=new_node
    )

    return new_node
```

### Fire-and-Forget Pattern (from ADR-0004)

```python
async def _trigger_memory_event(
    self,
    event_type: CanvasEventType,
    canvas_name: str,
    node_id: Optional[str] = None,
    edge_id: Optional[str] = None,
    **metadata
) -> None:
    """
    Trigger memory event asynchronously (fire-and-forget).

    Story 30.5: Non-blocking memory write pattern.
    [Source: ADR-0004 - asyncio.create_task for fire-and-forget]
    """
    if self._memory_client is None:
        logger.debug("Memory client not configured, skipping event trigger")
        return

    try:
        # Fire-and-forget with timeout protection
        asyncio.create_task(
            asyncio.wait_for(
                self._write_memory_event(
                    event_type=event_type,
                    canvas_name=canvas_name,
                    node_id=node_id,
                    edge_id=edge_id,
                    **metadata
                ),
                timeout=0.5  # 500ms timeout (ADR-0003)
            )
        )
    except Exception as e:
        logger.error(f"Memory event trigger failed: {event_type} for {canvas_name}: {e}")
        # Silent degradation - don't raise
```

### Event Types (from temporal-event.schema.json)

```json
"event_type": {
  "enum": [
    "decomposition_completed",
    "scoring_completed",
    "explanation_generated",
    "review_canvas_created",
    "concept_reviewed",
    "canvas_opened",
    "node_created",      // ← AC-30.5.1
    "node_updated"       // ← AC-30.5.3
  ]
}
```

**Note**: `edge_created` 需要扩展到schema中 (AC-30.5.2)

### Neo4j Relationship Graph (AC-30.5.4)

```cypher
// Canvas contains Node relationship
CREATE (c:Canvas {path: $canvas_path})
       -[:CONTAINS_NODE {created_at: datetime()}]->
       (n:Node {id: $node_id, text: $node_text})

// Node part of Canvas relationship (inverse)
MATCH (c:Canvas {path: $canvas_path}), (n:Node {id: $node_id})
CREATE (n)-[:PART_OF_CANVAS]->(c)

// Edge relationship between nodes
MATCH (from:Node {id: $from_id}), (to:Node {id: $to_id})
CREATE (from)-[:CONNECTS_TO {edge_id: $edge_id}]->(to)
```

---

## SDD规范参考 (必填)

### API端点

**Canvas CRUD端点** (本Story触发点):

| 端点 | 方法 | 触发事件 | 规范来源 |
|------|------|----------|----------|
| `/canvas/{canvas_path}/nodes` | POST | `node_created` | `[Source: specs/api/canvas-api.openapi.yml#addNode]` |
| `/canvas/{canvas_path}/nodes/{node_id}` | PUT | `node_updated` | `[Source: specs/api/canvas-api.openapi.yml#updateNode]` |
| `/canvas/{canvas_path}/edges` | POST | `edge_created` | `[Source: specs/api/canvas-api.openapi.yml#createEdge]` |

**Memory端点** (本Story调用):
- 端点: `POST /api/v1/memory/episodes`
- 规范来源: Memory API (Story 30.3)

### 数据Schema

**CanvasNode Schema**:
- 规范来源: `[Source: specs/data/canvas-node.schema.json]`
- 必填字段: `id`, `type`, `x`, `y`
- 可选字段: `text`, `file`, `color`, `width`, `height`

**TemporalEvent Schema**:
- 规范来源: `[Source: specs/data/temporal-event.schema.json]`
- 必填字段: `event_id`, `session_id`, `event_type`, `timestamp`
- 可选字段: `canvas_path`, `node_id`, `agent_type`, `metadata`

### Canvas Event Model (新建)

```python
# backend/app/models/canvas_events.py
from enum import Enum
from pydantic import BaseModel
from datetime import datetime
from typing import Optional, Dict, Any

class CanvasEventType(str, Enum):
    """Canvas CRUD事件类型枚举"""
    NODE_CREATED = "node_created"
    NODE_UPDATED = "node_updated"
    EDGE_CREATED = "edge_created"

class CanvasEvent(BaseModel):
    """
    Canvas CRUD事件模型

    [Source: specs/data/temporal-event.schema.json]
    """
    event_id: str
    session_id: str
    event_type: CanvasEventType
    timestamp: datetime
    canvas_path: str
    node_id: Optional[str] = None
    edge_id: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
```

---

## ADR决策关联 (必填)

| ADR编号 | 决策标题 | 对Story的影响 |
|---------|----------|---------------|
| ADR-0003 | Graphiti Memory Architecture | 记忆写入必须通过MemoryService→Neo4j |
| ADR-0004 | Async Execution Engine | 使用asyncio.create_task()实现非阻塞写入 |

### 关键约束 (从ADR Consequences提取):

**从 ADR-0003**:
- 所有Graphiti查询必须是异步的 (`await`)
- Neo4j连接失败时必须优雅降级
- 3层架构: Temporal(FSRS) → Graphiti(Neo4j) → Semantic(LanceDB)
- 缓存失效策略: write-through

**从 ADR-0004**:
- 使用 `asyncio.Semaphore(12)` 控制并发
- 模式: `asyncio.gather(*tasks, return_exceptions=True)`
- 单个任务超时不应影响整体执行
- 超时保护: 500ms

来源引用: `[Source: docs/architecture/decisions/0003-graphiti-memory.md]`, `[Source: docs/architecture/decisions/0004-async-execution-engine.md]`

---

## Dependencies

### 前置Story

| Story | 标题 | 状态 | 依赖类型 |
|-------|------|------|----------|
| 30.1 | Neo4j Docker环境部署 | Draft | P0 BLOCKER |
| 30.2 | Neo4jClient真实驱动实现 | Draft | P0 BLOCKER |
| 30.3 | Memory API端点集成验证 | Draft | P1 |
| 30.4 | Agent记忆写入触发机制 | Draft | P1 (可并行) |

**Note**: Story 30.5可与30.4并行开发，但依赖30.1-30.3提供Neo4j基础设施。

### 技术依赖

- Python 3.11+ (`asyncio.create_task`, `asyncio.wait_for`)
- Neo4j 5.26+ (Bolt driver)
- Pydantic v2 (数据模型)

---

## Testing

### Test File Locations
- Unit tests: `backend/tests/unit/test_canvas_memory_trigger.py` (新建)
- Integration tests: `backend/tests/integration/test_canvas_memory_integration.py` (新建)

### Testing Standards
- Framework: pytest + pytest-asyncio
- Coverage: 目标 > 90%
- Mock: 使用 `unittest.mock.AsyncMock` mock MemoryService

### Testing Patterns

```python
@pytest.mark.asyncio
async def test_add_node_triggers_memory_event():
    """Test that add_node triggers node_created memory event."""
    # Arrange
    mock_memory_client = AsyncMock()
    service = CanvasService(
        canvas_base_path="./test",
        memory_client=mock_memory_client
    )

    # Act
    await service.add_node("test-canvas", {
        "type": "text",
        "text": "Test concept",
        "x": 100,
        "y": 200
    })

    # Assert
    mock_memory_client.record_event.assert_called_once()
    call_args = mock_memory_client.record_event.call_args
    assert call_args.kwargs["event_type"] == "node_created"


@pytest.mark.asyncio
async def test_memory_failure_does_not_block_crud():
    """Test that memory write failure doesn't block CRUD response."""
    # Arrange
    mock_memory_client = AsyncMock()
    mock_memory_client.record_event.side_effect = Exception("Neo4j connection failed")
    service = CanvasService(memory_client=mock_memory_client)

    # Act - should not raise despite memory failure
    result = await service.add_node("test-canvas", {"type": "text", "text": "Test"})

    # Assert - CRUD still succeeds
    assert result["id"] is not None
    assert result["type"] == "text"
```

### Key Test Cases
1. `add_node()` triggers `node_created` event
2. `update_node()` triggers `node_updated` event
3. `add_edge()` triggers `edge_created` event
4. Memory write failure doesn't block CRUD response (silent degradation)
5. Memory write timeout (>500ms) is handled gracefully
6. No performance degradation (<50ms overhead)
7. Canvas-Concept relationship is created in Neo4j

---

## Conflict Resolutions (Step 8d)

| # | 冲突 | 决策 | 行动 | 解决者 | 时间戳 |
|---|------|------|------|--------|--------|
| 1 | temporal-event.schema.json vs Story: edge_created枚举缺失 | A (Accept SoT) | 添加Task 0更新Schema | User | 2026-01-16 |

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-17 | 1.0 | Implementation complete, all tests passing (14 unit + 11 integration) | James (Dev) |
| 2026-01-16 | 0.2 | PO验证完成，添加Task 0 (Schema更新前置任务) | Sarah (PO) |
| 2026-01-16 | 0.1 | Initial draft created by SM Agent | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
claude-opus-4-5-20251101 (Claude Opus 4.5)

### Debug Log References
- Unit tests: 14 passed, 0 failed
- Integration tests: 11 passed, 0 failed
- No runtime errors encountered

### Completion Notes List
1. Added `edge_created` to temporal-event.schema.json enum (Task 0)
2. Created CanvasEventType enum, CanvasEvent model, CanvasEventContext dataclass (Task 1)
3. Implemented fire-and-forget pattern using `asyncio.create_task()` with 500ms timeout (Tasks 2-4)
4. Added `record_temporal_event()` to MemoryService with Neo4j relationship creation (Task 5)
5. Added `create_canvas_node_relationship()` and `create_edge_relationship()` to Neo4jClient
6. Used TYPE_CHECKING pattern to avoid circular imports between CanvasService and MemoryService
7. Fixed Pydantic v2 deprecation warning by using `model_config` dict instead of class Config

### File List
**Files created/modified:**
- `specs/data/temporal-event.schema.json` (修改 +2行: edge_created enum, edge_id property)
- `backend/app/models/canvas_events.py` (新建 162行)
- `backend/app/models/__init__.py` (修改 +3行: exports)
- `backend/app/services/canvas_service.py` (修改 +100行: memory trigger hooks)
- `backend/app/services/memory_service.py` (修改 +90行: record_temporal_event method)
- `backend/app/clients/neo4j_client.py` (修改 +60行: relationship methods)
- `backend/tests/unit/test_canvas_memory_trigger.py` (新建 443行, 14 tests)
- `backend/tests/integration/test_canvas_memory_integration.py` (新建 507行, 11 tests)

---

## QA Results

**Review Date**: 2026-01-17
**Reviewer**: Quinn (QA Agent)
**Review Mode**: Comprehensive (ultrathink)

### Code Quality Assessment

| Aspect | Rating | Notes |
|--------|--------|-------|
| Architecture Compliance | ✅ PASS | Fire-and-forget pattern correctly implements ADR-0004 |
| Error Handling | ✅ PASS | Silent degradation pattern, 500ms timeout protection |
| Code Style | ✅ PASS | TYPE_CHECKING pattern for circular imports, Pydantic v2 model_config |
| Documentation | ✅ PASS | Inline comments reference ADR and Story sources |
| Test Coverage | ✅ PASS | 25 tests (14 unit + 11 integration), all passing |

### ADR Compliance Check

| ADR | Requirement | Implementation | Status |
|-----|-------------|----------------|--------|
| ADR-0003 | Async Graphiti queries | `await` on all Neo4j operations | ✅ |
| ADR-0003 | Graceful degradation | try/except with logger.error, no raise | ✅ |
| ADR-0003 | 3-layer architecture | Temporal→Graphiti→Semantic flow | ✅ |
| ADR-0004 | asyncio.create_task() | Fire-and-forget pattern in `_trigger_memory_event()` | ✅ |
| ADR-0004 | 500ms timeout | `asyncio.wait_for(..., timeout=0.5)` | ✅ |
| ADR-0004 | Non-blocking execution | CRUD returns immediately | ✅ |

### AC Traceability Matrix

| AC | Implementation | Unit Tests | Integration Tests | Status |
|----|---------------|------------|-------------------|--------|
| AC-30.5.1 (node_created) | canvas_service.py:218-220 | test_add_node_triggers_memory_event | test_full_crud_triggers_memory | ✅ |
| AC-30.5.2 (edge_created) | canvas_service.py:359-361 | test_add_edge_triggers_memory_event | test_edge_creation_memory_integration | ✅ |
| AC-30.5.3 (node_updated) | canvas_service.py:289-291 | test_update_node_triggers_memory_event | test_update_node_memory_integration | ✅ |
| AC-30.5.4 (Neo4j relationships) | neo4j_client.py:804-893 | test_canvas_concept_relationship | test_canvas_concept_relationship_created | ✅ |

### NFR Assessment

| NFR Category | Requirement | Verified | Evidence |
|--------------|-------------|----------|----------|
| **Security** | Path traversal protection | ✅ | canvas_name validation in _trigger_memory_event |
| **Performance** | <50ms overhead | ✅ | Fire-and-forget returns immediately, test_async_non_blocking |
| **Reliability** | Silent degradation | ✅ | test_memory_failure_silent_degradation (14 tests) |
| **Scalability** | Concurrent CRUD support | ✅ | test_concurrent_crud_with_memory_writes |

### Test Execution Summary

```
============================= test session starts =============================
platform win32 -- Python 3.11.11, pytest-8.3.5
collected 25 items

backend/tests/unit/test_canvas_memory_trigger.py .............. [56%]
backend/tests/integration/test_canvas_memory_integration.py ........... [100%]

============================= 25 passed in 2.34s ==============================
```

### Improvements Checklist

- [x] All ACs have corresponding tests
- [x] ADR constraints verified in code
- [x] Schema updates applied (edge_created, edge_id)
- [x] Fire-and-forget pattern prevents CRUD blocking
- [x] Error handling prevents memory failures from cascading

### Gate Status

| Criterion | Status | Notes |
|-----------|--------|-------|
| All ACs Implemented | ✅ PASS | 4/4 ACs verified |
| Tests Pass | ✅ PASS | 25/25 tests passing |
| ADR Compliance | ✅ PASS | ADR-0003, ADR-0004 verified |
| NFRs Satisfied | ✅ PASS | Security, Performance, Reliability |
| No Blocking Issues | ✅ PASS | No regressions identified |

**GATE DECISION: ✅ PASS**

**Rationale**: Story 30.5 demonstrates complete implementation of all 4 Acceptance Criteria with comprehensive test coverage. The fire-and-forget async pattern correctly follows ADR-0004 guidelines, and the silent degradation pattern ensures CRUD operations are never blocked by memory system failures. All 25 tests pass consistently.
