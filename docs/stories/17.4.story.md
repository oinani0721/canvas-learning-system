# Story 17.4: 性能优化策略实施

## Status
Draft

## Story

**As a** Canvas Learning System用户,
**I want** 系统实施性能优化策略(Canvas操作优化、Agent并行优化、记忆系统优化),
**so that** 我可以获得更快的Canvas操作响应(<500ms API响应)、更高效的Agent执行(<5s Agent调用)、和更低的资源消耗。

## Acceptance Criteria

1. Canvas文件读取优化：使用orjson替代json，实现lru_cache缓存，首次读取后缓存命中率≥80%
2. Canvas批量写入优化：合并多次写入操作，IO减少≥50%
3. Agent并行调度优化：实现ResourceAwareScheduler，根据CPU/内存动态调整并发数
4. 记忆系统优化：Graphiti查询缓存、LanceDB索引预热、Temporal时间范围索引
5. 性能指标达标：API P95响应<500ms, Agent P95执行<5s, 错误率<1%
6. 优化效果可观测：通过Dashboard实时查看优化前后性能对比
7. 回滚机制：优化策略可配置启用/禁用，支持降级到原始实现
8. 所有代码包含文档来源标注(Context7/Skill验证)

## Tasks / Subtasks

- [ ] Task 1: Canvas文件读取优化 (AC: 1)
  - [ ] 集成orjson替代标准json库 (`pip install orjson`)
  - [ ] 实现 `read_canvas_cached()` 方法 (lru_cache + mtime检测)
  - [ ] 配置缓存大小 (maxsize=100)
  - [ ] 编写缓存命中率监控指标

- [ ] Task 2: Canvas批量写入优化 (AC: 2)
  - [ ] 实现 `BatchCanvasWriter` 类
  - [ ] 实现写入队列和合并逻辑 (100ms窗口内合并)
  - [ ] 实现原子写入 (临时文件+重命名)
  - [ ] 实现强制刷新接口 (`flush()`)

- [ ] Task 3: Agent并行调度优化 (AC: 3)
  - [ ] 创建 `src/optimization/resource_aware_scheduler.py`
  - [ ] 实现 `ResourceAwareScheduler` 类
  - [ ] 实现动态并发调整 (CPU>80%或Memory>85%时减半)
  - [ ] 集成psutil获取系统资源指标
  - [ ] 与Epic 10.2 AsyncExecutionEngine集成

- [ ] Task 4: Graphiti查询缓存 (AC: 4)
  - [ ] 实现Graphiti查询结果缓存 (TTL=10分钟)
  - [ ] 实现缓存key生成策略 (query hash)
  - [ ] 实现缓存失效机制 (数据变更时清除)

- [ ] Task 5: LanceDB索引预热 (AC: 4)
  - [ ] 实现启动时索引加载
  - [ ] 实现预热进度回调
  - [ ] 实现懒加载fallback (首次查询时加载)

- [ ] Task 6: Temporal时间范围索引 (AC: 4)
  - [ ] 实现按日期分区查询优化
  - [ ] 添加时间范围索引 (recent 7days, 30days)
  - [ ] 实现查询路由 (根据时间范围选择分区)

- [ ] Task 7: 性能验证和监控集成 (AC: 5, 6)
  - [ ] 实现性能基准测试脚本
  - [ ] 集成Prometheus指标 (优化前后对比)
  - [ ] 更新Dashboard添加优化效果面板
  - [ ] 记录优化收益到日志

- [ ] Task 8: 配置化和回滚机制 (AC: 7)
  - [ ] 创建优化配置 `config/optimization.yaml`
  - [ ] 实现特性开关 (feature flags)
  - [ ] 实现优雅降级 (优化失败时回退)
  - [ ] 编写回滚文档

- [ ] Task 9: 测试和文档 (AC: 8)
  - [ ] 扩展 `src/tests/performance/test_canvas_optimizer.py`
  - [ ] 编写优化策略集成测试
  - [ ] 性能回归测试 (确保无退化)
  - [ ] 更新架构文档
  - [ ] 确认所有代码有文档来源标注

## Dev Notes

### 技术验证报告 (Step 3.6)

**验证完成时间**: 2025-12-03
**验证执行人**: SM Agent (Bob)
**Quality Gate状态**: Pending

#### 技术栈清单

| 技术栈 | 查询方式 | 验证状态 | 文档位置 |
|--------|---------|---------|----------|
| orjson | Context7 | 待验证 | /ijl/orjson |
| functools.lru_cache | Context7 | 待验证 | /python/cpython (functools) |
| psutil | Context7 | 待验证 | /giampaolo/psutil |
| prometheus_client | Context7 | 待验证 | /prometheus/client_python |
| asyncio.Semaphore | Context7 | 待验证 | /python/cpython (asyncio) |
| LanceDB | Local Skill | 待验证 | @langgraph (LanceDB integration) |
| Graphiti | Local Skill | 待验证 | @graphiti |

#### 核心API验证待办

**开发前必须验证**:
- [ ] orjson.loads() / orjson.dumps() API → Context7: /ijl/orjson
- [ ] functools.lru_cache maxsize参数 → Context7: /python/cpython
- [ ] psutil.cpu_percent() / psutil.virtual_memory() → Context7: /giampaolo/psutil
- [ ] prometheus_client Histogram/Gauge/Counter → Context7: /prometheus/client_python
- [ ] asyncio.Semaphore 动态调整 → Context7: /python/cpython
- [ ] LanceDB 索引预热机制 → Local Skill: @langgraph
- [ ] Graphiti search() 缓存策略 → Local Skill: @graphiti

### SDD规范参考 (必填)

**API端点规范** (Epic 17 Monitoring):
- `GET /metrics` - 获取Prometheus格式指标
  - [Source: specs/api/canvas-api.openapi.yml:605-628]
  - 响应格式: `text/plain` (Prometheus格式)
- `GET /metrics/summary` - 获取JSON格式指标摘要
  - [Source: specs/api/canvas-api.openapi.yml:630-642]
  - 响应Schema: `MetricsSummary`
- `GET /metrics/alerts` - 获取当前活跃告警
  - [Source: specs/api/canvas-api.openapi.yml:644-652]
  - 响应Schema: `AlertList`

**性能指标Schema** (需要使用/新增):
- MetricsSummary:
  - [Source: specs/api/canvas-api.openapi.yml - components/schemas]
  - 字段: `api_requests_total`, `avg_latency_ms`, `error_rate`, `concurrent_requests`
  - 优化相关新增字段: `cache_hit_rate`, `optimization_enabled`, `optimization_savings`

**Layer 1 Canvas操作端点** (优化目标):
- `GET /canvas/{canvas_path}` - 读取Canvas文件 (优化重点)
  - [Source: specs/api/canvas-api.openapi.yml:58-76]
  - 目标延迟: <200ms (当前P95)
- `PUT /canvas/{canvas_path}` - 写入Canvas文件 (批量优化)
  - [Source: specs/api/canvas-api.openapi.yml:77-96]
  - 目标: 批量写入合并，IO减少60%

### ADR决策关联 (必填)

| ADR编号 | 决策标题 | 对Story的影响 |
|---------|----------|---------------|
| ADR-0004 | Async Execution Engine | ResourceAwareScheduler必须与现有AsyncExecutionEngine兼容集成 |
| ADR-0007 | Caching Strategy (Tiered) | 使用L1内存+L2 SQLite分层缓存架构，Embedding永久缓存 |
| ADR-0009 | Error Handling & Retry | 优化失败时的错误处理遵循统一重试策略 |
| ADR-0010 | Logging Aggregation | 性能指标日志使用structlog格式 |

**关键约束**:
- 缓存实现必须遵循ADR-0007分层缓存架构 (L1内存 + L2 SQLite)
- 内存缓存使用TTLCache，配置见 `ADR-007-CACHING-STRATEGY-TIERED.md:103-129`
- Embedding缓存永不过期，使用LRU淘汰策略
- 优化策略必须可配置开关，支持回滚

### 架构设计参考

**架构文档引用**:
- 性能监控架构: [Source: docs/architecture/performance-monitoring-architecture.md]
- 性能优化策略: [Source: docs/architecture/performance-monitoring-architecture.md:336-398]
- Canvas操作优化: [Source: docs/architecture/performance-monitoring-architecture.md:338-360]
- Agent并行优化: [Source: docs/architecture/performance-monitoring-architecture.md:362-389]
- 记忆系统优化: [Source: docs/architecture/performance-monitoring-architecture.md:391-398]

**性能目标** (Source: docs/architecture/performance-monitoring-architecture.md:516-524):
| 指标 | 目标 | 验收条件 |
|------|------|---------|
| API响应时间 | P95 <500ms | 95%请求在500ms内完成 |
| 错误率 | <1% | 每日错误率低于1% |
| Agent执行 | P95 <5s | 95%Agent调用在5秒内完成 |
| 缓存命中率 | >80% | Canvas读取缓存命中率 |

**优化策略预期收益**:
| 优化点 | 策略 | 预期收益 |
|--------|------|---------|
| 文件读取 | 增量读取 + 缓存 | -50%延迟 |
| JSON解析 | orjson替代json | -30%CPU |
| 批量写入 | 合并多次写入 | -60%IO |

### 代码示例库

**Canvas文件读取优化** (Source: docs/architecture/performance-monitoring-architecture.md:346-360):
```python
# ✅ Verified from Architecture Doc (performance-monitoring-architecture.md:346-360)
from functools import lru_cache
import orjson

@lru_cache(maxsize=100)
def read_canvas_cached(canvas_path: str, mtime: float):
    """带缓存的Canvas读取

    Args:
        canvas_path: Canvas文件路径
        mtime: 文件修改时间戳 (用于缓存失效)

    Returns:
        dict: Canvas JSON数据
    """
    with open(canvas_path, 'rb') as f:
        return orjson.loads(f.read())

def read_canvas(canvas_path: str):
    """读取Canvas文件 (自动缓存)"""
    mtime = os.path.getmtime(canvas_path)
    return read_canvas_cached(canvas_path, mtime)
```

**资源感知并行调度器** (Source: docs/architecture/performance-monitoring-architecture.md:364-389):
```python
# ✅ Verified from Architecture Doc (performance-monitoring-architecture.md:364-389)
import asyncio
import psutil
from typing import List, Coroutine

class ResourceAwareScheduler:
    """资源感知的并行调度器

    根据系统CPU和内存使用率动态调整并发任务数。
    """

    def __init__(self, max_concurrent: int = 50):
        self.max_concurrent = max_concurrent
        self.semaphore = asyncio.Semaphore(max_concurrent)

    async def schedule(self, tasks: List[Coroutine]):
        """根据资源动态调整并发"""
        cpu_usage = psutil.cpu_percent()
        memory_usage = psutil.virtual_memory().percent

        # 动态调整并发数
        if cpu_usage > 80 or memory_usage > 85:
            effective_limit = max(10, self.max_concurrent // 2)
        else:
            effective_limit = self.max_concurrent

        semaphore = asyncio.Semaphore(effective_limit)

        async def limited_task(task):
            async with semaphore:
                return await task

        return await asyncio.gather(*[limited_task(t) for t in tasks])
```

**缓存配置** (Source: docs/architecture/decisions/ADR-007-CACHING-STRATEGY-TIERED.md:103-129):
```python
# ✅ Verified from ADR-007 (ADR-007-CACHING-STRATEGY-TIERED.md:103-129)
class CacheConfig:
    """Canvas Learning System - 32GB 内存优化配置"""

    MEMORY_CACHES = {
        # Embedding 向量 - 最高优先级
        "embedding": {
            "maxsize": 5000,     # 5000 个向量
            "ttl": None,        # 永不过期，LRU 淘汰
        },
        # 记忆检索结果
        "memory_results": {
            "maxsize": 2000,     # 2000 条查询结果
            "ttl": 600,         # 10 分钟过期
        },
        # Canvas 文件内容
        "canvas_files": {
            "maxsize": 200,      # 200 个文件
            "ttl": 3600,        # 1 小时过期
        },
    }
```

### 文件路径参考

**现有性能优化代码**:
- Canvas优化器测试: `src/tests/performance/test_canvas_optimizer.py`
- 系统压力测试: `src/tests/performance/test_system_stress.py`
- Canvas性能优化器: `src/canvas_performance_optimizer.py`
- API配置: `src/api/config.py`, `backend/app/config.py`

**需要修改/新增的文件**:
- 新增: `src/optimization/resource_aware_scheduler.py`
- 新增: `src/optimization/canvas_cache.py`
- 新增: `src/optimization/memory_cache.py`
- 新增: `config/optimization.yaml`
- 修改: `backend/app/dependencies.py` (集成优化组件)
- 修改: `backend/app/api/v1/endpoints/health.py` (添加优化指标)

### 依赖关系

**前置Story**:
- Story 17.1: 基础监控 (提供指标采集基础)
- Story 17.2: 深度监控 (提供Agent/Memory监控)
- Story 17.3: 告警和Dashboard (提供可视化基础)

**后续影响**:
- 优化效果将反映在Dashboard性能面板
- 告警阈值可能需要根据优化后基线调整

### Definition of Done

- [ ] 所有AC通过验收测试
- [ ] orjson集成完成，Canvas读取性能提升≥30%
- [ ] lru_cache缓存命中率≥80%
- [ ] 批量写入IO减少≥50%
- [ ] ResourceAwareScheduler集成完成
- [ ] 记忆系统缓存实现完成
- [ ] 性能基准测试通过 (P95 API <500ms, Agent <5s)
- [ ] Dashboard显示优化效果
- [ ] 配置开关和回滚机制可用
- [ ] 代码Review通过
- [ ] 测试覆盖率≥90%
- [ ] 文档更新完成

### 风险和缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|---------|
| orjson兼容性问题 | 低 | 中 | 保留json fallback |
| 缓存内存占用过高 | 中 | 中 | 配置maxsize限制 |
| 并发调整过于激进 | 中 | 高 | 设置最小并发数(10) |
| 优化引入新bug | 中 | 高 | 完整测试覆盖+回滚机制 |

### 估算

- **Story Points**: 8
- **预估工时**: 4-5天
- **复杂度**: 中高 (涉及多个优化策略集成)

---

**文档版本**: v1.0.0
**创建时间**: 2025-12-03
**创建者**: SM Agent (Bob)
**Epic**: Epic 17 - 性能优化和监控
