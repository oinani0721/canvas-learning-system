# Epic 9.8.8: é«˜çº§åŠŸèƒ½å®ç° (æ™ºèƒ½æ¨è + åä½œåŠŸèƒ½)

## ğŸ“‹ Epic æ¦‚è¦

**Epic åç§°**: é«˜çº§åŠŸèƒ½å®ç° - æ™ºèƒ½æ¨èç³»ç»Ÿä¸å®æ—¶åä½œåŠŸèƒ½
**Epic ç¼–å·**: 9.8.8
**åˆ›å»ºæ—¥æœŸ**: 2025-10-26
**é¢„è®¡å·¥æœŸ**: 2å‘¨
**ä¼˜å…ˆçº§**: ä¸­ (P2)
**è´Ÿè´£äºº**: Frontend Team + ML Team
**ä¾èµ–å…³ç³»**: Epic 9.8.6, Epic 9.8.7
**Epic ç±»å‹**: é«˜çº§åŠŸèƒ½å¼€å‘

## ğŸ¯ Epic ç›®æ ‡

åœ¨å‰ä¸¤é˜¶æ®µæ¶æ„ä¼˜åŒ–çš„åŸºç¡€ä¸Šï¼Œå®æ–½ç¬¬ä¸‰é˜¶æ®µçš„é«˜çº§åŠŸèƒ½å¼€å‘ï¼Œå®ç°åŸºäºç”¨æˆ·è¡Œä¸ºçš„æ™ºèƒ½å‘½ä»¤æ¨èç³»ç»Ÿå’Œå¤šç”¨æˆ·å®æ—¶åä½œåŠŸèƒ½ï¼Œå°†Canvas Learning Systemå‡çº§ä¸ºæ™ºèƒ½åŒ–çš„ååŒå­¦ä¹ å¹³å°ã€‚

### æ ¸å¿ƒç›®æ ‡

1. **æ™ºèƒ½æ¨èç³»ç»Ÿ**: åŸºäºä½¿ç”¨å†å²å’Œå­¦ä¹ æ¨¡å¼ï¼Œæä¾›ä¸ªæ€§åŒ–çš„å‘½ä»¤å’Œå­¦ä¹ å†…å®¹æ¨è
2. **å®æ—¶åä½œåŠŸèƒ½**: æ”¯æŒå¤šç”¨æˆ·åŒæ—¶ç¼–è¾‘Canvasï¼Œå®æ—¶åŒæ­¥çŠ¶æ€å’Œåä½œæ“ä½œ
3. **ç§»åŠ¨ç«¯é€‚é…**: å®Œå–„ç§»åŠ¨ç«¯ä½“éªŒï¼Œæ”¯æŒè§¦æ‘¸æ“ä½œå’Œå“åº”å¼è®¾è®¡
4. **ç”¨æˆ·è¡Œä¸ºåˆ†æ**: æ„å»ºç”¨æˆ·è¡Œä¸ºæ•°æ®æ”¶é›†å’Œåˆ†æä½“ç³»ï¼Œæ”¯æŒæ™ºèƒ½å†³ç­–

## ğŸ“Š åŠŸèƒ½éœ€æ±‚åˆ†æ

### æ™ºèƒ½æ¨èç³»ç»Ÿéœ€æ±‚

#### æ¨èåœºæ™¯
- **å‘½ä»¤æ¨è**: åŸºäºä½¿ç”¨é¢‘ç‡å’Œæ—¶é—´æ¨¡å¼çš„å‘½ä»¤æ¨è
- **Canvasæ¨è**: åŸºäºå­¦ä¹ è¿›åº¦å’Œç›¸å…³æ€§çš„Canvaså†…å®¹æ¨è
- **å¤ä¹ æé†’**: åŸºäºè‰¾å®¾æµ©æ–¯æ›²çº¿çš„æ™ºèƒ½å¤ä¹ æ—¶é—´æ¨è
- **å­¦ä¹ è·¯å¾„**: åŸºäºçŸ¥è¯†å›¾è°±çš„ä¸ªæ€§åŒ–å­¦ä¹ è·¯å¾„æ¨è

#### æ¨èç®—æ³•ç±»å‹
- **ååŒè¿‡æ»¤**: åŸºäºç”¨æˆ·è¡Œä¸ºç›¸ä¼¼æ€§çš„æ¨è
- **å†…å®¹è¿‡æ»¤**: åŸºäºå†…å®¹ç‰¹å¾ç›¸ä¼¼æ€§çš„æ¨è
- **æ—¶é—´åºåˆ—åˆ†æ**: åŸºäºæ—¶é—´ä½¿ç”¨æ¨¡å¼çš„æ¨è
- **çŸ¥è¯†å›¾è°±æ¨ç†**: åŸºäºCanvasçŸ¥è¯†å…³è”çš„æ¨è

### å®æ—¶åä½œåŠŸèƒ½éœ€æ±‚

#### åä½œç‰¹æ€§
- **å®æ—¶åŒæ­¥**: å¤šç”¨æˆ·ç¼–è¾‘Canvasæ—¶çš„å®æ—¶çŠ¶æ€åŒæ­¥
- **å†²çªè§£å†³**: ç¼–è¾‘å†²çªçš„æ™ºèƒ½æ£€æµ‹å’Œè§£å†³æœºåˆ¶
- **æƒé™ç®¡ç†**: ä¸åŒç”¨æˆ·è§’è‰²çš„è®¿é—®å’Œç¼–è¾‘æƒé™æ§åˆ¶
- **åä½œå†å²**: å®Œæ•´çš„åä½œæ“ä½œå†å²è®°å½•å’Œå›æ”¾

#### åä½œåœºæ™¯
- **å¸ˆç”Ÿåä½œ**: æ•™å¸ˆæŒ‡å¯¼å­¦ç”Ÿè¿›è¡ŒCanvaså­¦ä¹ 
- **åŒå­¦åä½œ**: å­¦ç”Ÿä¹‹é—´è¿›è¡ŒCanvaså…±äº«å’Œè®¨è®º
- **ç¾¤ç»„å­¦ä¹ **: å¤šäººå…±åŒç¼–è¾‘å’Œå­¦ä¹ Canvaså†…å®¹

## ğŸ—ï¸ æŠ€æœ¯å®æ–½æ–¹æ¡ˆ

### 1. æ™ºèƒ½æ¨èç³»ç»Ÿæ¶æ„

#### 1.1 æ¨èå¼•æ“è®¾è®¡
```typescript
// src/services/recommendation/RecommendationEngine.ts
export interface RecommendationContext {
  userId: string;
  currentCanvas?: string;
  recentCommands: CommandHistoryItem[];
  learningProgress: LearningProgress;
  timeOfDay: number;
  dayOfWeek: number;
  sessionDuration: number;
}

export interface RecommendationItem {
  id: string;
  type: 'command' | 'canvas' | 'review' | 'learning_path';
  title: string;
  description: string;
  score: number;
  reason: string;
  metadata: Record<string, any>;
}

export class RecommendationEngine {
  private strategies: Map<string, RecommendationStrategy> = new Map();
  private userBehaviorStore: UserBehaviorStore;
  private knowledgeGraph: KnowledgeGraphService;

  constructor(
    userBehaviorStore: UserBehaviorStore,
    knowledgeGraph: KnowledgeGraphService
  ) {
    this.userBehaviorStore = userBehaviorStore;
    this.knowledgeGraph = knowledgeGraph;
    this.initializeStrategies();
  }

  private initializeStrategies() {
    // å‘½ä»¤ä½¿ç”¨é¢‘ç‡ç­–ç•¥
    this.strategies.set('command_frequency', new CommandFrequencyStrategy());

    // æ—¶é—´æ¨¡å¼ç­–ç•¥
    this.strategies.set('time_pattern', new TimePatternStrategy());

    // å†…å®¹ç›¸å…³æ€§ç­–ç•¥
    this.strategies.set('content_relevance', new ContentRelevanceStrategy());

    // å­¦ä¹ è¿›åº¦ç­–ç•¥
    this.strategies.set('learning_progress', new LearningProgressStrategy());

    // ååŒè¿‡æ»¤ç­–ç•¥
    this.strategies.set('collaborative_filtering', new CollaborativeFilteringStrategy());
  }

  async generateRecommendations(
    context: RecommendationContext,
    count: number = 10
  ): Promise<RecommendationItem[]> {
    const recommendations: RecommendationItem[] = [];

    // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰æ¨èç­–ç•¥
    const strategyPromises = Array.from(this.strategies.entries()).map(
      async ([name, strategy]) => {
        try {
          return await strategy.generate(context, Math.ceil(count / this.strategies.size));
        } catch (error) {
          console.error(`Recommendation strategy ${name} failed:`, error);
          return [];
        }
      }
    );

    const strategyResults = await Promise.all(strategyPromises);
    const allRecommendations = strategyResults.flat();

    // å»é‡å’Œæ’åº
    const uniqueRecommendations = this.deduplicateRecommendations(allRecommendations);
    const scoredRecommendations = this.scoreRecommendations(uniqueRecommendations, context);

    return scoredRecommendations
      .sort((a, b) => b.score - a.score)
      .slice(0, count);
  }

  private deduplicateRecommendations(recommendations: RecommendationItem[]): RecommendationItem[] {
    const seen = new Set<string>();
    return recommendations.filter(rec => {
      const key = `${rec.type}:${rec.id}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }

  private scoreRecommendations(
    recommendations: RecommendationItem[],
    context: RecommendationContext
  ): RecommendationItem[] {
    return recommendations.map(rec => ({
      ...rec,
      score: this.calculateCompositeScore(rec, context)
    }));
  }

  private calculateCompositeScore(
    recommendation: RecommendationItem,
    context: RecommendationContext
  ): number {
    let score = recommendation.score;

    // æ—¶é—´å› ç´ åŠ æƒ
    const timeWeight = this.getTimeWeight(context.timeOfDay);
    score *= timeWeight;

    // ç”¨æˆ·è¡Œä¸ºåŠ æƒ
    const behaviorWeight = this.getBehaviorWeight(recommendation, context);
    score *= behaviorWeight;

    // æ–°é²œåº¦åŠ æƒ
    const freshnessWeight = this.getFreshnessWeight(recommendation);
    score *= freshnessWeight;

    return Math.round(score * 100) / 100;
  }

  private getTimeWeight(timeOfDay: number): number {
    // ä¸Šåˆ(9-12ç‚¹)å’Œæ™šä¸Š(19-22ç‚¹)æ˜¯å­¦ä¹ é«˜å³°æœŸ
    if ((timeOfDay >= 9 && timeOfDay <= 12) || (timeOfDay >= 19 && timeOfDay <= 22)) {
      return 1.2;
    }
    return 1.0;
  }

  private getBehaviorWeight(
    recommendation: RecommendationItem,
    context: RecommendationContext
  ): number {
    // åŸºäºç”¨æˆ·å†å²è¡Œä¸ºè°ƒæ•´æƒé‡
    const userPreferences = this.userBehaviorStore.getUserPreferences(context.userId);

    if (recommendation.type === 'command') {
      const commandFreq = userPreferences.commandFrequency.get(recommendation.id) || 0;
      return 1 + (commandFreq * 0.1);
    }

    return 1.0;
  }

  private getFreshnessWeight(recommendation: RecommendationItem): number {
    // æ–°æ¨èè·å¾—é¢å¤–æƒé‡
    const daysSinceCreated = this.getDaysSinceCreated(recommendation);
    if (daysSinceCreated < 7) {
      return 1.1;
    }
    return 1.0;
  }

  private getDaysSinceCreated(recommendation: RecommendationItem): number {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ä»metadataä¸­è·å–åˆ›å»ºæ—¶é—´
    return 0;
  }
}
```

#### 1.2 æ¨èç­–ç•¥å®ç°
```typescript
// src/services/recommendation/strategies/CommandFrequencyStrategy.ts
export class CommandFrequencyStrategy implements RecommendationStrategy {
  async generate(context: RecommendationContext, count: number): Promise<RecommendationItem[]> {
    const { recentCommands, timeOfDay, dayOfWeek } = context;

    // åˆ†æå‘½ä»¤ä½¿ç”¨é¢‘ç‡æ¨¡å¼
    const frequencyAnalysis = this.analyzeCommandFrequency(recentCommands);
    const timePatterns = this.analyzeTimePatterns(recentCommands, timeOfDay, dayOfWeek);

    const recommendations: RecommendationItem[] = [];

    // åŸºäºé¢‘ç‡æ¨è
    frequencyAnalysis.forEach((freq, command) => {
      if (freq > 2) { // ä½¿ç”¨é¢‘ç‡>2æ¬¡çš„å‘½ä»¤
        recommendations.push({
          id: command,
          type: 'command',
          title: this.getCommandDisplayName(command),
          description: this.getCommandDescription(command),
          score: freq * 0.8 + (timePatterns.get(command) || 0) * 0.2,
          reason: `æ‚¨å·²ä½¿ç”¨${freq}æ¬¡ï¼Œæ˜¯æ‚¨çš„å¸¸ç”¨å‘½ä»¤`,
          metadata: { frequency: freq, timePattern: timePatterns.get(command) }
        });
      }
    });

    return recommendations
      .sort((a, b) => b.score - a.score)
      .slice(0, count);
  }

  private analyzeCommandFrequency(commands: CommandHistoryItem[]): Map<string, number> {
    const frequency = new Map<string, number>();
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);

    commands
      .filter(cmd => new Date(cmd.timestamp) > thirtyDaysAgo)
      .forEach(cmd => {
        frequency.set(cmd.command, (frequency.get(cmd.command) || 0) + 1);
      });

    return frequency;
  }

  private analyzeTimePatterns(
    commands: CommandHistoryItem[],
    currentHour: number,
    currentDayOfWeek: number
  ): Map<string, number> {
    const patterns = new Map<string, number>();

    commands.forEach(cmd => {
      const cmdDate = new Date(cmd.timestamp);
      const cmdHour = cmdDate.getHours();
      const cmdDayOfWeek = cmdDate.getDay();

      // è®¡ç®—æ—¶é—´ç›¸ä¼¼åº¦
      const hourDiff = Math.abs(cmdHour - currentHour);
      const dayDiff = Math.abs(cmdDayOfWeek - currentDayOfWeek);

      const timeSimilarity = Math.exp(-(hourDiff * hourDiff + dayDiff * dayDiff) / 10);
      const currentScore = patterns.get(cmd.command) || 0;
      patterns.set(cmd.command, currentScore + timeSimilarity);
    });

    return patterns;
  }

  private getCommandDisplayName(command: string): string {
    // ä»å‘½ä»¤æ˜ å°„è¡¨è·å–æ˜¾ç¤ºåç§°
    const commandNames: Record<string, string> = {
      'review': 'è‰¾å®¾æµ©æ–¯å¤ä¹ ',
      'canvas': 'Canvaså­¦ä¹ ç³»ç»Ÿ',
      'memory-stats': 'è®°å¿†ç»Ÿè®¡',
      'è¯„åˆ†': 'æ™ºèƒ½è¯„åˆ†',
      'åŸºç¡€æ‹†è§£': 'åŸºç¡€æ‹†è§£',
      'å£è¯­åŒ–è§£é‡Š': 'å£è¯­åŒ–è§£é‡Š'
    };
    return commandNames[command] || command;
  }

  private getCommandDescription(command: string): string {
    const descriptions: Record<string, string> = {
      'review': 'åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿çš„æ™ºèƒ½å¤ä¹ ç³»ç»Ÿ',
      'canvas': 'å¯åŠ¨Canvaså­¦ä¹ ç³»ç»Ÿï¼Œè¿›è¡Œå¯è§†åŒ–å­¦ä¹ ',
      'memory-stats': 'æŸ¥çœ‹å­¦ä¹ è®°å¿†ç»Ÿè®¡å’Œç³»ç»ŸçŠ¶æ€',
      'è¯„åˆ†': 'ä½¿ç”¨AIè¯„åˆ†ç³»ç»Ÿè¯„ä¼°æ‚¨çš„ç†è§£ç¨‹åº¦',
      'åŸºç¡€æ‹†è§£': 'å°†å¤æ‚æ¦‚å¿µæ‹†è§£ä¸ºç®€å•æ˜“æ‡‚çš„é—®é¢˜',
      'å£è¯­åŒ–è§£é‡Š': 'ç”Ÿæˆæ•™æˆå¼çš„å£è¯­åŒ–è§£é‡Š'
    };
    return descriptions[command] || 'Canvaså­¦ä¹ ç³»ç»Ÿå‘½ä»¤';
  }
}
```

```typescript
// src/services/recommendation/strategies/LearningProgressStrategy.ts
export class LearningProgressStrategy implements RecommendationStrategy {
  async generate(context: RecommendationContext, count: number): Promise<RecommendationItem[]> {
    const { learningProgress, currentCanvas } = context;
    const recommendations: RecommendationItem[] = [];

    // åŸºäºå­¦ä¹ è¿›åº¦æ¨èå¤ä¹ å†…å®¹
    const reviewRecommendations = this.generateReviewRecommendations(learningProgress);
    recommendations.push(...reviewRecommendations);

    // åŸºäºå½“å‰Canvasæ¨èç›¸å…³å†…å®¹
    if (currentCanvas) {
      const contentRecommendations = await this.generateContentRecommendations(currentCanvas, learningProgress);
      recommendations.push(...contentRecommendations);
    }

    return recommendations
      .sort((a, b) => b.score - a.score)
      .slice(0, count);
  }

  private generateReviewRecommendations(progress: LearningProgress): RecommendationItem[] {
    const recommendations: RecommendationItem[] = [];

    // æ‰¾å‡ºéœ€è¦å¤ä¹ çš„Canvas
    progress.canvasProgress.forEach(canvas => {
      const daysSinceLastReview = this.getDaysSince(canvas.lastReviewDate);
      const reviewScore = this.calculateReviewScore(canvas, daysSinceLastReview);

      if (reviewScore > 0.5) { // éœ€è¦å¤ä¹ çš„é˜ˆå€¼
        recommendations.push({
          id: `review:${canvas.canvasId}`,
          type: 'review',
          title: `å¤ä¹ : ${canvas.canvasName}`,
          description: `ä¸Šæ¬¡å¤ä¹ ${daysSinceLastReview}å¤©å‰ï¼Œå»ºè®®å¤ä¹ `,
          score: reviewScore,
          reason: `æ ¹æ®è‰¾å®¾æµ©æ–¯æ›²çº¿ï¼Œç°åœ¨å¤ä¹ æ•ˆæœæœ€ä½³`,
          metadata: {
            canvasId: canvas.canvasId,
            daysSinceLastReview,
            masteryLevel: canvas.masteryLevel
          }
        });
      }
    });

    return recommendations;
  }

  private calculateReviewScore(canvas: CanvasProgress, daysSinceLastReview: number): number {
    // åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿è®¡ç®—å¤ä¹ ç´§æ€¥ç¨‹åº¦
    const forgettingCurve = Math.exp(-daysSinceLastReview / (canvas.masteryLevel * 10));
    return 1 - forgettingCurve;
  }

  private getDaysSince(date: Date): number {
    const now = new Date();
    const diffTime = Math.abs(now.getTime() - date.getTime());
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  }

  private async generateContentRecommendations(
    currentCanvas: string,
    progress: LearningProgress
  ): Promise<RecommendationItem[]> {
    // åŸºäºçŸ¥è¯†å›¾è°±æ¨èç›¸å…³Canvaså†…å®¹
    // è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥æŸ¥è¯¢çŸ¥è¯†å›¾è°±æœåŠ¡
    return [{
      id: `related:${currentCanvas}`,
      type: 'canvas',
      title: `ç›¸å…³å­¦ä¹ : ${this.getRelatedCanvasName(currentCanvas)}`,
      description: 'åŸºäºå½“å‰å­¦ä¹ å†…å®¹æ¨èçš„ç›¸å…³Canvas',
      score: 0.7,
      reason: 'ä¸å½“å‰å­¦ä¹ çš„Canvaså†…å®¹é«˜åº¦ç›¸å…³',
      metadata: { relatedTo: currentCanvas }
    }];
  }

  private getRelatedCanvasName(canvasId: string): string {
    // ç®€åŒ–å®ç°
    return 'ç›¸å…³æ¦‚å¿µ';
  }
}
```

#### 1.3 æ¨èUIç»„ä»¶
```typescript
// src/components/recommendation/RecommendationPanel.tsx
import { useState, useEffect } from 'react';
import { useRecommendations } from '@/hooks/useRecommendations';
import { RecommendationItem } from '@/services/recommendation/RecommendationEngine';

interface RecommendationPanelProps {
  userId: string;
  currentCanvas?: string;
  maxItems?: number;
  className?: string;
}

const RecommendationPanel: React.FC<RecommendationPanelProps> = ({
  userId,
  currentCanvas,
  maxItems = 8,
  className = ''
}) => {
  const [recommendations, setRecommendations] = useState<RecommendationItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [dismissedItems, setDismissedItems] = useState<Set<string>>(new Set());

  const { generateRecommendations, trackRecommendationInteraction } = useRecommendations();

  useEffect(() => {
    loadRecommendations();
  }, [userId, currentCanvas]);

  const loadRecommendations = async () => {
    setIsLoading(true);
    try {
      const newRecommendations = await generateRecommendations({
        userId,
        currentCanvas,
        maxItems: maxItems * 2 // è·å–æ›´å¤šå€™é€‰ï¼Œç„¶åè¿‡æ»¤
      });

      // è¿‡æ»¤å·²å¿½ç•¥çš„æ¨è
      const filteredRecommendations = newRecommendations.filter(
        rec => !dismissedItems.has(`${rec.type}:${rec.id}`)
      );

      setRecommendations(filteredRecommendations.slice(0, maxItems));
    } catch (error) {
      console.error('Failed to load recommendations:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleRecommendationClick = (recommendation: RecommendationItem) => {
    // è®°å½•ç”¨æˆ·äº¤äº’
    trackRecommendationInteraction(userId, recommendation.id, 'click');

    // æ‰§è¡Œæ¨èåŠ¨ä½œ
    executeRecommendation(recommendation);
  };

  const handleDismiss = (recommendation: RecommendationItem, e: React.MouseEvent) => {
    e.stopPropagation();

    const dismissKey = `${recommendation.type}:${recommendation.id}`;
    const newDismissedItems = new Set(dismissedItems).add(dismissKey);
    setDismissedItems(newDismissedItems);

    // è®°å½•å¿½ç•¥è¡Œä¸º
    trackRecommendationInteraction(userId, recommendation.id, 'dismiss');

    // ç§»é™¤è¯¥é¡¹å¹¶é‡æ–°åŠ è½½
    setRecommendations(prev => prev.filter(rec => rec !== recommendation));
  };

  const executeRecommendation = (recommendation: RecommendationItem) => {
    switch (recommendation.type) {
      case 'command':
        // æ‰§è¡Œå‘½ä»¤
        window.location.href = `/command?cmd=${recommendation.id}`;
        break;
      case 'canvas':
        // æ‰“å¼€Canvas
        window.location.href = `/canvas?file=${recommendation.id}`;
        break;
      case 'review':
        // å¼€å§‹å¤ä¹ 
        window.location.href = `/review?canvas=${recommendation.metadata.canvasId}`;
        break;
      case 'learning_path':
        // æ˜¾ç¤ºå­¦ä¹ è·¯å¾„
        window.location.href = `/learning-path?id=${recommendation.id}`;
        break;
    }
  };

  if (isLoading) {
    return (
      <div className={`recommendation-panel loading ${className}`}>
        <div className="panel-header">
          <h3>æ™ºèƒ½æ¨è</h3>
        </div>
        <div className="recommendation-skeleton">
          {[...Array(4)].map((_, i) => (
            <div key={i} className="skeleton-item">
              <div className="skeleton-content" />
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (recommendations.length === 0) {
    return (
      <div className={`recommendation-panel empty ${className}`}>
        <div className="panel-header">
          <h3>æ™ºèƒ½æ¨è</h3>
        </div>
        <div className="empty-state">
          <div className="empty-icon">ğŸ¤–</div>
          <p>æš‚æ— æ¨èå†…å®¹</p>
          <p className="empty-hint">ç»§ç»­å­¦ä¹ åå°†è·å¾—ä¸ªæ€§åŒ–æ¨è</p>
        </div>
      </div>
    );
  }

  return (
    <div className={`recommendation-panel ${className}`}>
      <div className="panel-header">
        <h3>æ™ºèƒ½æ¨è</h3>
        <button
          onClick={loadRecommendations}
          className="refresh-button"
          title="åˆ·æ–°æ¨è"
        >
          ğŸ”„
        </button>
      </div>

      <div className="recommendation-list">
        {recommendations.map((recommendation, index) => (
          <div
            key={`${recommendation.type}:${recommendation.id}`}
            className="recommendation-item"
            onClick={() => handleRecommendationClick(recommendation)}
            style={{ animationDelay: `${index * 50}ms` }}
          >
            <div className="recommendation-content">
              <div className="recommendation-header">
                <div className="recommendation-type">
                  {getTypeIcon(recommendation.type)}
                </div>
                <div className="recommendation-title">
                  <h4>{recommendation.title}</h4>
                  <div className="recommendation-score">
                    {Math.round(recommendation.score * 100)}%
                  </div>
                </div>
                <button
                  className="dismiss-button"
                  onClick={(e) => handleDismiss(recommendation, e)}
                  title="å¿½ç•¥æ­¤æ¨è"
                >
                  âœ•
                </button>
              </div>

              <p className="recommendation-description">
                {recommendation.description}
              </p>

              <div className="recommendation-reason">
                <span className="reason-label">æ¨èç†ç”±:</span>
                <span className="reason-text">{recommendation.reason}</span>
              </div>
            </div>

            <div className="recommendation-arrow">
              â†’
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

function getTypeIcon(type: string): string {
  const icons: Record<string, string> = {
    command: 'âš¡',
    canvas: 'ğŸ¨',
    review: 'ğŸ“š',
    learning_path: 'ğŸ¯'
  };
  return icons[type] || 'ğŸ“¦';
}

export default RecommendationPanel;
```

### 2. å®æ—¶åä½œåŠŸèƒ½

#### 2.1 WebSocketè¿æ¥ç®¡ç†
```typescript
// src/services/collaboration/CollaborationService.ts
export interface CollaborationEvent {
  id: string;
  type: 'node_add' | 'node_update' | 'node_delete' | 'edge_add' | 'edge_delete' | 'cursor_move';
  userId: string;
  canvasId: string;
  timestamp: number;
  data: any;
}

export interface UserCursor {
  userId: string;
  userName: string;
  position: { x: number; y: number };
  color: string;
  lastSeen: number;
}

export class CollaborationService {
  private ws: WebSocket | null = null;
  private eventHandlers: Map<string, Function[]> = new Map();
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;
  private canvasId: string | null = null;
  private userId: string | null = null;

  constructor() {
    this.setupEventHandlers();
  }

  async connect(canvasId: string, userId: string): Promise<void> {
    this.canvasId = canvasId;
    this.userId = userId;

    const wsUrl = `${process.env.REACT_APP_WS_URL}/collaboration/${canvasId}?userId=${userId}`;

    try {
      this.ws = new WebSocket(wsUrl);
      await this.setupWebSocket();
    } catch (error) {
      console.error('Failed to connect to collaboration service:', error);
      throw error;
    }
  }

  private async setupWebSocket(): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!this.ws) {
        reject(new Error('WebSocket not initialized'));
        return;
      }

      this.ws.onopen = () => {
        console.log('Collaboration service connected');
        this.reconnectAttempts = 0;
        this.emit('connected');
        resolve();
      };

      this.ws.onmessage = (event) => {
        try {
          const collaborationEvent: CollaborationEvent = JSON.parse(event.data);
          this.handleIncomingEvent(collaborationEvent);
        } catch (error) {
          console.error('Failed to parse collaboration event:', error);
        }
      };

      this.ws.onclose = (event) => {
        console.log('Collaboration service disconnected:', event.code, event.reason);
        this.emit('disconnected');
        this.handleReconnect();
      };

      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        reject(error);
      };
    });
  }

  private handleReconnect(): void {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);

      console.log(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts})`);

      setTimeout(async () => {
        try {
          if (this.canvasId && this.userId) {
            await this.connect(this.canvasId, this.userId);
          }
        } catch (error) {
          console.error('Reconnection failed:', error);
        }
      }, delay);
    } else {
      console.error('Max reconnection attempts reached');
      this.emit('reconnect_failed');
    }
  }

  private handleIncomingEvent(event: CollaborationEvent): void {
    // å¿½ç•¥è‡ªå·±å‘é€çš„äº‹ä»¶
    if (event.userId === this.userId) {
      return;
    }

    switch (event.type) {
      case 'node_add':
      case 'node_update':
      case 'node_delete':
      case 'edge_add':
      case 'edge_delete':
        this.emit('canvas_change', event);
        break;
      case 'cursor_move':
        this.emit('cursor_update', event);
        break;
    }

    this.emit('event', event);
  }

  sendEvent(type: CollaborationEvent['type'], data: any): void {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      console.warn('WebSocket not connected, cannot send event');
      return;
    }

    const event: CollaborationEvent = {
      id: this.generateEventId(),
      type,
      userId: this.userId!,
      canvasId: this.canvasId!,
      timestamp: Date.now(),
      data
    };

    this.ws.send(JSON.stringify(event));
  }

  updateCursor(position: { x: number; y: number }): void {
    this.sendEvent('cursor_move', { position });
  }

  private generateEventId(): string {
    return `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // Event handling
  on(event: string, handler: Function): void {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, []);
    }
    this.eventHandlers.get(event)!.push(handler);
  }

  off(event: string, handler: Function): void {
    const handlers = this.eventHandlers.get(event);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

  private emit(event: string, data?: any): void {
    const handlers = this.eventHandlers.get(event) || [];
    handlers.forEach(handler => {
      try {
        handler(data);
      } catch (error) {
        console.error(`Error in event handler for ${event}:`, error);
      }
    });
  }

  private setupEventHandlers(): void {
    // æ¸…ç†äº‹ä»¶å¤„ç†å™¨
    if (typeof window !== 'undefined') {
      window.addEventListener('beforeunload', () => {
        this.disconnect();
      });
    }
  }

  disconnect(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}

export const collaborationService = new CollaborationService();
```

#### 2.2 åä½œCanvasç»„ä»¶
```typescript
// src/components/collaboration/CollaborativeCanvas.tsx
import { useEffect, useState, useRef } from 'react';
import { collaborationService, CollaborationEvent, UserCursor } from '@/services/collaboration/CollaborationService';
import { useCanvasStore } from '@/stores/canvas-store';

interface CollaborativeCanvasProps {
  canvasId: string;
  userId: string;
  userName: string;
  onCanvasChange?: (event: CollaborationEvent) => void;
}

const CollaborativeCanvas: React.FC<CollaborativeCanvasProps> = ({
  canvasId,
  userId,
  userName,
  onCanvasChange
}) => {
  const [isConnected, setIsConnected] = useState(false);
  const [connectedUsers, setConnectedUsers] = useState<Map<string, UserCursor>>(new Map());
  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected'>('connecting');
  const { updateCanvas } = useCanvasStore();
  const canvasRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    connectToCollaboration();
    return () => {
      disconnectFromCollaboration();
    };
  }, [canvasId, userId]);

  const connectToCollaboration = async () => {
    try {
      setConnectionStatus('connecting');

      await collaborationService.connect(canvasId, userId);

      // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
      collaborationService.on('connected', handleConnected);
      collaborationService.on('disconnected', handleDisconnected);
      collaborationService.on('canvas_change', handleCanvasChange);
      collaborationService.on('cursor_update', handleCursorUpdate);
      collaborationService.on('reconnect_failed', handleReconnectFailed);

    } catch (error) {
      console.error('Failed to connect to collaboration:', error);
      setConnectionStatus('disconnected');
    }
  };

  const disconnectFromCollaboration = () => {
    collaborationService.disconnect();
    setConnectedUsers(new Map());
  };

  const handleConnected = () => {
    setIsConnected(true);
    setConnectionStatus('connected');
    console.log('Connected to collaboration service');
  };

  const handleDisconnected = () => {
    setIsConnected(false);
    setConnectionStatus('disconnected');
    console.log('Disconnected from collaboration service');
  };

  const handleCanvasChange = (event: CollaborationEvent) => {
    // å¤„ç†è¿œç¨‹Canvaså˜æ›´
    switch (event.type) {
      case 'node_add':
        updateCanvas((canvas) => {
          canvas.nodes.push(event.data);
          return canvas;
        });
        break;
      case 'node_update':
        updateCanvas((canvas) => {
          const nodeIndex = canvas.nodes.findIndex(n => n.id === event.data.id);
          if (nodeIndex !== -1) {
            canvas.nodes[nodeIndex] = { ...canvas.nodes[nodeIndex], ...event.data };
          }
          return canvas;
        });
        break;
      case 'node_delete':
        updateCanvas((canvas) => {
          canvas.nodes = canvas.nodes.filter(n => n.id !== event.data.id);
          return canvas;
        });
        break;
      case 'edge_add':
        updateCanvas((canvas) => {
          canvas.edges.push(event.data);
          return canvas;
        });
        break;
      case 'edge_delete':
        updateCanvas((canvas) => {
          canvas.edges = canvas.edges.filter(e => e.id !== event.data.id);
          return canvas;
        });
        break;
    }

    // é€šçŸ¥çˆ¶ç»„ä»¶
    if (onCanvasChange) {
      onCanvasChange(event);
    }
  };

  const handleCursorUpdate = (event: CollaborationEvent) => {
    const { userId: remoteUserId, data } = event;
    const cursor: UserCursor = {
      userId: remoteUserId,
      userName: data.userName,
      position: data.position,
      color: getUserColor(remoteUserId),
      lastSeen: Date.now()
    };

    setConnectedUsers(prev => new Map(prev).set(remoteUserId, cursor));
  };

  const handleReconnectFailed = () => {
    setConnectionStatus('disconnected');
    // å¯ä»¥åœ¨è¿™é‡Œæ˜¾ç¤ºé‡è¿å¤±è´¥çš„é€šçŸ¥
  };

  // å¤„ç†æœ¬åœ°Canvaså˜æ›´å¹¶å¹¿æ’­
  const handleLocalCanvasChange = (type: CollaborationEvent['type'], data: any) => {
    if (isConnected) {
      collaborationService.sendEvent(type, data);
    }
  };

  // å¤„ç†é¼ æ ‡ç§»åŠ¨
  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!isConnected || !canvasRef.current) return;

    const rect = canvasRef.current.getBoundingClientRect();
    const position = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };

    collaborationService.updateCursor(position);
  };

  // æ¸…ç†è¶…æ—¶çš„ç”¨æˆ·å…‰æ ‡
  useEffect(() => {
    const cleanupInterval = setInterval(() => {
      const now = Date.now();
      const timeout = 30000; // 30ç§’è¶…æ—¶

      setConnectedUsers(prev => {
        const updated = new Map();
        prev.forEach((cursor, userId) => {
          if (now - cursor.lastSeen < timeout) {
            updated.set(userId, cursor);
          }
        });
        return updated;
      });
    }, 10000); // æ¯10ç§’æ¸…ç†ä¸€æ¬¡

    return () => clearInterval(cleanupInterval);
  }, []);

  const getUserColor = (userId: string): string => {
    // åŸºäºç”¨æˆ·IDç”Ÿæˆä¸€è‡´çš„é¢œè‰²
    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
      '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'
    ];

    let hash = 0;
    for (let i = 0; i < userId.length; i++) {
      hash = userId.charCodeAt(i) + ((hash << 5) - hash);
    }

    return colors[Math.abs(hash) % colors.length];
  };

  return (
    <div className="collaborative-canvas" ref={canvasRef} onMouseMove={handleMouseMove}>
      {/* è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨ */}
      <div className={`connection-status ${connectionStatus}`}>
        <div className="status-indicator">
          {connectionStatus === 'connecting' && 'ğŸ”„ è¿æ¥ä¸­...'}
          {connectionStatus === 'connected' && 'ğŸŸ¢ å·²è¿æ¥'}
          {connectionStatus === 'disconnected' && 'ğŸ”´ å·²æ–­å¼€'}
        </div>
      </div>

      {/* åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ */}
      <div className="online-users">
        <h4>åœ¨çº¿ç”¨æˆ· ({connectedUsers.size + 1})</h4>
        <div className="user-list">
          {/* è‡ªå·± */}
          <div className="user-item self">
            <div
              className="user-avatar"
              style={{ backgroundColor: getUserColor(userId) }}
            >
              {userName.charAt(0).toUpperCase()}
            </div>
            <span className="user-name">{userName} (æˆ‘)</span>
          </div>

          {/* å…¶ä»–ç”¨æˆ· */}
          {Array.from(connectedUsers.values()).map(user => (
            <div key={user.userId} className="user-item">
              <div
                className="user-avatar"
                style={{ backgroundColor: user.color }}
              >
                {user.userName.charAt(0).toUpperCase()}
              </div>
              <span className="user-name">{user.userName}</span>
            </div>
          ))}
        </div>
      </div>

      {/* ç”¨æˆ·å…‰æ ‡ */}
      {Array.from(connectedUsers.values()).map(user => (
        <div
          key={user.userId}
          className="user-cursor"
          style={{
            left: user.position.x,
            top: user.position.y,
            borderColor: user.color
          }}
        >
          <div
            className="cursor-label"
            style={{ backgroundColor: user.color }}
          >
            {user.userName}
          </div>
        </div>
      ))}

      {/* Canvaså†…å®¹ */}
      <div className="canvas-content">
        {/* è¿™é‡Œæ¸²æŸ“å®é™…çš„Canvaså†…å®¹ */}
        <CanvasContent
          canvasId={canvasId}
          onCanvasChange={handleLocalCanvasChange}
        />
      </div>
    </div>
  );
};

// ç®€åŒ–çš„Canvaså†…å®¹ç»„ä»¶
const CanvasContent: React.FC<{
  canvasId: string;
  onCanvasChange: (type: CollaborationEvent['type'], data: any) => void;
}> = ({ canvasId, onCanvasChange }) => {
  // è¿™é‡Œåº”è¯¥æ˜¯å®é™…çš„Canvasæ¸²æŸ“é€»è¾‘
  // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥é›†æˆç°æœ‰çš„Canvasç»„ä»¶

  return (
    <div className="canvas-placeholder">
      <p>Canvas ID: {canvasId}</p>
      <p>Canvaså†…å®¹å°†åœ¨è¿™é‡Œæ¸²æŸ“</p>
    </div>
  );
};

export default CollaborativeCanvas;
```

### 3. ç§»åŠ¨ç«¯é€‚é…

#### 3.1 å“åº”å¼è®¾è®¡ä¼˜åŒ–
```typescript
// src/hooks/useResponsive.ts
import { useState, useEffect } from 'react';

export interface Breakpoints {
  xs: number;  // 0-575px
  sm: number;  // 576-767px
  md: number;  // 768-991px
  lg: number;  // 992-1199px
  xl: number;  // 1200px+
}

export const breakpoints: Breakpoints = {
  xs: 575,
  sm: 767,
  md: 991,
  lg: 1199,
  xl: 1200
};

export interface ResponsiveInfo {
  width: number;
  height: number;
  isMobile: boolean;
  isTablet: boolean;
  isDesktop: boolean;
  breakpoint: keyof Breakpoints;
  orientation: 'portrait' | 'landscape';
}

export const useResponsive = (): ResponsiveInfo => {
  const [windowSize, setWindowSize] = useState({
    width: typeof window !== 'undefined' ? window.innerWidth : 1200,
    height: typeof window !== 'undefined' ? window.innerHeight : 800
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const { width, height } = windowSize;

  const getBreakpoint = (): keyof Breakpoints => {
    if (width <= breakpoints.xs) return 'xs';
    if (width <= breakpoints.sm) return 'sm';
    if (width <= breakpoints.md) return 'md';
    if (width <= breakpoints.lg) return 'lg';
    return 'xl';
  };

  const breakpoint = getBreakpoint();
  const isMobile = width <= breakpoints.sm;
  const isTablet = width > breakpoints.sm && width <= breakpoints.md;
  const isDesktop = width > breakpoints.md;
  const orientation = width > height ? 'landscape' : 'portrait';

  return {
    width,
    height,
    isMobile,
    isTablet,
    isDesktop,
    breakpoint,
    orientation
  };
};
```

#### 3.2 è§¦æ‘¸æ‰‹åŠ¿æ”¯æŒ
```typescript
// src/hooks/useTouchGestures.ts
import { useRef, useCallback } from 'react';

export interface TouchGestureOptions {
  onSwipeLeft?: () => void;
  onSwipeRight?: () => void;
  onSwipeUp?: () => void;
  onSwipeDown?: () => void;
  onPinch?: (scale: number) => void;
  onTap?: () => void;
  onDoubleTap?: () => void;
  swipeThreshold?: number;
  pinchThreshold?: number;
}

export const useTouchGestures = (options: TouchGestureOptions = {}) => {
  const touchStartRef = useRef<{ x: number; y: number; time: number } | null>(null);
  const lastTouchRef = useRef<{ x: number; y: number; time: number } | null>(null);
  const initialDistanceRef = useRef<number>(0);

  const {
    onSwipeLeft,
    onSwipeRight,
    onSwipeUp,
    onSwipeDown,
    onPinch,
    onTap,
    onDoubleTap,
    swipeThreshold = 50,
    pinchThreshold = 10
  } = options;

  const handleTouchStart = useCallback((e: React.TouchEvent) => {
    if (e.touches.length === 1) {
      const touch = e.touches[0];
      touchStartRef.current = {
        x: touch.clientX,
        y: touch.clientY,
        time: Date.now()
      };
    } else if (e.touches.length === 2) {
      // è®°å½•ä¸¤æŒ‡åˆå§‹è·ç¦»
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      initialDistanceRef.current = Math.sqrt(dx * dx + dy * dy);
    }
  }, []);

  const handleTouchMove = useCallback((e: React.TouchEvent) => {
    if (e.touches.length === 2 && onPinch) {
      // è®¡ç®—å½“å‰ä¸¤æŒ‡è·ç¦»
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const currentDistance = Math.sqrt(dx * dx + dy * dy);

      if (initialDistanceRef.current > 0) {
        const scale = currentDistance / initialDistanceRef.current;
        onPinch(scale);
      }
    }
  }, [onPinch]);

  const handleTouchEnd = useCallback((e: React.TouchEvent) => {
    if (!touchStartRef.current) return;

    const touch = e.changedTouches[0];
    const deltaX = touch.clientX - touchStartRef.current.x;
    const deltaY = touch.clientY - touchStartRef.current.y;
    const deltaTime = Date.now() - touchStartRef.current.time;

    const absDeltaX = Math.abs(deltaX);
    const absDeltaY = Math.abs(deltaY);

    // æ£€æµ‹æ»‘åŠ¨æ‰‹åŠ¿
    if (deltaTime < 500 && (absDeltaX > swipeThreshold || absDeltaY > swipeThreshold)) {
      if (absDeltaX > absDeltaY) {
        // æ°´å¹³æ»‘åŠ¨
        if (deltaX > 0 && onSwipeRight) {
          onSwipeRight();
        } else if (deltaX < 0 && onSwipeLeft) {
          onSwipeLeft();
        }
      } else {
        // å‚ç›´æ»‘åŠ¨
        if (deltaY > 0 && onSwipeDown) {
          onSwipeDown();
        } else if (deltaY < 0 && onSwipeUp) {
          onSwipeUp();
        }
      }
    }
    // æ£€æµ‹ç‚¹å‡»æ‰‹åŠ¿
    else if (absDeltaX < 10 && absDeltaY < 10 && deltaTime < 200) {
      if (lastTouchRef.current && (Date.now() - lastTouchRef.current.time) < 300) {
        // åŒå‡»
        if (onDoubleTap) onDoubleTap();
      } else {
        // å•å‡»
        if (onTap) onTap();
      }
    }

    // è®°å½•æœ€åä¸€æ¬¡è§¦æ‘¸
    lastTouchRef.current = {
      x: touch.clientX,
      y: touch.clientY,
      time: Date.now()
    };

    touchStartRef.current = null;
  }, [
    onSwipeLeft, onSwipeRight, onSwipeUp, onSwipeDown,
    onPinch, onTap, onDoubleTap, swipeThreshold
  ]);

  return {
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd
  };
};
```

#### 3.3 ç§»åŠ¨ç«¯Canvasç»„ä»¶
```typescript
// src/components/canvas/MobileCanvas.tsx
import { useState, useRef, useEffect } from 'react';
import { useResponsive } from '@/hooks/useResponsive';
import { useTouchGestures } from '@/hooks/useTouchGestures';

interface MobileCanvasProps {
  canvasId: string;
  onNodeSelect?: (nodeId: string) => void;
  onCanvasEdit?: (editData: any) => void;
}

const MobileCanvas: React.FC<MobileCanvasProps> = ({
  canvasId,
  onNodeSelect,
  onCanvasEdit
}) => {
  const { isMobile, isTablet } = useResponsive();
  const [scale, setScale] = useState(1);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const canvasRef = useRef<HTMLDivElement>(null);

  // è§¦æ‘¸æ‰‹åŠ¿å¤„ç†
  const touchGestures = useTouchGestures({
    onSwipeLeft: () => {
      // å·¦æ»‘åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªCanvas
      console.log('Swipe left - next canvas');
    },
    onSwipeRight: () => {
      // å³æ»‘åˆ‡æ¢åˆ°ä¸Šä¸€ä¸ªCanvas
      console.log('Swipe right - previous canvas');
    },
    onPinch: (newScale) => {
      // ç¼©æ”¾Canvas
      setScale(Math.max(0.5, Math.min(3, newScale)));
    }
  });

  // æ‹–æ‹½å¤„ç†
  const handleMouseDown = (e: React.MouseEvent) => {
    if (e.button === 0 && !e.target || !(e.target as HTMLElement).closest('.canvas-node')) {
      setIsDragging(true);
      setDragStart({
        x: e.clientX - position.x,
        y: e.clientY - position.y
      });
    }
  };

  const handleMouseMove = (e: React.MouseEvent) => {
    if (isDragging) {
      setPosition({
        x: e.clientX - dragStart.x,
        y: e.clientY - dragStart.y
      });
    }
  };

  const handleMouseUp = () => {
    setIsDragging(false);
  };

  // é‡ç½®è§†å›¾
  const resetView = () => {
    setScale(1);
    setPosition({ x: 0, y: 0 });
  };

  // è‡ªé€‚åº”å±å¹•
  const fitToScreen = () => {
    if (canvasRef.current) {
      const container = canvasRef.current.parentElement;
      if (container) {
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        // è®¡ç®—Canvaså†…å®¹çš„è¾¹ç•Œ
        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„è¾¹ç•Œ
        const contentWidth = 1200;
        const contentHeight = 800;

        const scaleX = containerWidth / contentWidth;
        const scaleY = containerHeight / contentHeight;
        const newScale = Math.min(scaleX, scaleY, 1);

        setScale(newScale);
        setPosition({
          x: (containerWidth - contentWidth * newScale) / 2,
          y: (containerHeight - contentHeight * newScale) / 2
        });
      }
    }
  };

  useEffect(() => {
    if (isMobile || isTablet) {
      fitToScreen();
    }
  }, [isMobile, isTablet]);

  if (!isMobile && !isTablet) {
    // æ¡Œé¢ç«¯ä½¿ç”¨æ ‡å‡†Canvasç»„ä»¶
    return <StandardCanvas canvasId={canvasId} />;
  }

  return (
    <div className="mobile-canvas-container">
      {/* ç§»åŠ¨ç«¯å·¥å…·æ  */}
      <div className="mobile-toolbar">
        <button onClick={resetView} className="toolbar-button">
          ğŸ  é‡ç½®
        </button>
        <button onClick={fitToScreen} className="toolbar-button">
          ğŸ“ é€‚åº”
        </button>
        <div className="zoom-controls">
          <button
            onClick={() => setScale(Math.max(0.5, scale - 0.1))}
            className="toolbar-button"
          >
            â–
          </button>
          <span className="zoom-level">{Math.round(scale * 100)}%</span>
          <button
            onClick={() => setScale(Math.min(3, scale + 0.1))}
            className="toolbar-button"
          >
            â•
          </button>
        </div>
      </div>

      {/* Canvasè§†å£ */}
      <div
        className="mobile-canvas-viewport"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        {...touchGestures}
      >
        <div
          ref={canvasRef}
          className="mobile-canvas-content"
          style={{
            transform: `translate(${position.x}px, ${position.y}px) scale(${scale})`,
            transformOrigin: '0 0',
            cursor: isDragging ? 'grabbing' : 'grab'
          }}
        >
          {/* CanvasèŠ‚ç‚¹æ¸²æŸ“ */}
          <CanvasNodes
            canvasId={canvasId}
            scale={scale}
            onNodeSelect={onNodeSelect}
            onEdit={onCanvasEdit}
          />
        </div>
      </div>

      {/* ç§»åŠ¨ç«¯å¯¼èˆªæç¤º */}
      <div className="mobile-hints">
        <div className="hint-item">
          <span className="hint-icon">ğŸ‘†</span>
          <span className="hint-text">å•æŒ‡æ‹–åŠ¨ç§»åŠ¨</span>
        </div>
        <div className="hint-item">
          <span className="hint-icon">ğŸ¤</span>
          <span className="hint-text">åŒæŒ‡ç¼©æ”¾</span>
        </div>
        <div className="hint-item">
          <span className="hint-icon">ğŸ‘ˆğŸ‘‰</span>
          <span className="hint-text">å·¦å³æ»‘åŠ¨åˆ‡æ¢</span>
        </div>
      </div>
    </div>
  );
};

// ç®€åŒ–çš„èŠ‚ç‚¹ç»„ä»¶
const CanvasNodes: React.FC<{
  canvasId: string;
  scale: number;
  onNodeSelect?: (nodeId: string) => void;
  onEdit?: (editData: any) => void;
}> = ({ canvasId, scale, onNodeSelect, onEdit }) => {
  // è¿™é‡Œåº”è¯¥æ¸²æŸ“å®é™…çš„CanvasèŠ‚ç‚¹
  // ç®€åŒ–å®ç°

  return (
    <div className="canvas-nodes">
      <div
        className="canvas-node"
        style={{
          fontSize: `${16 / scale}px`,
          minWidth: `${120 / scale}px`,
          minHeight: `${80 / scale}px`
        }}
        onClick={() => onNodeSelect?.('node-1')}
      >
        ç¤ºä¾‹èŠ‚ç‚¹ 1
      </div>
    </div>
  );
};

// æ¡Œé¢ç«¯Canvasç»„ä»¶å ä½ç¬¦
const StandardCanvas: React.FC<{ canvasId: string }> = ({ canvasId }) => {
  return <div>æ¡Œé¢ç«¯Canvasç»„ä»¶ (ID: {canvasId})</div>;
};

export default MobileCanvas;
```

## ğŸ“‹ ä»»åŠ¡åˆ†è§£

### Sprint 1: æ™ºèƒ½æ¨èç³»ç»Ÿ (1å‘¨)

#### Story 9.8.8.1: æ¨èå¼•æ“æ¶æ„
- **ä»»åŠ¡**: è®¾è®¡å’Œå®ç°æ¨èå¼•æ“æ ¸å¿ƒæ¶æ„
- **éªŒæ”¶æ ‡å‡†**:
  - RecommendationEngineç±»å®ç°å®Œæˆ
  - æ”¯æŒ5ç§æ¨èç­–ç•¥
  - æ¨èç®—æ³•æ¥å£å®šä¹‰æ¸…æ™°
  - æ¨èç»“æœæ’åºå’Œå»é‡æ­£å¸¸

#### Story 9.8.8.2: æ¨èç­–ç•¥å®ç°
- **ä»»åŠ¡**: å®ç°å‘½ä»¤é¢‘ç‡ã€å­¦ä¹ è¿›åº¦ã€æ—¶é—´æ¨¡å¼ç­‰æ¨èç­–ç•¥
- **éªŒæ”¶æ ‡å‡†**:
  - CommandFrequencyStrategyå®ç°
  - LearningProgressStrategyå®ç°
  - TimePatternStrategyå®ç°
  - æ¨èå‡†ç¡®æ€§ >70%

#### Story 9.8.8.3: æ¨èUIç»„ä»¶
- **ä»»åŠ¡**: åˆ›å»ºæ¨èé¢æ¿å’Œæ¨èé¡¹å±•ç¤ºç»„ä»¶
- **éªŒæ”¶æ ‡å‡†**:
  - RecommendationPanelç»„ä»¶å®Œæˆ
  - æ”¯æŒæ¨èé¡¹ç‚¹å‡»å’Œå¿½ç•¥
  - æ¨èç†ç”±æ˜¾ç¤ºæ¸…æ™°
  - å“åº”å¼è®¾è®¡é€‚é…

#### Story 9.8.8.4: ç”¨æˆ·è¡Œä¸ºåˆ†æ
- **ä»»åŠ¡**: å®ç°ç”¨æˆ·è¡Œä¸ºæ•°æ®æ”¶é›†å’Œåˆ†æ
- **éªŒæ”¶æ ‡å‡†**:
  - UserBehaviorStoreå®ç°
  - è¡Œä¸ºæ•°æ®æ­£ç¡®è®°å½•
  - æ¨èæ•ˆæœè¿½è¸ªæœºåˆ¶
  - æ•°æ®éšç§ä¿æŠ¤åˆ°ä½

### Sprint 2: å®æ—¶åä½œåŠŸèƒ½ (1å‘¨)

#### Story 9.8.8.5: WebSocketåä½œæœåŠ¡
- **ä»»åŠ¡**: å®ç°å®æ—¶åä½œçš„WebSocketé€šä¿¡
- **éªŒæ”¶æ ‡å‡†**:
  - CollaborationServiceå®ç°å®Œæˆ
  - WebSocketè¿æ¥ç¨³å®š
  - è‡ªåŠ¨é‡è¿æœºåˆ¶å·¥ä½œ
  - äº‹ä»¶åŒæ­¥å»¶è¿Ÿ <100ms

#### Story 9.8.8.6: åä½œCanvasç»„ä»¶
- **ä»»åŠ¡**: åˆ›å»ºæ”¯æŒå¤šç”¨æˆ·åä½œçš„Canvasç»„ä»¶
- **éªŒæ”¶æ ‡å‡†**:
  - CollaborativeCanvasç»„ä»¶å®Œæˆ
  - å®æ—¶æ˜¾ç¤ºç”¨æˆ·å…‰æ ‡
  - Canvaså˜æ›´å®æ—¶åŒæ­¥
  - å†²çªæ£€æµ‹å’Œè§£å†³æœºåˆ¶

#### Story 9.8.8.7: æƒé™ç®¡ç†ç³»ç»Ÿ
- **ä»»åŠ¡**: å®ç°åä½œæƒé™æ§åˆ¶å’Œç”¨æˆ·ç®¡ç†
- **éªŒæ”¶æ ‡å‡†**:
  - ç”¨æˆ·è§’è‰²æƒé™å®šä¹‰
  - Canvasè®¿é—®æ§åˆ¶
  - ç¼–è¾‘æƒé™ç®¡ç†
  - åä½œå†å²è®°å½•

### Sprint 3: ç§»åŠ¨ç«¯é€‚é… (0.5å‘¨)

#### Story 9.8.8.8: å“åº”å¼è®¾è®¡ä¼˜åŒ–
- **ä»»åŠ¡**: ä¼˜åŒ–ç§»åŠ¨ç«¯å¸ƒå±€å’Œäº¤äº’
- **éªŒæ”¶æ ‡å‡†**:
  - å“åº”å¼æ–­ç‚¹è®¾è®¡åˆç†
  - ç§»åŠ¨ç«¯å¯¼èˆªå‹å¥½
  - è§¦æ‘¸ç›®æ ‡å¤§å°åˆé€‚
  - æ¨ªç«–å±é€‚é…æ­£å¸¸

#### Story 9.8.8.9: è§¦æ‘¸æ‰‹åŠ¿æ”¯æŒ
- **ä»»åŠ¡**: å®ç°ç§»åŠ¨ç«¯è§¦æ‘¸æ‰‹åŠ¿æ“ä½œ
- **éªŒæ”¶æ ‡å‡†**:
  - æ‹–æ‹½ã€ç¼©æ”¾ã€æ»‘åŠ¨æ‰‹åŠ¿æ”¯æŒ
  - æ‰‹åŠ¿å“åº”çµæ•å‡†ç¡®
  - å¤šæŒ‡æ‰‹åŠ¿æ­£ç¡®è¯†åˆ«
  - æ‰‹åŠ¿å†²çªå¤„ç†åˆç†

#### Story 9.8.8.10: ç§»åŠ¨ç«¯Canvasä¼˜åŒ–
- **ä»»åŠ¡**: ä¼˜åŒ–ç§»åŠ¨ç«¯Canvasæ€§èƒ½å’Œä½“éªŒ
- **éªŒæ”¶æ ‡å‡†**:
  - Canvasåœ¨ç§»åŠ¨ç«¯æµç•…è¿è¡Œ
  - è§¦æ‘¸äº¤äº’å“åº”åŠæ—¶
  - ç§»åŠ¨ç«¯å·¥å…·æ å®ç”¨
  - è‡ªé€‚åº”ç¼©æ”¾å’Œå®šä½

#### Story 9.8.8.11: é›†æˆæµ‹è¯•å’Œæ€§èƒ½ä¼˜åŒ–
- **ä»»åŠ¡**: å®Œæˆé«˜çº§åŠŸèƒ½é›†æˆæµ‹è¯•å’Œæ€§èƒ½è°ƒä¼˜
- **éªŒæ”¶æ ‡å‡†**:
  - æ‰€æœ‰æ–°åŠŸèƒ½æ­£å¸¸è¿è¡Œ
  - æ¨èå‡†ç¡®ç‡ >80%
  - åä½œå»¶è¿Ÿ <200ms
  - ç§»åŠ¨ç«¯æ€§èƒ½è¾¾æ ‡

## ğŸ”§ æŠ€æœ¯è¦æ±‚

### æ–°å¢ä¾èµ–åŒ…
```json
{
  "dependencies": {
    "recharts": "^2.8.0", // ç”¨äºæ¨èå¯è§†åŒ–
    "uuid": "^9.0.1",    // ç”¨äºç”Ÿæˆå”¯ä¸€ID
    "date-fns": "^2.30.0" // ç”¨äºæ—¶é—´å¤„ç†
  },
  "devDependencies": {
    "@types/uuid": "^9.0.7"
  }
}
```

### WebSocketæœåŠ¡ç«¯è¦æ±‚
- Node.js WebSocketæœåŠ¡å™¨
- Redisç”¨äºä¼šè¯ç®¡ç†
- äº‹ä»¶å¹¿æ’­æœºåˆ¶
- è¿æ¥æ± ç®¡ç†

### ç§»åŠ¨ç«¯å…¼å®¹æ€§
- iOS Safari 12+
- Android Chrome 80+
- è§¦æ‘¸äº‹ä»¶æ”¯æŒ
- å“åº”å¼å¸ƒå±€

## ğŸ¯ éªŒæ”¶æ ‡å‡†

### æ™ºèƒ½æ¨èéªŒæ”¶
- [ ] æ¨èå‡†ç¡®ç‡ >80%
- [ ] æ¨èå“åº”æ—¶é—´ <500ms
- [ ] æ¨èç†ç”±æ¸…æ™°å¯ä¿¡
- [ ] ç”¨æˆ·äº¤äº’è¿½è¸ªæ­£å¸¸
- [ ] æ¨èæ•ˆæœå¯é‡åŒ–

### å®æ—¶åä½œéªŒæ”¶
- [ ] å¤šç”¨æˆ·åŒæ—¶ç¼–è¾‘æ­£å¸¸
- [ ] å®æ—¶åŒæ­¥å»¶è¿Ÿ <200ms
- [ ] è¿æ¥ç¨³å®šæ€§ >99%
- [ ] å†²çªè§£å†³æœºåˆ¶æœ‰æ•ˆ
- [ ] æƒé™æ§åˆ¶æ­£ç¡®

### ç§»åŠ¨ç«¯éªŒæ”¶
- [ ] è§¦æ‘¸äº¤äº’æµç•…
- [ ] å“åº”å¼å¸ƒå±€å®Œç¾
- [ ] æ‰‹åŠ¿è¯†åˆ«å‡†ç¡®
- [ ] æ€§èƒ½è¡¨ç°è‰¯å¥½
- [ ] ç”¨æˆ·ä½“éªŒå‹å¥½

## ğŸš¨ é£é™©è¯„ä¼°

### é«˜é£é™©
- **æ¨èç®—æ³•å¤æ‚æ€§**: ç®—æ³•å®ç°å¯èƒ½æ¯”é¢„æœŸå¤æ‚
- **WebSocketç¨³å®šæ€§**: å®æ—¶åä½œçš„è¿æ¥ç¨³å®šæ€§æŒ‘æˆ˜

### ä¸­é£é™©
- **ç§»åŠ¨ç«¯æ€§èƒ½**: ç§»åŠ¨è®¾å¤‡æ€§èƒ½é™åˆ¶
- **ç”¨æˆ·æ¥å—åº¦**: æ–°åŠŸèƒ½çš„å­¦ä¹ æˆæœ¬

### ç¼“è§£æªæ–½
- åˆ†é˜¶æ®µå®ç°æ¨èç®—æ³•ï¼Œä»ç®€å•åˆ°å¤æ‚
- å®Œå–„çš„WebSocketé‡è¿å’Œé”™è¯¯å¤„ç†æœºåˆ¶
- ç§»åŠ¨ç«¯æ€§èƒ½ä¼˜åŒ–å’Œæ¸è¿›å¼åŠŸèƒ½åŠ è½½
- è¯¦ç»†çš„ç”¨æˆ·æŒ‡å—å’Œå¸®åŠ©æ–‡æ¡£

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [Epic 9.8.6: å‰ç«¯åŸºç¡€æ¶æ„å¢å¼º](./epic-9.8.6-frontend-architecture-enhancement.md)
- [Epic 9.8.7: æ€§èƒ½å’Œä½“éªŒä¼˜åŒ–](./epic-9.8.7-performance-optimization.md)
- [WebSocketæœ€ä½³å®è·µ](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
- [ç§»åŠ¨ç«¯æ€§èƒ½ä¼˜åŒ–æŒ‡å—](https://web.dev/mobile-performance/)

## ğŸ“Š æˆåŠŸæŒ‡æ ‡

### æ™ºèƒ½æ¨èæŒ‡æ ‡
- æ¨èç‚¹å‡»ç‡ >15%
- æ¨èé‡‡çº³ç‡ >10%
- ç”¨æˆ·æ»¡æ„åº¦ >4.0/5.0
- æ¨èç®—æ³•å“åº”æ—¶é—´ <500ms

### å®æ—¶åä½œæŒ‡æ ‡
- å¹¶å‘ç”¨æˆ·æ•° >50
- åŒæ­¥å»¶è¿Ÿ <200ms
- è¿æ¥ç¨³å®šæ€§ >99%
- åä½œåŠŸèƒ½ä½¿ç”¨ç‡ >30%

### ç§»åŠ¨ç«¯æŒ‡æ ‡
- ç§»åŠ¨ç«¯è®¿é—®å æ¯” >40%
- è§¦æ‘¸äº¤äº’æˆåŠŸç‡ >95%
- ç§»åŠ¨ç«¯æ€§èƒ½è¯„åˆ† >90
- ç§»åŠ¨ç«¯ç”¨æˆ·ç•™å­˜ç‡ >85%

---

**Epic 9.8.8 é«˜çº§åŠŸèƒ½å®ç°**å°†é€šè¿‡æ™ºèƒ½æ¨èã€å®æ—¶åä½œå’Œç§»åŠ¨ç«¯é€‚é…ï¼Œå°†Canvas Learning Systemå‡çº§ä¸ºç°ä»£åŒ–çš„æ™ºèƒ½ååŒå­¦ä¹ å¹³å°ï¼Œä¸ºç”¨æˆ·æä¾›æ›´åŠ æ™ºèƒ½åŒ–ã€ä¸ªæ€§åŒ–çš„å­¦ä¹ ä½“éªŒã€‚è¿™æ˜¯Canvaså­¦ä¹ ç³»ç»Ÿå®ç°å…¨é¢æ™ºèƒ½åŒ–å’Œç§»åŠ¨åŒ–çš„å…³é”®é˜¶æ®µã€‚ ğŸš€
